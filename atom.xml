<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>微风的博客</title>
  
  
  <link href="https://weifeng233.github.io/atom.xml" rel="self"/>
  
  <link href="https://weifeng233.github.io/"/>
  <updated>2024-02-16T19:21:26.931Z</updated>
  <id>https://weifeng233.github.io/</id>
  
  <author>
    <name>SugarBreeze</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>半小时速通Rust</title>
    <link href="https://weifeng233.github.io/2024/02/17/%E5%8D%8A%E5%B0%8F%E6%97%B6%E9%80%9F%E9%80%9ARust/"/>
    <id>https://weifeng233.github.io/2024/02/17/%E5%8D%8A%E5%B0%8F%E6%97%B6%E9%80%9F%E9%80%9ARust/</id>
    <published>2024-02-16T19:20:11.922Z</published>
    <updated>2024-02-16T19:21:26.931Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>编程语言不学Rust，就如同游戏不玩原神</p></blockquote><p><em>本文翻译自<a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half-hour to learn Rust</a></em></p><hr><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><code>let</code>用于声明变量绑定(<em>binding</em>)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x; <span class="comment">// 声明 x</span></span><br><span class="line">x = <span class="number">42</span>; <span class="comment">// 将 42 赋值给 x</span></span><br></pre></td></tr></table></figure><p>也可以写成一行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>可以通过<code>:</code>来显式指定变量类型，即类型注释：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">i32</span>; <span class="comment">// `i32` 为 32 位有符号整型</span></span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 在Rust中，整型有 i8, i16, i32, i64, 128</span></span><br><span class="line"><span class="comment">// 以及对应的无符号类型 u8, u16, u32, u64, u128</span></span><br></pre></td></tr></table></figure><p>也可以写成一行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>如果你在声明变量后，初始化前使用变量，则会被编译器阻止：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">foobar(x); <span class="comment">// error: borrow of possibly-uninitialized variable: `x`</span></span><br><span class="line">x = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>这样则没问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line">foobar(x); <span class="comment">// `x` 的类型将会根据此处推断</span></span><br></pre></td></tr></table></figure><p>下划线<code>_</code>是一个特殊的变量名称，即缺省名称。通常使用<code>_</code>说明丢弃一些东西：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _ = <span class="number">42</span>; <span class="comment">// 将不会做任何事，因为 42 是一个常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _ = get_thing(); <span class="comment">// 调用 `get_thing` 但丢弃返回值</span></span><br></pre></td></tr></table></figure><p>变量可以以下划线开头，除了编译器不会警告它们未被使用之外与普通变量名一样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `_x` 可能最终会被用到，但是目前代码还没有完成，并且当前不想看到编译器对其的警告</span></span><br><span class="line"><span class="keyword">let</span> _x = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>可以引入相同名称的变量绑定，进而隐藏原先的变量绑定：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">let</span> x = x + <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 之后使用 `x` 仅指代第二个 `x`， 第一个 `x` 不再存在</span></span><br></pre></td></tr></table></figure><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>元组(<em>Tuple</em>)可以将其视作不同类型值的定长集合：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pair = (<span class="string">&#x27;a&#x27;</span>, <span class="number">17</span>);</span><br><span class="line">pair.<span class="number">0</span> <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">pair.<span class="number">1</span> <span class="comment">// 17</span></span><br></pre></td></tr></table></figure><p>若要给元组添加类型注释，则可以：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pair: (<span class="built_in">char</span>, <span class="built_in">i32</span>) = (<span class="string">&#x27;a&#x27;</span>, <span class="number">17</span>);</span><br></pre></td></tr></table></figure><p>在进行赋值的时候元组可以被解构，即可以分解为独立的字段：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (some_char, some_int) = (<span class="string">&#x27;a&#x27;</span>, <span class="number">17</span>);</span><br></pre></td></tr></table></figure><p>在函数返回元组时非常有用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (left, right) = slice.split_at(middle);</span><br></pre></td></tr></table></figure><p>当然，在结构元组的时候也可以使用<code>_</code>来丢弃其中一部分：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (_, right) = slice.split_at(middle);</span><br></pre></td></tr></table></figure><h3 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h3><p>分号标志着语句的结束：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> z = x + y;</span><br></pre></td></tr></table></figure><p>这意味着语句可以跨越多行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">    .iter()</span><br><span class="line">    .map(|x| x + <span class="number">3</span>)</span><br><span class="line">    .fold(<span class="number">0</span>, |x, y| x + y);</span><br></pre></td></tr></table></figure><p>（后文会对其作讲解）</p><h3 id="fn"><a href="#fn" class="headerlink" title="fn"></a>fn</h3><p><code>fn</code>用于声明函数<br>这是一个无返回值的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">greet</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hi there!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个返回 32 位有符号整型的函数。用箭头来表示其返回值类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fair_dice_roll</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>花括号对<code>&#123;&#125;</code>用于声明块(<em>Block</em>)，它有自己的作用域：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该程序会先输出 &quot;in&quot; 然后是 &quot;out&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">&quot;out&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此处是另一个 `x`</span></span><br><span class="line">        <span class="keyword">let</span> x = <span class="string">&quot;in&quot;</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>块也是表达式，这意味着其计算结果也是一个值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两行是等价的</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="number">42</span> &#125;;</span><br></pre></td></tr></table></figure><p>在一个块内可以有多条语句：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">1</span>; <span class="comment">// 第一条语句</span></span><br><span class="line">    <span class="keyword">let</span> z = <span class="number">2</span>; <span class="comment">// 第二条语句</span></span><br><span class="line">    y + z <span class="comment">// 这里是*尾巴* - 整个块会被认定的表达式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就是为什么”省略函数末尾的分号“与<code>return</code>是相同的，即以下写法是等效的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fair_dice_roll</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fair_dice_roll</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code> 条件也是表达式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fair_dice_roll</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> feeling_lucky &#123;</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>match</code>也是表达式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fair_dice_roll</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> feeling_lucky &#123;</span><br><span class="line">        <span class="literal">true</span> =&gt; <span class="number">6</span>,</span><br><span class="line">        <span class="literal">false</span> =&gt; <span class="number">4</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>表达式总会返回值</strong>，能返回值的就是表达式，表达式不能以分号结尾，否则就变成了语句，不再返回值，若表达式不返回值，则会隐式地返回一个<code>()</code>。<br>点<code>.</code>通常用于访问值的字段：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = (<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">a.<span class="number">0</span>; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> amos = get_some_struct();</span><br><span class="line">amos.nickname; <span class="comment">// &quot;fasterthanlime&quot;</span></span><br></pre></td></tr></table></figure><p>或者对值调用方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nick = <span class="string">&quot;fasterthanlime&quot;</span>;</span><br><span class="line">nick.len(); <span class="comment">// 14</span></span><br></pre></td></tr></table></figure><p>双冒号<code>::</code>与其类似，但是它使用在命名空间上。<br>在此示例中，<code>std</code>是一个包(<em>crate</em>)（或者说库），<code>cmp</code>是一个模块(<em>module</em>)（或者说源文件），以及<code>min</code>是一个函数(<em>function</em>)：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> least = std::cmp::min(<span class="number">3</span>, <span class="number">8</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><code>use</code>可用于从其他命名空间引入名称到作用域：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::min;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> least = min(<span class="number">7</span>, <span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>使用<code>use</code>时，花括号还有另一种含义，即 <em>glob</em>。如果我们想同时导入<code>min</code>和<code>max</code>，我们可以使用以下任意一种方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::min;</span><br><span class="line"><span class="keyword">use</span> std::cmp::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::cmp::&#123;min, max&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::min, cmp::max&#125;;</span><br></pre></td></tr></table></figure><p>通配符<code>*</code>允许你从命名空间导入所有符号：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这将会将 `min` 和 `max` 以及许多其他东西导入到当前作用域</span></span><br><span class="line"><span class="keyword">use</span> std::cmp::*;</span><br></pre></td></tr></table></figure><p>类型也是命名空间，方法可以作为常规函数调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">&quot;amos&quot;</span>.len(); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="built_in">str</span>::len(<span class="string">&quot;amos&quot;</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><code>str</code>是原始类型，但默认情况下许多非原始类型也包含在作用域内：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `Vec` 是一个常规的结构体，不是原始类型</span></span><br><span class="line"><span class="keyword">let</span> v = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上面的代码相同，但是使用了 `Vec` 的完整路径</span></span><br><span class="line"><span class="keyword">let</span> v = std::vec::<span class="built_in">Vec</span>::new();</span><br></pre></td></tr></table></figure><p>这之所以有效是因为 Rust 会在每个模块的开头插入以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::prelude::v1::*;</span><br></pre></td></tr></table></figure><p>这会重新导出很多符号，例如<code>Vec</code>，<code>String</code>，<code>Option</code>和<code>Result</code>。</p><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>结构体使用<code>struct</code>关键字声明：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f64</span>, <span class="comment">// 64 位浮点数，即双精度</span></span><br><span class="line">    y: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们可以通过结构体字面量初始化：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1 = Vec2 &#123; x: <span class="number">1.0</span>, y: <span class="number">3.0</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> v2 = Vec2 &#123; y: <span class="number">2.0</span>, x: <span class="number">4.0</span>&#125;;</span><br><span class="line"><span class="comment">// 顺序不需要关注，只需要关注名称</span></span><br></pre></td></tr></table></figure><p>有一种简便写法可以从另一个结构体初始化剩余的字段：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v3 = Vec2 &#123;</span><br><span class="line">    x: <span class="number">14.0</span>,</span><br><span class="line">    ..v2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这被称为”结构体更新语法“，只能用在最后一个位置，且后面不能跟逗号。<br>注意，其余字段可以表示所有字段：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v4 = Vec2 &#123; ..v3 &#125;;</span><br></pre></td></tr></table></figure><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>结构体与元组一样，可以被解构。<br>就和以下是一个有效的<code>let</code>模式一样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (left, right)  slice.split_at(middle);</span><br></pre></td></tr></table></figure><p>以下也是如此：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = Vec2 &#123; x: <span class="number">3.0</span>, y: <span class="number">6.0</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> Vec2 &#123; x, y &#125; = v;</span><br><span class="line"><span class="comment">// `x` 为 3.0， `y` 为 6.0</span></span><br></pre></td></tr></table></figure><p>以及这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vec2 &#123; x, ..&#125; = v;</span><br><span class="line"><span class="comment">// 将会忽略 `v.y`</span></span><br></pre></td></tr></table></figure><p>模式是 Rust 中的特殊语法，它用来匹配类型中的结构和数据，它往往和 <code>match</code> 表达式联用，以实现强大的模式匹配能力。模式一般由以下内容组合而成：</p><ul><li>字面值</li><li>解构的数组、枚举、结构体或者元组</li><li>变量</li><li>通配符</li><li>占位符<br><code>let</code>模式可以用作<code>if</code>的条件：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number</span></span> &#123;</span><br><span class="line">    odd: <span class="built_in">bool</span>,</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> one = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> two = Number &#123; odd: <span class="literal">false</span>, value: <span class="number">2</span> &#125;;</span><br><span class="line">    print_number(one);</span><br><span class="line">    print_number(two);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: Number) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Number &#123; odd: <span class="literal">true</span>, value &#125; = n &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Odd number: &#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> Number &#123; odd: <span class="literal">false</span>, value &#125; = n &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Even number: &#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会输出：</span></span><br><span class="line"><span class="comment">// Odd number: 1</span></span><br><span class="line"><span class="comment">// Even number: 2</span></span><br></pre></td></tr></table></figure><code>match</code>分支同样同于模式，就像<code>if let</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: Number) &#123;</span><br><span class="line">    <span class="keyword">match</span> n &#123;</span><br><span class="line">        Number &#123; odd: <span class="literal">true</span>, value &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Odd number: &#123;&#125;&quot;</span>, value),</span><br><span class="line">        Number &#123; odd: <span class="literal">false</span>, value &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Even number: &#123;&#125;&quot;</span>, value),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出与之前相同</span></span><br></pre></td></tr></table></figure><code>match</code>是穷尽式的，即至少有一个分支被匹配。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: Number) &#123;</span><br><span class="line">    <span class="keyword">match</span> n &#123;</span><br><span class="line">        Number &#123; value: <span class="number">1</span>, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One&quot;</span>),</span><br><span class="line">        Number &#123; value: <span class="number">2</span>, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Two&quot;</span>),</span><br><span class="line">        Number &#123; value, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, value),</span><br><span class="line">        <span class="comment">// 如果最后一个分支不存在，那么编译器将会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果很难做到匹配所有分支，那么则可以使用<code>_</code>来匹配所有剩余的情况：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: Number) &#123;</span><br><span class="line">    <span class="keyword">match</span> n.value &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One&quot;</span>),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Two&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n.value),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>你可以在自己的类型上声明方法：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number</span></span> &#123;</span><br><span class="line">    odd: <span class="built_in">bool</span>,</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Number &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_strictly_positive</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>并像通常一样使用它们：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> minus_two = Number &#123;</span><br><span class="line">        odd: <span class="literal">false</span>,</span><br><span class="line">        value: -<span class="number">2</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;positive? &#123;&#125;&quot;</span>, minus_two.is_strictly_positive());</span><br><span class="line">    <span class="comment">// 输出 &quot;positive? false&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mut"><a href="#mut" class="headerlink" title="mut"></a>mut</h3>默认情况下，变量绑定是不可变的，这意味着它们的内部状态不能被改变：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123;</span><br><span class="line">        odd: <span class="literal">true</span>,</span><br><span class="line">        value: <span class="number">17</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    n.odd = <span class="literal">false</span>; <span class="comment">// error: cannot assign to `n.odd`,</span></span><br><span class="line">                   <span class="comment">// as `n` is not declared to be mutable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>同时它们也不能被重新赋值：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123;</span><br><span class="line">        odd: <span class="literal">true</span>,</span><br><span class="line">        value: <span class="number">17</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    n = Number &#123;</span><br><span class="line">        odd: <span class="literal">false</span>,</span><br><span class="line">        value: <span class="number">22</span>,</span><br><span class="line">    &#125;; <span class="comment">// error: cannot assign twice to immutable variable `n`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>mut</code>可使变量绑定可变：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> n = Number &#123;</span><br><span class="line">        odd: <span class="literal">true</span>,</span><br><span class="line">        value: <span class="number">17</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    n.value = <span class="number">19</span>; <span class="comment">// 一切顺利</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3>特征(<em>trait</em>)是指多种类型可以共有的共同点：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Signed</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_strictly_negative</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>你可以实现：</li><li>对任何人的类型使用你的特征</li><li>将任何人的特征用于你的类型</li><li>不能将外来特征用于外来类型<br>这被称作孤儿规则(<em>orphan rules</em>)，更为规范的定义是<strong>如果你想要为类型</strong> <code>A</code> <strong>实现特征</strong> <code>T</code><strong>，那么</strong> <code>A</code> <strong>或者</strong> <code>T</code> <strong>至少有一个是在当前作用域中定义的</strong>。<br>这是一个将我们的特征用在我们的类型上的实现：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Signed <span class="keyword">for</span> Number &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_strictly_negative</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value &lt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">false</span>, value: -<span class="number">44</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n.is_strictly_negative()); <span class="comment">// 输出 &quot;true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>将我们的特征用在外来类型（甚至是原始类型）上：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Signed <span class="keyword">for</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_strictly_negative</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> &lt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n: <span class="built_in">i32</span> = -<span class="number">44</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n.is_strictly_negative()); <span class="comment">// 输出 &quot;true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>将外来特征用在我们的类型上：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `Neg` 特征用于重载 `-`，即一元减运算符</span></span><br><span class="line"><span class="keyword">impl</span> std::ops::Neg <span class="keyword">for</span> Number &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = Number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">neg</span></span>(<span class="keyword">self</span>) -&gt; Number &#123;</span><br><span class="line">        Number &#123;</span><br><span class="line">            value: -<span class="keyword">self</span>.value,</span><br><span class="line">            odd: <span class="keyword">self</span>.odd,</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">987</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> m = -n; <span class="comment">// 因为我们实现了 `Neg` 所以可以这样做</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, m.value); <span class="comment">// 输出 &quot;-987&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>一个<code>impl</code>块使用代表一种类型，所以在该块里<code>Self</code>表示该类型：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> std::ops::Neg <span class="keyword">for</span> Number &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = <span class="keyword">Self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">neg</span></span>(<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            value: -<span class="keyword">self</span>.value,</span><br><span class="line">            odd: <span class="keyword">self</span>.odd,</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>有一些特征是标记(<em>marker</em>)，它们并不是指该类型实现了某些方法，而是指可以用该类型完成某些事情。<br>例如，<code>i32</code>实现了特征<code>Copy</code>（简单说<code>i32</code>是<code>Copy</code>），所以以下是可行的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a: <span class="built_in">i32</span> = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">let</span> b = a; <span class="comment">// `a` 被复制</span></span><br><span class="line">    <span class="keyword">let</span> c = a; <span class="comment">// `a` 再次被复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>同时以下也可行：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_i32</span></span>(x: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a: <span class="built_in">i32</span> = <span class="number">15</span>;</span><br><span class="line">    print_i32(a); <span class="comment">// `a` 被复制</span></span><br><span class="line">    print_i32(a); <span class="comment">// `a` 再次被复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>但是<code>Number</code>结构体不是<code>Copy</code>，所以以下是不可行的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">51</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> m = n; <span class="comment">// `n` 被移动至 `m`</span></span><br><span class="line">    <span class="keyword">let</span> o = n; <span class="comment">// error: use of moved value: `n`</span></span><br><span class="line">    <span class="comment">// 因为试图使用一个已经被移动过的值而报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以下也是如此：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: Number) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; number &#123;&#125;&quot;</span>, <span class="keyword">if</span> n.odd &#123; <span class="string">&quot;odd&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;even&quot;</span> &#125;, n.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">51</span> &#125;;</span><br><span class="line">    print_number(n); <span class="comment">// `n` 被移动</span></span><br><span class="line">    print_number(n); <span class="comment">// error: use of moved value: `n`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>但是如果<code>print_number</code>使用不可变引用，那么它就可以工作：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: &amp;Number) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; number &#123;&#125;&quot;</span>, <span class="keyword">if</span> n.odd &#123; <span class="string">&quot;odd&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;even&quot;</span> &#125;, n.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">51</span> &#125;;</span><br><span class="line">    print_number(&amp;n); <span class="comment">// `n` 被引用给这次调用</span></span><br><span class="line">    print_number(&amp;n); <span class="comment">// `n` 再次被引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果函数采用可变引用，那么也可以工作，前提是我们的变量绑定也是<code>mut</code>。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">invert</span></span>(n: &amp;<span class="keyword">mut</span> Number) &#123;</span><br><span class="line">    n.value = -n.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: &amp;Number) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; number &#123;&#125;&quot;</span>, <span class="keyword">if</span> n.odd &#123; <span class="string">&quot;odd&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;even&quot;</span> &#125;, n.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 这一次 `n` 是可变的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">51</span> &#125;;</span><br><span class="line">    print_number(&amp;n);</span><br><span class="line">    invert(&amp;<span class="keyword">mut</span> n); <span class="comment">// `n 被可变引用，一切都是明确的</span></span><br><span class="line">    print_number(&amp;n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>特征方法还可以通过引用或者可变引用获取<code>self</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> std::clone::<span class="built_in">Clone</span> <span class="keyword">for</span> Number &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ..*<span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当调用特征方法时，接受者被隐式引用：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">51</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> m = n.clone();</span><br><span class="line">    m.value += <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    print_number(&amp;n);</span><br><span class="line">    print_number(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>为了强调这一点，以下写法是等效的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = n.clone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = std::clone::<span class="built_in">Clone</span>::clone(&amp;n);</span><br></pre></td></tr></table></figure>像<code>Copy</code>这样的标记特征没有方法：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：`Copy` 需要 `Clone` 也被实现</span></span><br><span class="line"><span class="keyword">impl</span> std::clone::<span class="built_in">Clone</span> <span class="keyword">for</span> Number &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ..*<span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>现在<code>Clone</code>仍然可以被使用：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">51</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> m = n.clone();</span><br><span class="line">    <span class="keyword">let</span> o = n.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>但是<code>Number</code>的值不会再被移动：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: trie, value: <span class="number">51</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> m = n; <span class="comment">// `m` 是 `n` 的一个拷贝</span></span><br><span class="line">    <span class="keyword">let</span> o = n; <span class="comment">// 同样，`n` 不再会被移动或引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>有些特征非常常见，可以使用<code>derive</code>属性自动实现：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone, Copy)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number</span></span> &#123;</span><br><span class="line">    odd: <span class="built_in">bool</span>,</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这将会展开成 `impl Clone for Number` 和 `impl Copy for Number` 块</span></span><br></pre></td></tr></table></figure><h3 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型(Generics)"></a>泛型(<em>Generics</em>)</h3>函数可以是泛型化的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;T&gt;(arg: T) &#123;</span><br><span class="line">    <span class="comment">// 与 `arg` 相关的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>它们可以有多个类型参数，然后可以在函数的声明及其主体中使用这些参数，而不是具体类型：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;L, R&gt;(left: L, right: R) &#123;</span><br><span class="line">    <span class="comment">// 与 `left` 和 `right` 相关的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>类型参数通常由约束(<em>constraint</em>)，所以实际上你可以用它们来做一些事情。<br>最简单的约束是特征名称：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>&lt;T: Display&gt;(value: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value = &#123;&#125;&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>&lt;T: <span class="built_in">Debug</span>&gt;(value: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value = &#123;:?&#125;&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>类型参数约束由一种更长的语法：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>&lt;T&gt;(value: T)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value = &#123;&#125;&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>约束可以更复杂：它们可能需要类型参数实现多个特征：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">compare</span></span>&lt;T&gt;(left: T, right: T)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T:<span class="built_in">Debug</span> + <span class="built_in">PartialEq</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &#123;&#125; &#123;:?&#125;&quot;</span>, left, <span class="keyword">if</span> left == right &#123; <span class="string">&quot;==&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;!=&quot;</span> &#125;, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    compare(<span class="string">&quot;tea&quot;</span>, <span class="string">&quot;coffee&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出 &quot;tea != coffee&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>泛型函数可以被认为是命名空间，包含无穷个具有不同具体类型的函数。<br>与包，模块和类型相同，可以对泛型函数使用<code>::</code><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::any::type_name;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, type_name::&lt;<span class="built_in">i32</span>&gt;()); <span class="comment">// 输出 &quot;i32&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, type_name::&lt;(<span class="built_in">f64</span>, <span class="built_in">char</span>)&gt;()); <span class="comment">// 输出 &quot;(f64, char)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这被亲切地称为 turbofish 语法，因为<code>::&lt;&gt;</code>看起来像一条鱼。<br>结构也可以泛型化：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>&lt;T&gt; &#123;</span><br><span class="line">    a: T,</span><br><span class="line">    b: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_type_name</span></span>&lt;T&gt;(_val: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, std::any::type_name::&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = Pair &#123; a: <span class="number">3</span>, b: <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> p2 = Pair &#123; a: <span class="literal">true</span>, b: <span class="literal">false</span>&#125;;</span><br><span class="line">    print_type_name(&amp;p1);</span><br><span class="line">    print_type_name(&amp;p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>标准库类型<code>Vec</code>（或者说堆分配的数组）是泛型化的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v1 = <span class="built_in">Vec</span>::new();</span><br><span class="line">    v1.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v2 = <span class="built_in">Vec</span>::new();</span><br><span class="line">    v2.push(<span class="literal">false</span>);</span><br><span class="line">    print_type_name(&amp;v1); <span class="comment">// prints &quot;Vec&lt;i32&gt;&quot;</span></span><br><span class="line">    print_type_name(&amp;v2); <span class="comment">// prints &quot;Vec&lt;bool&gt;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3>说到<code>Vec</code>，它带有一个宏，可以提供或多或少的”vec 字面量“：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="built_in">vec!</span>[<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>];</span><br><span class="line">    print_type_name(&amp;v1);</span><br><span class="line">    print_type_name(&amp;v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>所有的<code>name!()</code>，<code>name![]</code>和<code>name!&#123;&#125;</code>都会调用宏。宏只是展开成常规代码。<br>实际上<code>println</code>是一个宏：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Hello there!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这会展开成具有相同效果的东西：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line">    io::stdout().lock().write_all(<span class="string">b&quot;Hello there!\n&quot;</span>).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>panic</code>也是一个宏，它会猛烈地停止执行并显示错误消息和文件名 / 行号：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;This panics&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>有些方法也会出现<code>panic</code>。例如，<code>Option</code>类型可以包含某些内容，也可以不包含任何内容。如果<code>.unwrap()</code>被调用，并且它不包括任何内容，那么就会发生<code>panic</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> o1: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">Some</span>(<span class="number">128</span>);</span><br><span class="line">    o1.unwrap(); <span class="comment">// this is fine</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> o2: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    o2.unwrap(); <span class="comment">// this panics!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: thread &#x27;main&#x27; panicked at &#x27;called `Option::unwrap()` on a `None` value&#x27;, src/libcore/option.rs:378:21</span></span><br></pre></td></tr></table></figure><code>Option</code>不是一个结构体，它是一个枚举(<code>enum</code>)，有两个成员：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">num <span class="built_in">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unwrap</span></span>(<span class="keyword">self</span>) -&gt; T &#123;</span><br><span class="line">        <span class="comment">// 枚举成员可以被用在模式中：</span></span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Self::<span class="literal">Some</span>(t) =&gt; t,</span><br><span class="line">            Self::<span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;.unwrap() called on a None option&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> self::<span class="built_in">Option</span>::&#123;<span class="literal">None</span>, <span class="literal">Some</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> o1: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">Some</span>(<span class="number">128</span>);</span><br><span class="line">    o1.unwrap(); <span class="comment">// this is fine</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> o2: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    o2.unwrap(); <span class="comment">// this panics!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: thread &#x27;main&#x27; panicked at &#x27;.unwrap() called on a None option&#x27;, src/main.rs:11:27</span></span><br></pre></td></tr></table></figure><code>Result</code>也是一个枚举，它可以包含某些内容，也可以包含错误：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>若调用<code>unwrap</code>时包含错误，那么它也会<code>panic</code>。<h3 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a>变量绑定</h3>变量绑定拥有一个”生命周期“：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// `x` 还不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">42</span>; <span class="comment">// `x` 开始存在</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, x);</span><br><span class="line">        <span class="comment">// `x` 停止存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// `x` 不再存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>同样，引用也有生命周期：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// `x` 还不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">42</span>; <span class="comment">// `x` 开始存在</span></span><br><span class="line">        <span class="keyword">let</span> x_ref = &amp;x; <span class="comment">// `x_ref` 开始存在 - 它引用 `x`</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x_ref = &#123;&#125;&quot;</span>, x_ref);</span><br><span class="line">        <span class="comment">// `x_ref` 停止存在</span></span><br><span class="line">        <span class="comment">// `x` 停止存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// `x` 不再存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>引用的生命周期不能超过它引用的变量绑定的生命周期：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x_ref = &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">42</span>;</span><br><span class="line">        &amp;x</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x_ref = &#123;&#125;&quot;</span>, x_ref);</span><br><span class="line">    <span class="comment">// error: `x` does not live long enough</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>变量绑定可以不可变地被多次引用：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> x_ref1 = &amp;x;</span><br><span class="line">    <span class="keyword">let</span> x_ref2 = &amp;x;</span><br><span class="line">    <span class="keyword">let</span> x_ref3 = &amp;x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, x_ref1, x_ref2, x_ref3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当被引用时，变量绑定不能改变：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> x_ref = &amp;x;</span><br><span class="line">    x = <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x_ref = &#123;&#125;&quot;</span>, x_ref);</span><br><span class="line">    <span class="comment">// error: cannot assign to `x` because it is borrowed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当被不可变引用时，变量不能被可变引用：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> x_ref1 = &amp;x;</span><br><span class="line">    <span class="keyword">let</span> x_ref2 = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">    <span class="comment">// error: cannot borrow `x` as mutable because it is also borrowed as immutable</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x_ref1 = &#123;&#125;&quot;</span>, x_ref1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>函数参数中的引用也有生命周期：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>(x: &amp;<span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="comment">// `x` 是从外部被引用的，可用在该次函数调用的全过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>具有引用参数的函数可以通过具有不同声明周期的引用来调用，因此：</li><li>所有接受引用的函数都是泛型化的</li><li>生命周期是泛型参数<br>生命周期的参数以单引号<code>&#39;</code>开头：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式（匿名）生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>(x: &amp;<span class="built_in">i32</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>使返回的引用的生命周期取决于参数的生命周期：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">number_value</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(num: &amp;<span class="symbol">&#x27;a</span> Number) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    &amp;num.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; value: <span class="number">47</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> v = number_value(&amp;n);</span><br><span class="line">    <span class="comment">// `v` 是 `n` 的不可变引用，因此 `v` 的生命周期不能超过 `n`.</span></span><br><span class="line">    <span class="comment">// 当 `v` 存在时，`n` 不能被可变引用，改变，移动等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当只有一个生命周期输入时，不需要命名，所有变量都具有相同的生命周期，因此以下两个函数是等效的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">number_value</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(num: &amp;<span class="symbol">&#x27;a</span> Number) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    &amp;num.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">number_value</span></span>(num: &amp;Number) -&gt; &amp;<span class="built_in">i32</span> &#123;</span><br><span class="line">    &amp;num.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>结构体也可以使用生命周期泛型，使其可以保存引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumRef</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">let</span> x_ref = NumRef &#123; x: &amp;x &#125;;</span><br><span class="line">    <span class="comment">// `x_ref` 的生命周期不能长于 `x`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加个相关函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumRef</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">as_num_ref</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>) -&gt; NumRef&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    NumRef &#123; x: &amp;x &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">let</span> x_ref = NumRef &#123; x: &amp;x &#125;;</span><br><span class="line">    <span class="comment">// `x_ref` 的生命周期不能长于 `x`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数中省写生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumRef</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">as_num_ref</span></span>(x: &amp;<span class="built_in">i32</span>) -&gt; NumRef&lt;<span class="symbol">&#x27;_</span>&gt; &#123;</span><br><span class="line">    NumRef &#123; x: &amp;x &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">let</span> x_ref = NumRef &#123; x: &amp;x &#125;;</span><br><span class="line">    <span class="comment">// `x_ref` 的生命周期不能长于 `x`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>impl</code>块也可以这样操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; NumRef&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">as_i32_ref</span></span>(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">let</span> x_num_ref = NumRef &#123; x: &amp;x &#125;;</span><br><span class="line">    <span class="keyword">let</span> x_i32_ref = x_num_ref.as_i32_ref();</span><br><span class="line">    <span class="comment">// 引用的生命周期都不能长于 `x`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以这样省写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; NumRef&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">as_i32_ref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你不需要用到变量名，那可以更简单：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> NumRef&lt;<span class="symbol">&#x27;_</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">as_i32_ref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个特殊的生命周期，即静态<code>&#39;static</code>，代表在整个程序的生命周期中都保持有效。<br>字符串字面量是<code>&#39;static</code>的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Person &#123;</span><br><span class="line">        name: <span class="string">&quot;fasterthanlime&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是持有字符串(<em>owned string</em>)不是静态的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="built_in">format!</span>(<span class="string">&quot;fasterthan&#123;&#125;&quot;</span>, <span class="string">&quot;lime&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> p = Person &#123; name: &amp;name &#125;;</span><br><span class="line">    <span class="comment">// error: `name` does not live long enough</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>name</code>不是<code>&amp;&#39;static str</code>而是<code>String</code>。它是被动态分配并且会被释放的，即其生命周期小于整个程序（即使其恰好位于<code>main</code>中）<br>如果要将非<code>&#39;static</code>字符串存储在<code>Person</code>中，有以下两种方法：<br>A. 使用生命周期泛型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="built_in">format!</span>(<span class="string">&quot;fasterthan&#123;&#125;&quot;</span>, <span class="string">&quot;lime&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> p = Person &#123; name: &amp;name &#125;;</span><br><span class="line">    <span class="comment">// `p` 的生命周期不能长于 `name`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B. 获取字符串的所有权</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="built_in">format!</span>(<span class="string">&quot;faterthan&#123;&#125;&quot;</span>, <span class="string">&quot;lime&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> p = Person &#123; name: name &#125;;</span><br><span class="line">    <span class="comment">// `name` 被移动到 `p`，它们的生命周期不再被限制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在结构体字面量中，如果即将字段设置为同名的变量绑定时，可以简写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = Person &#123; name: name &#125;;</span><br><span class="line"><span class="comment">// 可悲简写为</span></span><br><span class="line"><span class="keyword">let</span> p = Person &#123; name &#125;;</span><br></pre></td></tr></table></figure><p>对于 Rust 中的许多类型，都有所有权(<em>owned</em>)和无所有权(<em>non-owned</em>)两种变体：</p><ul><li>字符串：<code>String</code> 是有所有权的，<code>&amp;str</code> 是引用</li><li>路径：<code>PathBuf</code> 是有所有权的，<code>&amp;Path</code> 是引用</li><li>集合：<code>Vec&lt;T&gt;</code> 是有所有权的，<code>&amp;[T]</code> 是引用<br>在 Rust 中，所有权有以下规则：</li></ul><ol><li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</li><li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</li><li>当所有者(变量)离开作用域范围时，这个值将被丢弃(<em>drop</em>)<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3>切片(<em>slice</em>)是对多个连续元素的<strong>引用</strong>。<br>你可以引用一个向量的切片，例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> v2 = &amp;v[<span class="number">2</span>..<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;v2 = &#123;:?&#125;&quot;</span>, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// v2 = [3, 4]</span></span><br></pre></td></tr></table></figure>上面的操作并不神奇。索引操作符<code>foo[index]</code>重载了<code>Index</code>和<code>IndexMut</code>特征。<br><code>..</code>语法只是范围(<em>range</em>)字面量，范围是标准库中定义的结构体。<br>切片区间可以是开放的，右边界可以是闭的，如果前面有<code>=</code>的话。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 大于等于 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, (<span class="number">0</span>..).contains(&amp;<span class="number">100</span>)); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 严格小于 20</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, (..<span class="number">20</span>).contains(&amp;<span class="number">20</span>)); <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// 小于等于 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, (..=<span class="number">20</span>).contains(&amp;<span class="number">20</span>)); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 只包含 3, 4, 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, (<span class="number">3</span>..<span class="number">6</span>).contions(&amp;<span class="number">4</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>引用规则同样适用于切片：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">tail</span></span>(s: &amp;[<span class="built_in">u8</span>]) -&gt; &amp;[<span class="built_in">u8</span>] &#123;</span><br><span class="line">    &amp;s[<span class="number">1</span>..]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> y = tail(x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;:?&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>一样地，<code>tail</code>函数也可以这样写：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">tail</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> [<span class="built_in">u8</span>]) -&gt; &amp;<span class="symbol">&#x27;a</span> [<span class="built_in">u8</span>] &#123;</span><br><span class="line">    &amp;s[<span class="number">1</span>..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以下代码是合规的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y = &#123;</span><br><span class="line">        <span class="keyword">let</span> x = &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">        tail(x)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;:?&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>但这只是因为<code>&amp;[1, 2, 3, 4, 5]</code>是一个<code>&#39;static</code>数组。<br>所以以下是不可行的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y = &#123;</span><br><span class="line">        <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">        tail(&amp;v);</span><br><span class="line">        <span class="comment">//error: `v` does not live long enough</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;:?&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这是因为向量是堆分配的(<em>heap-allocated</em>)，并且它的生命周期不是<code>&#39;static</code><br><code>&amp;str</code>值实际上是切片。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_ext</span></span>(name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="built_in">str</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 这不会返回一个新的字符串</span></span><br><span class="line">    <span class="comment">// 而是返回参数的一个切片</span></span><br><span class="line">    name.split(<span class="string">&quot;.&quot;</span>).last()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&quot;Read me. Or don&#x27;t.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(ext) = file_ext(name) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;file extension: &#123;&#125;&quot;</span>, ext);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;no file extension&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>所以引用规则也同样适用：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> ext = &#123;</span><br><span class="line">        <span class="keyword">let</span> name = <span class="built_in">String</span>::from(<span class="string">&quot;Read me. Or don&#x27;t.txt&quot;</span>);</span><br><span class="line">        file_ext(&amp;name).unwarp_or(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="comment">// error: `name` does not live long enough</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;extension: &#123;:?&#125;&quot;</span>, ext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3>可能会出错的函数通常会返回<code>Result</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">240</span>, <span class="number">159</span>, <span class="number">141</span>, <span class="number">137</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">    <span class="comment">// 输出：Ok(&quot;🍉&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s = std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">195</span>, <span class="number">40</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">    <span class="comment">// 输出：Err(Utf8Error &#123; valid_up_to: 0, error_len: Some(1) &#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果你想在出错的时候<code>panic</code>，则可以使用<code>.unwarp()</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">240</span>, <span class="number">159</span>, <span class="number">141</span>, <span class="number">137</span>]).unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">    <span class="comment">// 输出：&quot;🍉&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s = std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">195</span>, <span class="number">40</span>]).unwrap();</span><br><span class="line">    <span class="comment">// 输出：thread &#x27;main&#x27; panicked at &#x27;called `Result::unwrap()`</span></span><br><span class="line">    <span class="comment">// on an `Err` value: Utf8Error &#123; valid_up_to: 0, error_len: Some(1) &#125;&#x27;,</span></span><br><span class="line">    <span class="comment">// src/libcore/result.rs:1165:5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>或者<code>expect()</code>，用来自定义报错消息：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">195</span>, <span class="number">40</span>]).expect(<span class="string">&quot;valid utf-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出：thread &#x27;main&#x27; panicked at &#x27;valid utf-8: Utf8Error</span></span><br><span class="line">    <span class="comment">// &#123; valid_up_to: 0, error_len: Some(1) &#125;&#x27;, src/libcore/result.rs:1165:5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>或者你可以使用<code>match</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">240</span>, <span class="number">159</span>, <span class="number">141</span>, <span class="number">137</span>]) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s).</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="built_in">println!</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出：🍉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>或者使用<code>if let</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(s) = std::std::from_utf8(&amp;[<span class="number">240</span>, <span class="number">159</span>, <span class="number">141</span>, <span class="number">137</span>]) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出：🍉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>或者你可以将错误提升出来：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), std::<span class="built_in">str</span>::Utf8Error&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">240</span>, <span class="number">159</span>, <span class="number">141</span>, <span class="number">137</span>]) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s),</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>你可以使用<code>?</code>来以更简洁的方式完成此操作：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), std::<span class="built_in">str</span>::Utf8Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> s = std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">240</span>, <span class="number">159</span>, <span class="number">141</span>, <span class="number">137</span>])?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>*</code>运算符可用于取消引用(<em>dereference</em>)，但是你在访问字段和调用方法的时候并不需要用到：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f64</span>,</span><br><span class="line">    y: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">3.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> p_ref = &amp;p;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, p_ref.x, p_ref.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 `(1, 3)`</span></span><br></pre></td></tr></table></figure>只有当类型为<code>Copy</code>的时候才能这样操作：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f64</span>,</span><br><span class="line">    y: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">negate</span></span>(p: Point) -&gt; Point &#123;</span><br><span class="line">    Point &#123;</span><br><span class="line">        x: -p.x,</span><br><span class="line">        y: -p.y,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">3.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> p_ref = &amp;p;</span><br><span class="line">    negate(*p_ref);</span><br><span class="line">    <span class="comment">// error: cannot move out of `*p_ref` which is behind a shared reference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在 `Point` 是 `Copy`</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f64</span>,</span><br><span class="line">    y: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">negate</span></span>(p: Point) -&gt; Point &#123;</span><br><span class="line">    Point &#123;</span><br><span class="line">        x: -p.x,</span><br><span class="line">        y: -p.y,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">3.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> p_ref = &amp;p;</span><br><span class="line">    negate(*p_ref); <span class="comment">// 并且现在不会报错了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包(<em>closure</em>)只是<code>Fn</code>，<code>FnMut</code>和<code>FnOnce</code>类型的函数加上捕获传递的上下文。<br>它们的参数是被一对管道(<code>|</code>)包括，用逗号分隔的。它们不需要花括号，除非你需要多条语句。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">for_each_planet</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>)</span><br><span class="line">&#123;</span><br><span class="line">    f(<span class="string">&quot;Earth&quot;</span>);</span><br><span class="line">    f(<span class="string">&quot;Mars&quot;</span>);</span><br><span class="line">    f(<span class="string">&quot;Jupiter&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    for_each_planet(|planet| <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;&quot;</span>, planet));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Hello, Earth</span></span><br><span class="line"><span class="comment">// Hello, Mars</span></span><br><span class="line"><span class="comment">// Hello, Jupiter</span></span><br></pre></td></tr></table></figure><p>引用规则同样适用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">for_each_planet</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>)</span><br><span class="line">&#123;</span><br><span class="line">    f(<span class="string">&quot;Earth&quot;</span>);</span><br><span class="line">    f(<span class="string">&quot;Mars&quot;</span>);</span><br><span class="line">    f(<span class="string">&quot;Jupiter&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="built_in">String</span>::from(<span class="string">&quot;Good to see you&quot;</span>);</span><br><span class="line">    for_each_planet(|planet| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, greeting, planet));</span><br><span class="line">    <span class="comment">// 我们的闭包引用了 `greeting`，所以其生命周期不能长于它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如以下是无法工作的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">for_each_planet</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>) + <span class="symbol">&#x27;static</span> <span class="comment">// `F` 必须是 &quot;&#x27;static&quot; 生命周期</span></span><br><span class="line">&#123;</span><br><span class="line">    f(<span class="string">&quot;Earth&quot;</span>);</span><br><span class="line">    f(<span class="string">&quot;Mars&quot;</span>);</span><br><span class="line">    f(<span class="string">&quot;Jupiter&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="built_in">String</span>::from(<span class="string">&quot;Good to see you&quot;</span>);</span><br><span class="line">    for_each_planet(|planet| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, greeting, planet));</span><br><span class="line">    <span class="comment">// error: closure may outlive the current function, but it borrows</span></span><br><span class="line">    <span class="comment">// `greeting`, which is owned by the current function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样可以：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="built_in">String</span>::from(<span class="string">&quot;You&#x27;re doing great&quot;</span>);</span><br><span class="line">    for_each_planet(<span class="keyword">move</span> |planet| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, greeting, planet));</span><br><span class="line">    <span class="comment">// `greeting` 不再被引用，它被移动到该闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FnMut</code>需要被可变引用才能被调用，因此一次传参只能调用一次。<br>以下是可行的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f(f(<span class="number">2</span>))); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foobar(|x| x * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：8</span></span><br></pre></td></tr></table></figure><p>但以下不能：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(<span class="keyword">mut</span> f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">FnMut</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f(f(<span class="number">2</span>))); </span><br><span class="line">    <span class="comment">// error: cannot borrow `f` as mutable more than once at a time</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foobar(|x| x * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样则可行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(<span class="keyword">mut</span> f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">FnMut</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = f(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f(tmp)); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foobar(|x| x * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：8</span></span><br></pre></td></tr></table></figure><p><code>FnMut</code>的存在是因为某些闭包会可变引用本地变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(<span class="keyword">mut</span> f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">FnMut</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = f(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f(tmp)); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> acc = <span class="number">2</span>;</span><br><span class="line">    foobar(|x| &#123;</span><br><span class="line">        acc += <span class="number">1</span>;</span><br><span class="line">        x * acc</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：24</span></span><br></pre></td></tr></table></figure><p>这些闭包不能传递给需要<code>Fn</code>的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f(f(<span class="number">2</span>))); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> acc = <span class="number">2</span>;</span><br><span class="line">    foobar(|x| &#123;</span><br><span class="line">        acc += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// error: cannot assign to `acc`, as it is a</span></span><br><span class="line">        <span class="comment">// captured variable in a `Fn` closure.</span></span><br><span class="line">        <span class="comment">// the compiler suggests &quot;changing foobar</span></span><br><span class="line">        <span class="comment">// to accept closures that implement `FnMut`&quot;</span></span><br><span class="line">        x * acc</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FnOnce</code>闭包只能调用一次。它们的存在是因为某些闭包会移出在捕获时就已被移动的变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">FnOnce</span>() -&gt; <span class="built_in">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f()); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;alright&quot;</span>);</span><br><span class="line">    foobar(<span class="keyword">move</span> || s);</span><br><span class="line">    <span class="comment">// `s` 被移动到我们的闭包中</span></span><br><span class="line">    <span class="comment">// 并且我们的闭包通过返回将其移动到调用这中</span></span><br><span class="line">    <span class="comment">// 记住 `String` 不是 `Copy`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是默认强制执行的，因为<code>FnOnce</code>闭包需要移动才能被调用。<br>例如以下是不可行的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">FnOnce</span>() -&gt; <span class="built_in">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f()); </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f()); </span><br><span class="line">    <span class="comment">// error: use of moved value: `f`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你对我们的闭包是否确实移动了<code>s</code>有疑问，以下也是不可行的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;alright&quot;</span>);</span><br><span class="line">    foobar(<span class="keyword">move</span> || s);</span><br><span class="line">    foobar(<span class="keyword">move</span> || s);</span><br><span class="line">    <span class="comment">// 使用了被移动的值：`s`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这是可行的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;alright&quot;</span>);</span><br><span class="line">    foobar(|| s.clone());</span><br><span class="line">    foobar(|| s.clone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是带有两个参数的闭包：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>, is_greater: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>) -&gt; <span class="built_in">bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> (greater, smaller) = <span class="keyword">if</span> is_greater(x, y) &#123;</span><br><span class="line">        (x, y)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (y, x)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is greater than &#123;&#125;&quot;</span>, greater, smaller);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foobar(<span class="number">32</span>, <span class="number">64</span>, |x, y| x &gt; y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个忽略其两个参数的闭包：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foobar(<span class="number">32</span>, <span class="number">64</span>, |_, _| <span class="built_in">panic!</span>(<span class="string">&quot;Comparing is futile!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个有点吓人的闭包（指输出）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">countdown</span></span>&lt;F&gt;(count: <span class="built_in">usize</span>, tick: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(<span class="built_in">usize</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..=count).rev() &#123;</span><br><span class="line">        tick(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    countdown(<span class="number">3</span>, |i| <span class="built_in">println!</span>(<span class="string">&quot;tick &#123;&#125;...&quot;</span>, i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// tick 3...</span></span><br><span class="line"><span class="comment">// tick 2...</span></span><br><span class="line"><span class="comment">// tick 1...</span></span><br></pre></td></tr></table></figure><p>这是马桶闭包：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    countdown(<span class="number">3</span>, |_| ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以这么称呼是因为<code>|_| ()</code>看起来像马桶。</p><h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><p>任何可迭代的东西都可以在<code>for in</code>循环中使用。<br>我们刚刚演示了在范围上使用，但实际上它也适用于向量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">vec!</span>[<span class="number">52</span>, <span class="number">49</span>, <span class="number">21</span>] &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;I like the number &#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是切片：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;[<span class="number">52</span>, <span class="number">49</span>, <span class="number">21</span>] &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;I like thw number &#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// I like the number 52</span></span><br><span class="line"><span class="comment">// I like the number 49</span></span><br><span class="line"><span class="comment">// I like the number 21</span></span><br></pre></td></tr></table></figure><p>或者是一个实际的迭代器(<em>iterator</em>)：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 注意：`&amp;str` 还有个 `.bytes()` 迭代器</span></span><br><span class="line">    <span class="comment">// Rust 的 `char` 类型是一个 Unicode 标量值</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;rust&quot;</span>.chars() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Give me a &#123;&#125;&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Give me a r</span></span><br><span class="line"><span class="comment">// Give me a u</span></span><br><span class="line"><span class="comment">// Give me a s</span></span><br><span class="line"><span class="comment">// Give me a t</span></span><br></pre></td></tr></table></figure><p>即使迭代器的成员被过滤(<em>filter</em>)，映射(<em>map</em>)和展平(<em>flat</em>)：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;SuRPRISE INbOUND&quot;</span></span><br><span class="line">        .chars()</span><br><span class="line">        .filter(|c| c.is_lowercase())</span><br><span class="line">        .flat_map(|c| c.to_uppercase())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：UB</span></span><br></pre></td></tr></table></figure><p>你可以从函数中返回一个闭包：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">make_tester</span></span>(answer: <span class="built_in">String</span>) -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(&amp;<span class="built_in">str</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">move</span> |challenge| &#123;</span><br><span class="line">        challenge == answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 你可以使用 `.into()` 在类型变种间实施转换</span></span><br><span class="line">    <span class="comment">// 例如 `&amp;&#x27;static str` 和 `String`</span></span><br><span class="line">    <span class="keyword">let</span> test = make_tester(<span class="string">&quot;hunter2&quot;</span>.into());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, test(<span class="string">&quot;******&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, test(<span class="string">&quot;hunter2&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你甚至可以将函数参数的引用移动到它所返回的闭包中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">make_tester</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(answer: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(&amp;<span class="built_in">str</span>) -&gt; <span class="built_in">bool</span> + <span class="symbol">&#x27;a</span> &#123;</span><br><span class="line">    <span class="keyword">move</span> |challenge| &#123;</span><br><span class="line">        challenge == answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> test = make_tester(<span class="string">&quot;hunter2&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, test(<span class="string">&quot;*******&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, test(<span class="string">&quot;hunter2&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>以及，省写生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">make_tester</span></span>(answer: &amp;<span class="built_in">str</span>) -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(&amp;<span class="built_in">str</span>) -&gt; <span class="built_in">bool</span> + <span class="symbol">&#x27;_</span> &#123;</span><br><span class="line">    <span class="keyword">move</span> |challenge| &#123;</span><br><span class="line">        challenge == answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>到此，本文就结束了，现在你应该能够阅读他人的 Rust 代码。如果你想更进一步的学习，那么你可以查看：</p><ul><li><a href="https://course.rs/">Rust语言圣经</a></li><li><a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust By Example</a></li><li><a href="https://github.com/rustlang-cn/rusty-book">锈书</a><br>但无论如何，希望你能记住：<blockquote><p>If you didn’t code, you didn’t learn.</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;编程语言不学Rust，就如同游戏不玩原神&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;本文翻译自&lt;a href=&quot;https://fasterthanli.me/articles/a-half-hour-to-learn-rust&quot;&gt;A ha</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>香草风格模组指南</title>
    <link href="https://weifeng233.github.io/2023/06/09/%E9%A6%99%E8%8D%89%E9%A3%8E%E6%A0%BC%E6%A8%A1%E7%BB%84%E6%8C%87%E5%8D%97/"/>
    <id>https://weifeng233.github.io/2023/06/09/%E9%A6%99%E8%8D%89%E9%A3%8E%E6%A0%BC%E6%A8%A1%E7%BB%84%E6%8C%87%E5%8D%97/</id>
    <published>2023-06-09T02:44:55.497Z</published>
    <updated>2023-06-09T02:46:35.307Z</updated>
    
    <content type="html"><![CDATA[<p>当你想制作一个能够与原版 MC 风格一致的模组时，需要注意两个要素：<strong>美术</strong>和<strong>玩法。</strong></p><h2 id="美术"><a href="#美术" class="headerlink" title="美术"></a>美术</h2><p>根据 BlockBench Wiki 中的文档 <a href="https://www.blockbench.net/wiki/guides/minecraft-style-guide">Minecraft Style Guide</a>，MC 的美术风格的基础是<strong>简约。</strong></p><p>比如在模型当中，应当在保证能够描绘对象的基础上尽可能减少元素的数量，不应为了过分追求真实感和精细而制作一个相当复杂的模型，否则当其与原版的内容放置在一起时可以明显感受到突兀感。</p><p>在 Minecraft Style Guide 中，作者总结了以下规则：</p><p><img src="/2023/06/09/%E9%A6%99%E8%8D%89%E9%A3%8E%E6%A0%BC%E6%A8%A1%E7%BB%84%E6%8C%87%E5%8D%97/image-20230609104245800.png" alt="导图"></p><p>当然，你不需要在将其掌握到倒背如流的境界并在实际操作中步步遵守，毕竟即使在原版 MC 中也有例外出现（不要去观察可可豆的顶部），你只需要凭你自己的感觉去减少上文提到的那种“突兀感”即可，这里所列举的规则仅相当于一种如何让你的美术资源“香草化”的操作参考。</p><p>众所周知，MC 经历过一次大型的纹理更新，在此更新之后，MC 的纹理基本都由 Jappa 绘制，这样保证了风格的一致性，但是在纹理更新前的<em>程序员风格</em>纹理就不原版了吗？答案当然是否定的。你可以去学习 Jappa 的风格，也可以探索自己的风格，是否与原版契合是很容易被感知到的，但即使不契合，玩家也不会不接受。</p><h2 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h2><p>说到底美术只占了一部分视觉效果，真正能够体现一个模组是否与原版契合的还是在于其玩法（除非你仅仅想做一个装饰性的模组，我也喜欢那种）。</p><p>玩法与原版契合并不代表对原版进行复制粘贴，加入各种与原版功能区别不大的矿石工具等，那样并没有多少新意，玩家也很难提起兴趣去玩，因为那些经典的大型模组都已经提供了相当数量的优质选择。因此，模组应该有自己的原创玩法，给 MC 带来新的乐趣。</p><p>但是如何在加入新玩法的同时保持原版风格呢？</p><p>在 2020 年 Minecon 上，Jeb 展示了他所编写的“小绿书”中的部分内容，该书是 Mojang 内部的 Minecraft 设计指导，很可惜 Mojang 并不向玩家社区公开其具体内容。但幸运的是 Jeb 大方地展示了两页内容，这使得我们可以据此对 Mojang 的设计理念作一番揣测。</p><hr><p><strong>ONE BLOCK AT A TIME!</strong></p><p>一次一个方块，或者一块一块挖，即玩家的一次输入应当只引起一个方块的交互，但与一个方块交互后该方块可以再引起其他方块的变化，比如种树、点燃 TNT 或者启动红石装置，无论最终引起的变化有多大，对于玩家来说，一切都应该起始于与一个方块的交互。</p><p>这样的规则可以使玩家能够更容易地理解他人游玩时的操作，同时举了一键生成建筑的反面案例，这样的操作会可能使其他玩家难以理解发生了什么。</p><p>在此规则下，能够同时破坏多个方块的工具、连锁破坏都是不被允许的，因此需要另寻其他方式来为玩家提供便利。</p><p><strong>BAD TINGS HAPPEN…</strong> <em>but it’s technically the players’ fault</em></p><p>在 MC 中灾难是常见的，比如掉进熔岩湖或者房屋被苦力怕摧毁，但是重要的是这些事故都是由玩家造成的，或者说是玩家可以回避的，游戏中不应该有无法躲避的灾难，所有灾难性事件的发生都应该是有原因的。 </p><p>因此，在原版中，闪电虽然是随机的但强度并不大，没有自然生成的生物会主动攻击苦力怕，末影人虽然能移动方块但只能移动如泥土，沙子这类自然生成且玩家可徒手破坏的常见方块（TNT 是个例外，但在无玩家干涉情况下，末影人需要从林地府邸找到 TNT，寻找熔岩或者火焰，或者将其带到远古城市或者雪屋当中的红石块或红石火把旁，我十分期待后者的发生）。</p><p>所以大型的自然灾害，能够主动破坏方块的生物都是不应该被加入到 MC 的，但这并不代表限制了游戏的挑战性，监守者就是个很好的例子，它会被方块遮挡，但可以发动声爆攻击。再比如炽足兽，尽管它是友好生物，但是它可以在熔岩上行走，在设计新的生物时也可以如此考虑，虽然不能破坏方块，但是在特定环境下其行为方式可以给玩家带来足够的挑战。</p><hr><p>除此之外，开发者们也在社区提及了一些内容，比如<strong>毒马铃薯永远不会有用</strong>这种实用内容。</p><p>有把握认为上文这些规则设立于微软收购 Mojang 之后，自 Java 版末地更新开始实施，尤其是自水域更新之后加入的内容可以明显感知到与 Notch 时期的更新内容大相径庭，如闪电，苦力怕这些违反规则的内容都是在其之前加入的，对于闪电已经加入了避雷针，而苦力怕则是作为 MC 的吉祥物地位过高不可撼动。</p><p>当今新加入的动物基本上都是被动或者中立的，而且都带有一定的<strong>非现实元素</strong>（如海豚可以使玩家游泳加速，海龟壳可以用来酿造），同时因为环保的原因，MC 不支持玩家去杀死现实中存在的动物，所以新加入的动物都不会再掉落如食物之类的必需品（哞菇不是现实动物，因此棕色哞菇是合法的）；游戏中不会轻易加入不可破坏方块，除非它有极其重要的作用且相当罕见。</p><p>与美术一样，玩法方面的规则也不是必须要遵守的，你要做的是你自己的模组，一切内容都随你。当今 MC 的每一次更新都有玩家说这不原版，但一段时间后玩家们总会适应的，最重要的是新内容应该与 MC 先前的内容能够契合，而不是一套独立的玩法使 MC 原先的玩法变得无用（这里需要点名一些科技模组和魔法模组，但我懒得写了）。同时 MC 的更新内容可以分为 Notch 时期和微软时期，如果苦力怕是现在被加入游戏的，那么认为它<strong>不原版</strong>的玩家会不会更多呢？</p><p>MC 的主角是<strong>玩家</strong>，玩家可以自由探索改造这个世界，玩家的所作所为都应该被<strong>尊重</strong>，玩家的<strong>自由</strong>也不应该被过多限制，即使是末影龙，玩家也可以在一般生存模式下空手打败，也可以跳过该流程直接到外岛探索。1.8 加入的粘液块，1.20 加入的校频幽匿感测体单独看其功能不算太复杂，但都在社区带来了技术革命，MC 就是这样由一个个简单的内容的组合获得无限可能的，因此原版风格的模组不应该规定玩家的流程，那样会使 MC 更像一个 RPG 游戏或者经营策略游戏。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当你想制作一个能够与原版 MC 风格一致的模组时，需要注意两个要素：&lt;strong&gt;美术&lt;/strong&gt;和&lt;strong&gt;玩法。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;美术&quot;&gt;&lt;a href=&quot;#美术&quot; class=&quot;headerlink&quot; title=&quot;美术&quot;&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一些关于InnerCore的闲话</title>
    <link href="https://weifeng233.github.io/2023/02/19/%E6%97%A0%E7%94%A8%E9%97%B2%E8%AF%9D/"/>
    <id>https://weifeng233.github.io/2023/02/19/%E6%97%A0%E7%94%A8%E9%97%B2%E8%AF%9D/</id>
    <published>2023-02-18T16:35:06.127Z</published>
    <updated>2023-02-18T16:37:15.148Z</updated>
    
    <content type="html"><![CDATA[<p>阅前提醒：本文仅为个人观点，是否具有参考价值由读者自行判断。</p><p>能看到这篇文章的人应该都知道InnerCore和Horizon是什么了，就不再赘述了。那么先按常例简单梳理一下发展史，首先InnerCore是Zheka基于CoreEngine开发的一款适用于安卓平台上PE/BE版MC的模组启动器，而CoreEngine则是由Factorzation的FactAPI发展而来，运行在著名的方块启动器上。而Horizon是Zheka为了规避Play商店的限制和方便更新InnerCore而开发的一个实例化启动器，或者说是一个“游戏启动器平台”，但按当前的情况来看，但实现后者是一件遥不可及的事情，毕竟除了人力物力的支持外，还难免会涉及版权纠纷。<br>但是鉴于已经有相当多的人将Horizon与新版InnerCore画上等号，那么相比大部分人应该都不怎么担心Horizon会怎么样，只会关注InnerCore的游玩体验之类的事情，那么无论再怎么画饼也不会有人被吸引的。</p><p>说回InnerCore，现在InnerCore给人的第一印象相比只有三个字“不稳定”，再其次就是“卡顿”，“优化差”，“版本落后”，“不如网易”等批评，而且确实难以反驳。但是不能将这些问题简单地都推给引擎，还有两个重要因素值得注意，一是InnerCore的开发社区实在是太小了，人数最多的开发社区当属俄国（这么说并不能全部包括，或许应该叫前苏联地区233）和中国，但规模都在几十人且活跃者均为个位数，而且在这种甚至情况下还分生出了一些互相存在些许矛盾的小团体（嘛，其实也完全可以理解，毕竟人的方向和观念都是自由的），至于其他的国家或地区那就更是屈指可数了，这就导致了至今ICMod的开发还很不成熟，没有多少稳定可靠的轮子可用，而且有些比较基本的东西都还没有打成一个一致的标准（比如说经典UI和矿辞，都是有望通过开发社区交流合作来实现的）。</p><p>二是微软对第三方启动器的打压，虽然没有表现在明面上，但很多操作都可以证实，比如说封禁帐号和删除符号，前者是在警示玩家不要使用第三方启动器（当然，确实有反作弊的目的，但当时的封禁标准是针对安卓上的第三方启动器如方块启动器，Toolbox设计的，因为服务器作弊的大头在Win10平台上），后者则是阻碍第三方启动器的开发者对新版本的适配。所以我个人是对InnerCore适配新版本不抱任何希望了，但对于模组玩家来说，这并非是不能接受的事情。</p><p>但是我并不认为InnerCore就应该就此被遗弃，因为InnerCore以上的劣势都是由它最大的优势导致的——InnerCore是一个第三方模组API，这意味着开发者有足够的接口和权限去做几乎任何他们想做的事情（前提是不只是拘束在CoreEngineAPI当中），我可以断言，Mojang和网易的模组API永远不可能允许开发者有完全自由的文件读写权限和系统权限，当然这是因为这会给玩家带来很大的安全隐患，但这取决于开发者，Java版的模组引擎比如Forge，Fabric也有同样甚至更高的自由度，但恶意模组的事件不算多。如果第三方模组在基岩版彻底灭绝，全靠坐等官方开放的官方模组API，那么基岩版模组是不会有与Java版模组抗衡的时候的（虽然我个人觉得和Java版比意义不大就是了）。总之无论如何，我都会坚持支持第三方模组API。</p><p>再说点题外话，目前基岩版的官方模组API都是数据驱动+服务端脚本的模式，而InnerCore是客户端与服务端函数和回调混合的模式，直接比较两种不同的模式（或者叫“范式”）是不合适的，但就和面向过程和面向对象一样，都有其显优势的情况。我个人认为官方模组API的模式比较适合开发那些大体量但同质化较高和重视觉表现轻功能的模组，而InnerCore适合开发内容耦合性较高和拥有复杂逻辑的模组，虽然现在的环境是基本上都以前者为主，后者无论在基岩版和Java版都相当少见（但质量基本上都很高）。不过这都是相当理想的想法了，在现实中谁说要在InnerCore开发像机械动力那样的模组估计要么收获一些质疑要么被推荐去网易。另外比如Pojav，HMCLPE这些安卓平台上的Java版启动器我个人认为与InnerCore是不在同一条赛道上的，不能互相比较，谁优谁劣的争论是无意义的。</p><p align="right">Vanilla Survival Player</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阅前提醒：本文仅为个人观点，是否具有参考价值由读者自行判断。&lt;/p&gt;
&lt;p&gt;能看到这篇文章的人应该都知道InnerCore和Horizon是什么了，就不再赘述了。那么先按常例简单梳理一下发展史，首先InnerCore是Zheka基于CoreEngine开发的一款适用于安卓平</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Core Utility（渣翻预警）</title>
    <link href="https://weifeng233.github.io/2022/08/03/CoreUtility/"/>
    <id>https://weifeng233.github.io/2022/08/03/CoreUtility/</id>
    <published>2022-08-03T10:23:19.603Z</published>
    <updated>2022-08-26T17:41:33.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Core-Utility"><a href="#Core-Utility" class="headerlink" title="Core Utility"></a>Core Utility</h1><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><p>该核心设计用于创建 Hooks（重载原生(<em>Native</em>)方法或覆写其返回值）以及在 JavaScript / TypeScript 中调用原版方法，以极大的简化部分方法与原生模块的集成。</p><ul><li>声明文件<ul><li><a href="https://github.com/Reider745/libs/blob/main/mod_documentation_api/CoreUtility/core-utility.d.ts">core-utility.d.ts</a> - 用于支持 TypeScript 的编辑器</li></ul></li></ul><h2 id="ToolTip"><a href="#ToolTip" class="headerlink" title="ToolTip"></a>ToolTip</h2><p>ToolTip(工具提示) 用于自定义显示在物品名称下方的附加数据，可用于展示能量值或创造物品栏类别。</p><p>向物品添加工具提示（当然这也适用于方块）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ToolTip.addToolTip(id, data, name);</span><br></pre></td></tr></table></figure><p>在正文之前添加一条动态工具提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ToolTip.addDynamicPre(id, data, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Translation.translate(<span class="string">&quot;tool.unique_artifact.formatter&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在正文之后添加一条动态工具提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ToolTip.addDynamicPost(id, data, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Translation.translate(<span class="string">&quot;tool.unique_artifact.name&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>添加多条工具提示（译注：此处 names 为包含提示内容的数组）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ToolTip.addToolTips(id, data, names);</span><br></pre></td></tr></table></figure><p>删除特定的工具提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ToolTip.deletToolTip(id, data, names);</span><br></pre></td></tr></table></figure><p>清除先前添加的工具提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ToolTip.clearToolTip(id, data);</span><br></pre></td></tr></table></figure><p>以数组的形式获取所有的工具提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ToolTip.getToolTips(id, data);</span><br></pre></td></tr></table></figure><p>清除<strong>所有</strong>物品的工具提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ToolTip.clearToolTips();</span><br></pre></td></tr></table></figure><h2 id="NativeAPI"><a href="#NativeAPI" class="headerlink" title="NativeAPI"></a>NativeAPI</h2><p>用于调用在运行环境（运行时值）和模组脚本之间转换标识符的主要方法的工具类。</p><p>标识符可以有多种类型，对于一个物品或方块必须相应地如下指定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConversionType.ITEM</span><br><span class="line">ConversionType.BLOCK</span><br></pre></td></tr></table></figure><p>将动态标识符转换为静态标识符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NativeAPI.dynamicToStatic(id, type);</span><br></pre></td></tr></table></figure><p>将静态标识符转换为动态标识符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NativeAPI.staticToDynamic(id, type);</span><br></pre></td></tr></table></figure><p>通过实例对象获取实体的 UUID</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NativeAPI.getActorID(actor);</span><br></pre></td></tr></table></figure><p>通过UUID获取实体的实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NativeAPI.getActorById(id);</span><br></pre></td></tr></table></figure><h2 id="ActorDamageCause"><a href="#ActorDamageCause" class="headerlink" title="ActorDamageCause"></a>ActorDamageCause</h2><p>创建 ActorDamegeCause 类的实例对象，ID 为未来伤害的 ID（可以替换原版伤害类型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ActorDamageCause(id);</span><br></pre></td></tr></table></figure><p>设置死亡信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ActorDamageCause&gt;.setDeadMessage(<span class="function"><span class="keyword">function</span>(<span class="params">type, name_player, attacker</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Kill &quot;</span>+name_player;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="TickingAreasManager"><a href="#TickingAreasManager" class="headerlink" title="TickingAreasManager"></a>TickingAreasManager</h2><p><a href="https://minecraft.fandom.com/zh/wiki/%E5%B8%B8%E5%8A%A0%E8%BD%BD%E5%8C%BA%E5%9F%9F">常加载区域</a>是由玩家创建的一些区块，可以在附近没有玩家的情况下保持更新。该类用于管理已创建的常加载区域和创建新的常加载区域。</p><p>检查是否存在常加载区域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TickingAreasManager.hasActiveAreas();</span><br></pre></td></tr></table></figure><p>在特定坐标处添加特定半径的球形常加载区域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TickingAreasManager.addArea(dimension, name, x, y, z, range);</span><br></pre></td></tr></table></figure><p>以特定的两点添加长方体常加载区域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TickingAreasManager.addAreaPositions(dimension, name, x1, y1, z1, x2, y2, z2);</span><br></pre></td></tr></table></figure><p>为维度中的特定实体添加常加载区域，即使该实体拥有和玩家一样的加载区块的能力</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TickingAreasManager.addEntityArea(dimension, entity);</span><br></pre></td></tr></table></figure><p>返回世界中的常加载区域的数量，因为是通过指令添加，上限为10</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TickingAreasManager.countStandaloneTickingAreas();</span><br></pre></td></tr></table></figure><p>返回特定维度中的常加载区域的数量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TickingAreasManager.countPendingAreas(dimension);</span><br></pre></td></tr></table></figure><h2 id="FileUtils"><a href="#FileUtils" class="headerlink" title="FileUtils"></a>FileUtils</h2><p>用于处理文件的原生模块，简化了处理大量文件的过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除文件夹及其包含的文件</span></span><br><span class="line">FileUtils.deleteDirectory(path);</span><br><span class="line"><span class="comment">// 清空文件夹</span></span><br><span class="line">FileUtils.deleteDirectoryContents(path);</span><br><span class="line"><span class="comment">// 如果为空文件夹则将其删除</span></span><br><span class="line">FileUtils.deleteEmptyDirectory(dir);</span><br><span class="line"><span class="comment">// 删除特定文件</span></span><br><span class="line">FileUtils.deleteFile(file);</span><br><span class="line"><span class="comment">// 重命名文件夹</span></span><br><span class="line">FileUtils.renameDirectory(oldName, newName);</span><br><span class="line"><span class="comment">// 重命名文件</span></span><br><span class="line">FileUtils.renameFile(oldName, newName);</span><br><span class="line"><span class="comment">// 复制文件夹及其包含的文件</span></span><br><span class="line">FileUtils.copyDirectory(<span class="keyword">from</span>, to); </span><br><span class="line"><span class="comment">// 检查文件是否存在</span></span><br><span class="line">FileUtils.fileExists(file);</span><br><span class="line"><span class="comment">// 检查文件夹是否存在</span></span><br><span class="line">FileUtils.directoryExists(dir);    </span><br><span class="line"><span class="comment">// 检查路径是否可用</span></span><br><span class="line">FileUtils.isValidPath(path);</span><br><span class="line"><span class="comment">// 检查是否为游戏文件夹的相对路径</span></span><br><span class="line">FileUtils.isRelativePath(path);</span><br><span class="line"><span class="comment">// 检查文件或文件夹是否存在</span></span><br><span class="line">FileUtils.isExists(pathOrFile);</span><br><span class="line"><span class="comment">// 创建文件夹</span></span><br><span class="line">FileUtils.createDirectory(path);</span><br><span class="line"><span class="comment">// 为文件创建其路径中缺少的文件夹</span></span><br><span class="line">FileUtils.createDirectoryForFile(path);</span><br></pre></td></tr></table></figure><h2 id="World"><a href="#World" class="headerlink" title="World"></a>World</h2><p>用于管理世界列表，可以添加非游戏本身提供的世界文件夹路径，例如模组特定的世界。</p><p>向世界列表添加路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">World.addWorldToCache(path);</span><br></pre></td></tr></table></figure><p>刷新世界列表，若游戏已经加载完毕则会产生视觉上的变化（译注：在进入世界后使用可使游戏崩溃）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">World.updateWorlds();</span><br></pre></td></tr></table></figure><p>获取有效的世界数量（若世界存档损坏，则不会被计入）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">World.getWorldsCount();</span><br></pre></td></tr></table></figure><h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><ul><li>继承自 PointerClass</li></ul><p>生成最大值为<code>max</code>的随机数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;random&gt;.nextInt(max);</span><br></pre></td></tr></table></figure><h2 id="Level"><a href="#Level" class="headerlink" title="Level"></a>Level</h2><ul><li>继承自 PointerClass</li></ul><p>返回 Random 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;level&gt;.getRandom();</span><br></pre></td></tr></table></figure><p>生成特定命名空间ID的实体到世界中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addEntity(source, x, y, z, namespace);</span><br></pre></td></tr></table></figure><p>返回自世界创建以来的总 tick 数 (1 tick = 1/20s)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getCurrentTick();</span><br></pre></td></tr></table></figure><p>返回服务端自世界创建以来的总 tick 数 (1 tick = 1/20с)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getCurrentServerTick();</span><br></pre></td></tr></table></figure><p>获取玩家加载区块范围</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getChunkTickRange();</span><br></pre></td></tr></table></figure><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><ul><li>继承自 PointerClass</li></ul><p>获取用户界面类型 - 0 为 Pocket UI, 1 为经典UI</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;options&gt;.getUiProfile();</span><br></pre></td></tr></table></figure><h2 id="GuiData"><a href="#GuiData" class="headerlink" title="GuiData"></a>GuiData</h2><ul><li>继承自 PointerClass</li></ul><p>展示标题消息（等同于 /title <actorUid> title）</actorUid></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;guiData&gt;.setTitle(name);</span><br></pre></td></tr></table></figure><p>展示副标题消息（等同于 /title <actorUid> subtitle）</actorUid></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;guiData&gt;.setSubtitle(name);</span><br></pre></td></tr></table></figure><p>展示快捷栏标题消息（等同于 /title <actorUid> actionbar）</actorUid></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;guiData&gt;.setActionMessage(name);</span><br></pre></td></tr></table></figure><h2 id="ClientInstance"><a href="#ClientInstance" class="headerlink" title="ClientInstance"></a>ClientInstance</h2><ul><li>继承自 PointerClass</li></ul><p>返回 Options 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ClientInstance&gt;.getOptions();</span><br></pre></td></tr></table></figure><p>返回 GuiData 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ClientInstance&gt;.getGuiData();</span><br></pre></td></tr></table></figure><p>在特定坐标播放方块破坏粒子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ClientInstance&gt;.renderDestroyBlock(x, y, z, speed);</span><br></pre></td></tr></table></figure><p>将本地玩家的相机设置为另一个实体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ClientInstance&gt;.setCameraEntity(entity);</span><br></pre></td></tr></table></figure><h2 id="GlobalContext"><a href="#GlobalContext" class="headerlink" title="GlobalContext"></a>GlobalContext</h2><p>返回 ClientInstance 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GlobalContext.getClientInstance();</span><br></pre></td></tr></table></figure><p>返回服务端的 Level 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GlobalContext.getServerLevel();</span><br></pre></td></tr></table></figure><p>返回客户端的 Level 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GlobalContext.getLevel();</span><br></pre></td></tr></table></figure><h2 id="BlockUtils"><a href="#BlockUtils" class="headerlink" title="BlockUtils"></a>BlockUtils</h2><p>返回 LegacyBlock 的 PointerClass 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockUtils.getBlockById(id);</span><br></pre></td></tr></table></figure><p>返回 BlockState 的 PointerClass 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockUtils.getBlockStateForIdData(id, data);</span><br></pre></td></tr></table></figure><h1 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h1><p>Minecraft 中的每个方法都有它的唯一标识符（符号，<em>symbol</em>），通过符号可以为方法创建 Hook （监听器）或调用它。</p><blockquote><p>如何找到方法的符号？<br><a href="https://hex-rays.com/IDA-pro/">IDA Pro – Hex Rays</a> - Windows, Linux, macOS<br><a href="https://github.com/NationalSecurityAgency/ghidra">Ghidra Software Reverse Engineering Framework</a> - Windows, Linux, macOS<br><a href="https://play.google.com/store/apps/details?id=com.mcal.disassembler">Disassembler - Viewer, Dumper</a> - Android</p></blockquote><h2 id="Injector"><a href="#Injector" class="headerlink" title="Injector"></a>Injector</h2><p>用于和原版的类一起使用，以供调用方法并获取返回值。如果不打算再使用，建议释放内存。可以通过指针或 PointerClass 的实例对象来创建。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Injector(pointer);</span><br><span class="line"><span class="keyword">new</span> Injector(PointerClass);</span><br></pre></td></tr></table></figure><p>返回库中的 Offset 类，相当实用，需要查找相应的反汇编代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;injector&gt;.getOffset();</span><br><span class="line">&lt;injector&gt;.getOffset(offset);</span><br></pre></td></tr></table></figure><p>调用原版方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;injector&gt;.call(symbol, parameters, table);</span><br></pre></td></tr></table></figure><p>调用原版方法，返回值为整型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;injector&gt;.getIntResult(symbol, parameters, table);</span><br></pre></td></tr></table></figure><p>调用原版方法，返回值为浮点数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;injector&gt;.getFloatResult(symbol, parameters, table);</span><br></pre></td></tr></table></figure><p>调用原版方法，返回值为布尔值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;injector&gt;.getBoolResult(symbol, parameters, table);</span><br></pre></td></tr></table></figure><p>调用原版方法，返回值为字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;injector&gt;.getStringResult(symbol, parameters, table);</span><br></pre></td></tr></table></figure><p>调用原版方法，返回值为该类的实例对象的指针</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;injector&gt;.getPointerResult(symbol, parameters, table);</span><br></pre></td></tr></table></figure><p>用其他任意的方法替换特定的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;injector&gt;.replace(table, method, symbol);</span><br></pre></td></tr></table></figure><p>释放内存，将无法再与此对象进行交互</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;injector&gt;.free();</span><br></pre></td></tr></table></figure><p>设置原版库的名称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;injector&gt;.setLib(name);</span><br></pre></td></tr></table></figure><h3 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h3><p>如果一个类没有实例也不能创建实例，但存在静态方法，可通过构造一个空白的实例对象来调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Injector();</span><br></pre></td></tr></table></figure><h2 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h2><p>该类允许通过偏移获取类的字段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;offset&gt;.setOffset(offset);</span><br><span class="line"><span class="comment">// 获取整型</span></span><br><span class="line">&lt;offset&gt;.getInt(offset?);</span><br><span class="line"><span class="comment">// 获取浮点值</span></span><br><span class="line">&lt;offset&gt;.getFloat(offset?);</span><br><span class="line"><span class="comment">// 获取值的指针</span></span><br><span class="line">&lt;offset&gt;.getPointer(offset?);</span><br><span class="line"><span class="comment">// 获取字符串</span></span><br><span class="line">&lt;offset&gt;.getString(offset?);</span><br><span class="line"><span class="comment">// 释放内存，不可再使用</span></span><br><span class="line">&lt;offset&gt;.free();</span><br></pre></td></tr></table></figure><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><ol><li>在模组文件夹中创建一个<code>hooks.json</code>文件。</li><li>在其中编写 Hook 对象的描述。</li><li>在模组脚本中添加回调（回调函数的第一个参数为控制器，第二个为指向被 Hook 的类的指针，之后为在描述中定义的参数）。</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;symbol&quot;</span>: <span class="string">&quot;&lt;symbol&gt;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;callback&quot;</span>: <span class="string">&quot;&lt;callbackName&gt;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;args&quot;</span>: [], <span class="comment">// 默认为 []</span></span><br><span class="line">    <span class="attr">&quot;priority&quot;</span>: <span class="string">&quot;pre&quot;</span> <span class="comment">// 在方法调用之前或之后触发，默认为 pre 之前，可选 post 之后</span></span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: <span class="string">&quot;mcpe&quot;</span>, <span class="comment">// 默认为 mcpe</span></span><br><span class="line">    <span class="attr">&quot;return&quot;</span>: <span class="string">&quot;bool&quot;</span> <span class="comment">// 默认为 void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>返回值的类型</p><ul><li>stl::string</li><li>void - 接受类的实例对象的指针</li><li>int</li><li>float</li><li>bool</li></ul></li><li><p>参数类型</p><ul><li>stl::string</li><li>int</li><li>float</li><li>ptr</li><li>BlockPos</li><li>Vec2</li><li>Vec3</li><li>ChunkPos</li><li>BlockSource</li><li>CompoundTag</li></ul></li></ul><blockquote><p>对于其他的数据类型，可以使用指针<code>ptr</code>。另外不要忘记替换<code>&lt;symbol&gt;</code>为需要覆盖的特定符号，以及<code>&lt;callbackName&gt;</code>将作为该方法执行时调用的回调。</p></blockquote><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><ul><li>模组<ul><li><a href="https://icmods.mineprogramming.org/mod?id=881">TimeWand</a></li><li><a href="https://icmods.mineprogramming.org/mod?id=872">NotBurningMobs</a></li><li><a href="https://icmods.mineprogramming.org/mod?id=883">Combination Lock</a></li><li><a href="https://icmods.mineprogramming.org/mod?id=869">Faster Ladder Climbing</a></li></ul></li></ul><ol><li><p>Injector 示例，当方块被点击时调用其 randomTick 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNativeBlock</span>(<span class="params">region, x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> injector = <span class="keyword">new</span> Injector(region.getPointer()).setArgsType([<span class="string">&quot;ptr&quot;</span>]);</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="keyword">new</span> BlockPos(x, y, z);</span><br><span class="line">    <span class="keyword">let</span> block = injector.getPointerResult(<span class="string">&quot;_ZNK11BlockSource8getBlockERK8BlockPos&quot;</span>, [</span><br><span class="line">        Parameter.getPointer(pos)</span><br><span class="line">    ]);</span><br><span class="line">    injector.free();</span><br><span class="line">    pos.free();</span><br><span class="line">    <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomTick</span>(<span class="params">block, x, y, z, region</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> injector = <span class="keyword">new</span> Injector(block).setArgsType([<span class="string">&quot;ptr&quot;</span>, <span class="string">&quot;ptr&quot;</span>, <span class="string">&quot;ptr&quot;</span>]);</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="keyword">new</span> BlockPos(x, y, z);</span><br><span class="line">    injector.call(<span class="string">&quot;_ZNK5Block10randomTickER11BlockSourceRK8BlockPosR6Random&quot;</span>, [</span><br><span class="line">        Parameter.getPointer(region.getPointer()),</span><br><span class="line">        Parameter.getPointer(pos),</span><br><span class="line">        Parameter.getPointer(GlobalContext.getServerLevel().getRandom())</span><br><span class="line">    ]);</span><br><span class="line">    pos.free();</span><br><span class="line">    injector.free();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Callback.addCallback(<span class="string">&quot;ItemUse&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">pos, item, block, is, player</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> region = BlockSource.getDefaultForActor(player);</span><br><span class="line">    randomTick(getNativeBlock(region, pos.x, pos.y, pos.z), pos.x, pos.y, pos.z, region);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>Offset 示例，当点击方块时创建一个 BlockPos 实例，其坐标值为偏移值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Callback.addCallback(<span class="string">&quot;ItemUse&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">coords, item, block, is, player</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="keyword">new</span> BlockPos(coords.x, coords.y, coords.z);</span><br><span class="line">    <span class="keyword">let</span> injector = <span class="keyword">new</span> Injector(pos);</span><br><span class="line">    <span class="keyword">let</span> offset = injector.getOffset();</span><br><span class="line">    alert(offset.getInt(<span class="number">0</span>) + <span class="string">&quot; &quot;</span> + offset.getInt(<span class="number">4</span>) + <span class="string">&quot; &quot;</span> + offset.getInt(<span class="number">8</span>));</span><br><span class="line">    pos.free();</span><br><span class="line">    injector.free();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>Hook 示例，更改确定白天的逻辑，使无论在什么时间亡灵生物都会燃烧</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;symbol&quot;</span>: <span class="string">&quot;_ZNK9Dimension5isDayEv&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;callback&quot;</span>: <span class="string">&quot;Dimension.isDay&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;priority&quot;</span>: <span class="string">&quot;pre&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;return&quot;</span>: <span class="string">&quot;bool&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Callback.addCallback(<span class="string">&quot;Dimension.isDay&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">controller, self</span>)</span>&#123;</span><br><span class="line">    controller.replace();</span><br><span class="line">    controller.setResult(<span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>一个设置红石信号强度的例子，当使用木棍点击方块时会设置此处的红石信号强度为5。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDimension</span>(<span class="params">region</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> injector = <span class="keyword">new</span> Injector(region.getPointer());</span><br><span class="line"><span class="keyword">let</span> dimension = injector.getPointerResult(<span class="string">&quot;_ZN11BlockSource12getDimensionEv&quot;</span>);</span><br><span class="line">injector.free();</span><br><span class="line"><span class="keyword">return</span> dimension;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCircuitSystem</span>(<span class="params">region</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> injector = <span class="keyword">new</span> Injector(getDimension(region));</span><br><span class="line"><span class="keyword">let</span> system = injector.getPointerResult(<span class="string">&quot;_ZN9Dimension16getCircuitSystemEv&quot;</span>);</span><br><span class="line">injector.free();</span><br><span class="line"><span class="keyword">return</span> system;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cache = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">redstoneUpdate</span>(<span class="params">region, x, y, z, strength</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> system = cache[region.getDimension()];</span><br><span class="line"><span class="keyword">if</span>(!system)&#123;</span><br><span class="line">cache[region.getDimension()] = getCircuitSystem(region);</span><br><span class="line">system = cache[region.getDimension()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> injector = <span class="keyword">new</span> Injector(system);</span><br><span class="line"><span class="keyword">let</span> pos = <span class="keyword">new</span> BlockPos(x, y, z);</span><br><span class="line">injector.setArgsType([<span class="string">&quot;ptr&quot;</span>, <span class="string">&quot;int&quot;</span>]).call(<span class="string">&quot;_ZN13CircuitSystem11setStrengthERK8BlockPosi&quot;</span>, [</span><br><span class="line">Parameter.getPointer(pos),</span><br><span class="line">Parameter.getInt(strength||<span class="number">10</span>)</span><br><span class="line">]);</span><br><span class="line">injector.free();</span><br><span class="line">pos.free();</span><br><span class="line">&#125;</span><br><span class="line">Callback.addCallback(<span class="string">&quot;ItemUse&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">pos, item, block, is, player</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(item.id == <span class="number">280</span>)</span><br><span class="line">        Updatable.addUpdatable(&#123;</span><br><span class="line">            <span class="attr">tick</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="function"><span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.tick &gt;= <span class="number">20</span>)</span><br><span class="line">                    <span class="built_in">this</span>.remove = <span class="literal">true</span>;</span><br><span class="line">                redstoneUpdate(BlockSource.getDefaultForActor(player), pos.x, pos.y, pos.z, <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h1 id="原生类"><a href="#原生类" class="headerlink" title="原生类"></a>原生类</h1><p>为了使用方便，原生类都继承自 PointerClass。</p><p>返回类的实例对象的指针</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;pointerClass&gt;.getPointer();</span><br></pre></td></tr></table></figure><h2 id="ItemsUtil"><a href="#ItemsUtil" class="headerlink" title="ItemsUtil"></a>ItemsUtil</h2><p>获取特定ID物品的 PointerClass 实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ItemsUtil.getItemById(id);</span><br></pre></td></tr></table></figure><p>修改物品名称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ItemsUtil.overrideName(id, data, name);</span><br></pre></td></tr></table></figure><p>修改盔甲的护甲值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ItemsUtil.overrideArmorValue(id, value);</span><br></pre></td></tr></table></figure><h2 id="EntityRegister"><a href="#EntityRegister" class="headerlink" title="EntityRegister"></a>EntityRegister</h2><p>通过字符串类型的标识符向实体添加 tick 回调（例如 <code>minecraft:zombie&lt;&gt;</code>，其中<code>&lt;&gt;</code>为年龄，状态等附加数据）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EntityRegister.setHandlerTick(name, <span class="function"><span class="keyword">function</span>(<span class="params">ent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使符合条件的生物升天</span></span><br><span class="line">    Entity.setVelocity(ent, <span class="number">0</span>, <span class="number">0.0005</span>, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="BlockPos"><a href="#BlockPos" class="headerlink" title="BlockPos"></a>BlockPos</h2><ul><li>继承自 PointerClass</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BlockPos(pointer);</span><br><span class="line"><span class="keyword">new</span> BlockPos(x, y, z);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;blockPos&gt;.getX();</span><br><span class="line">&lt;blockPos&gt;.getY();</span><br><span class="line">&lt;blockPos&gt;.getZ();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;blockPos&gt;.setX(x);</span><br><span class="line">&lt;blockPos&gt;.setY(y);</span><br><span class="line">&lt;blockPos&gt;.setZ(z);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;blockPos&gt;.free();</span><br></pre></td></tr></table></figure><h2 id="Vec3"><a href="#Vec3" class="headerlink" title="Vec3"></a>Vec3</h2><ul><li>继承自 PointerClass</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vec3(pointer);</span><br><span class="line"><span class="keyword">new</span> Vec3(x, y, z);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;vec3&gt;.getX();</span><br><span class="line">&lt;vec3&gt;.getY();</span><br><span class="line">&lt;vec3&gt;.getZ();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;vec3&gt;.setX(x);</span><br><span class="line">&lt;vec3&gt;.setY(y);</span><br><span class="line">&lt;vec3&gt;.setZ(z);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;vec3&gt;.free();</span><br></pre></td></tr></table></figure><h2 id="Vec2"><a href="#Vec2" class="headerlink" title="Vec2"></a>Vec2</h2><ul><li>继承自 PointerClass</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vec2(pointer);</span><br><span class="line"><span class="keyword">new</span> Vec2(x, y);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;vec2&gt;.getX();</span><br><span class="line">&lt;vec2&gt;.getY();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;vec2&gt;.setX(x);</span><br><span class="line">&lt;vec2&gt;.setY(y);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;vec2&gt;.free();</span><br></pre></td></tr></table></figure><h2 id="ChunkPos"><a href="#ChunkPos" class="headerlink" title="ChunkPos"></a>ChunkPos</h2><ul><li>继承自 PointerClass</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ChunkPos(pointer);</span><br><span class="line"><span class="keyword">new</span> ChunkPos(x, z);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChunkPos&gt;.getX();</span><br><span class="line">&lt;ChunkPos&gt;.getZ();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChunkPos&gt;.setX(x);</span><br><span class="line">&lt;ChunkPos&gt;.setZ(z);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChunkPos&gt;.free();</span><br></pre></td></tr></table></figure><h2 id="Gui"><a href="#Gui" class="headerlink" title="Gui"></a>Gui</h2><p>在特定坐标播放方块破坏动画</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gui.animationDestroy(x, y, z);</span><br></pre></td></tr></table></figure><blockquote><p>在声明文件<a href="https://github.com/Reider745/libs/blob/main/mod_documentation_api/CoreUtility/core-utility.d.ts">core-utility.d.ts</a>中提供了一些方法文档</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Core-Utility&quot;&gt;&lt;a href=&quot;#Core-Utility&quot; class=&quot;headerlink&quot; title=&quot;Core Utility&quot;&gt;&lt;/a&gt;Core Utility&lt;/h1&gt;&lt;h2 id=&quot;应用领域&quot;&gt;&lt;a href=&quot;#应用领域&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>在Horizon使用ZeroTier进行多人游戏</title>
    <link href="https://weifeng233.github.io/2022/07/21/mutiplayer-in-horizon/"/>
    <id>https://weifeng233.github.io/2022/07/21/mutiplayer-in-horizon/</id>
    <published>2022-07-20T17:46:48.363Z</published>
    <updated>2022-07-20T17:49:52.273Z</updated>
    
    <content type="html"><![CDATA[<p>首先下载<a href="https://github.com/kaaass/ZerotierFix/releases/download/1.0.5_189/1.0.5_189.apk">ZeroTier</a>，如果打不开可以用<a href="https://hub.fastgit.xyz/kaaass/ZerotierFix/releases/download/1.0.5_189/1.0.5_189.apk">镜像</a>。</p><p>然后到<a href="https://www.zerotier.com/">ZeroTier官网</a>注册账号，接着去<a href="https://my.zerotier.com/network">创建一个网络</a>，点击<strong>Create A Network</strong>按钮然后复制<strong>NETWORK ID</strong>即可</p><p><img src="/2022/07/21/mutiplayer-in-horizon/1.png" alt="image-20220720234616437"></p><p>之后进入网络设置将访问控制更改为公共（你也可以选择私人，但那样每有新人加入时就需要手动在该页面同意），你也可以顺便改个名字</p><p><img src="/2022/07/21/mutiplayer-in-horizon/2.png" alt="image-20220721000234346"></p><p>然后在手机上打开<strong>ZeroTier Fix</strong>，进行极其简单的操作：</p><p><img src="/2022/07/21/mutiplayer-in-horizon/3.png" alt="image-20220721001124851"></p><p>然后进入游戏即可与普通的局域网联机一样了</p><p><img src="/2022/07/21/mutiplayer-in-horizon/4.png" alt="image-20220721014212117"></p><p><img src="/2022/07/21/mutiplayer-in-horizon/5.png" alt="MuMu20220721013920"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先下载&lt;a href=&quot;https://github.com/kaaass/ZerotierFix/releases/download/1.0.5_189/1.0.5_189.apk&quot;&gt;ZeroTier&lt;/a&gt;，如果打不开可以用&lt;a href=&quot;https://hub.f</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内核课程 - 0：模组结构、编程语言和库</title>
    <link href="https://weifeng233.github.io/2022/07/17/0/"/>
    <id>https://weifeng233.github.io/2022/07/17/0/</id>
    <published>2022-07-17T11:00:33.475Z</published>
    <updated>2022-07-17T13:19:56.560Z</updated>
    
    <content type="html"><![CDATA[<p>本文是ICMod开发教程的第0章，主要内容为<strong>模组结构</strong>，<strong>编程语言</strong>和<strong>库</strong>，适用版本为InnerCore 2.x（在玩家社区中通常以Horizon指代），注意发布时间。</p><h2 id="模组结构"><a href="#模组结构" class="headerlink" title="模组结构"></a>模组结构</h2><p>ICMod是以文件夹的形式放在对应InnerCore包下的<code>innercore/mods</code>文件夹，在发布时以<strong>ZIP</strong>格式的压缩包并通常使用<code>.icmod</code>作为文件后缀。</p><p>在ICMod中，许多文件的相对位置和名称都可以在<code>build.config</code>中指定，除了以下文件：</p><pre><code>模组文件夹  │  build.config - 模组的结构信息和编译信息 │  config.json - 模组的配置文件  │  config.info.json - 模组配置文件的描述文件，包括本地化(翻译)和配置属性 │  mod.info - 模组信息 │  mod_icon.png - 模组图标 |  └─.dex - 已编译的模组源码</code></pre><p>先简单说一下<code>mod.info</code>的内容，包含以下信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;模组名称&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;模组作者&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;模组版本&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;模组简介&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于配置文件以后会单独讲解，这里先按下不表。</p><p><code>build.config</code>中的内容可由模组作者自行修改，这里举个例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EnergyTech(能源科技) - V4.0.2</span></span><br><span class="line"><span class="comment">//该build.config由官方的toolchain自动生成，在较新的模组中是相当典型的例子</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;defaultConfig&quot;</span>:&#123; <span class="comment">//主要参数</span></span><br><span class="line">    <span class="attr">&quot;readme&quot;</span>:<span class="string">&quot;this build config is generated automatically by mod development toolchain&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;api&quot;</span>:<span class="string">&quot;CoreEngine&quot;</span>, <span class="comment">//指定API，还可以选择 AdaptedScript 但缺少了很多拓展功能，更贴近底层(Java层)</span></span><br><span class="line">    <span class="attr">&quot;buildType&quot;</span>:<span class="string">&quot;develop&quot;</span> <span class="comment">//编译类型，通常建议在发布时更改为 release</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;compile&quot;</span>:[ <span class="comment">//可执行文件，应 launcher 和 mod 源码类型各至少有一个</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;source/main.js&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sourceType&quot;</span>:<span class="string">&quot;mod&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;source/launcher.js&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sourceType&quot;</span>:<span class="string">&quot;launcher&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;library/BlockEngine.js&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sourceType&quot;</span>:<span class="string">&quot;library&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;library/ChargeItem.js&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sourceType&quot;</span>:<span class="string">&quot;library&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;library/SoundLib.js&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sourceType&quot;</span>:<span class="string">&quot;library&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;resources&quot;</span>:[ <span class="comment">//资源文件，如模组贴图和GUI贴图</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;resources/res&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;resourceType&quot;</span>:<span class="string">&quot;resource&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;gui/gui&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;resourceType&quot;</span>:<span class="string">&quot;gui&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;nativeDirs&quot;</span>:[], <span class="comment">//原生模组模块文件夹</span></span><br><span class="line">  <span class="attr">&quot;javaDirs&quot;</span>:[], <span class="comment">//Java模块文件夹</span></span><br><span class="line">  <span class="attr">&quot;buildDirs&quot;</span>:[] <span class="comment">//可行性构建文件夹</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>compile</code>中指定了很多js文件，其中<code>mod</code>类型即为模组的主要代码；<code>launcher</code>类型的文件只能有一个，用于决定模组是否启动；<code>library</code>类型为库，除了像这样一个一个添加之外还可以在<code>defaultConfig</code>中指定<code>libraryDir</code>，这样将会将该目录下的所有文件当作库并尝试执行；除了以上三种之外还有另外两种类型，分别是在模组加载之前执行的<code>preloader</code>和仅能在其他类型中使用<code>runCustomSource</code>方法调用的<code>custom</code>类型，值得注意的是这两种类型除了部分常量之外无法使用IC提供的API（虽然可以通过rhino调用，但不建议也没必要）。</p><p><code>resources</code>用于指定资源文件，没什么好说的，只需要注意GUI纹理资源需要单独指定。</p><p><code>nativeDirs</code>和<code>javaDirs</code>的用法见下文，此处单讲<code>buildDirs</code>。<code>buildDirs</code>允许开发者将可执行文件分散成多个文件以方便开发，举个简单的例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;buildDirs&quot;</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;dir&quot;</span>:<span class="string">&quot;source/dev/&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;targetSource&quot;</span>:<span class="string">&quot;source/main.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p><code>dir</code>指定了可执行文件存放的文件夹，此文件夹内必须有一个<code>includes</code>文件逐行记录了各个文件的相对位置，InnerCore将会按顺序合并为一个文件并覆写到<code>targetSource</code>指定的文件中。此过程并非简单的文本拼接，不可将完整的代码文件随意拆分为两个文件，否则可能会导致错误。</p><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>ICMod主要使用的编程语言是JavaScript，使用Rhino作为引擎，支持ES5和极少一部分ES6特性和调用Java，主要劣势为运行速度相当慢，与主流JS引擎相差百倍，但对于大多数情况都是够用的。这里推荐几个JS学习资源：</p><p><a href="https://wizardforcel.gitbooks.io/eloquent-js-3e/content/">JavaScript编程精解</a>，相当不错的入门书籍。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">JavaScript | MDN</a>，权威且全面，页面内还附有其他资源链接。</p><p><a href="https://mozilla.github.io/rhino/compat/engines.html">Rhino ES2015 Support</a>，关于Rhino引擎对于ES6特性的实际支持情况。</p><p>但JS有一个特点，就是它是弱类型语言，对于一些更习惯强类型语言的开发者可以选择TypeScript，在官方的toolchain中就支持使用TS编写模组并在之后转译为JS供InnerCore使用。同样的，推荐一些教程：</p><p><a href="https://www.typescriptlang.org/zh/">官方文档</a>，权威，最新。</p><p><a href="https://ts.xcatliu.com/introduction/index.html">TypeScript入门教程</a>，<a href="https://www.runoob.com/typescript/ts-tutorial.html">菜鸟教程</a>，中文，方便阅读但不是最新版本。</p><p>除了使用JS/TS，ICMod还允许使用Java或者Native模块来拓展API，需要有Java和C/C++知识并了解一些Android SDK/NDK开发，此处不再提供相关资源链接，但应注意始终以对应版本的官方文档为准，善用搜索引擎查找问题以及在提问前明确问题。</p><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>库用于拓展API，可以是单个的JS文件也可以是以模块形式的DEX文件或者SO文件又或者是单独的模组，关于JS格式的库在模组中的存放位置已在前文叙述，这里仅将如何编写内容和使用。</p><h3 id="JS库"><a href="#JS库" class="headerlink" title="JS库"></a>JS库</h3><p>在库的开头，需要使用<code>LIBRARY</code>方法来描述库的基本信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;名称&quot;</span>, <span class="comment">// 库的唯一识别名称，不应再修改</span></span><br><span class="line">    <span class="attr">version</span>: 版本, <span class="comment">// 库的版本，必须为大于0的整数，更高版本的库会覆盖更低版本的</span></span><br><span class="line">    <span class="attr">shared</span>: <span class="literal">false</span>, <span class="comment">// 如果为 true 则库将作为全局API，即所有使用该库的模组共用相同的API对象，否则仅作用于单个模组</span></span><br><span class="line">    <span class="attr">api</span>: <span class="string">&quot;CoreEngine&quot;</span>, <span class="comment">// 库使用的API</span></span><br><span class="line">    <span class="attr">dependencies</span>: [<span class="string">&quot;name1:version1&quot;</span>,</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    ] <span class="comment">//在库中导入的依赖库列表</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要导出库中的API，使用<code>EXPORT</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXPORT(<span class="string">&quot;API对象名称&quot;</span>, API对象);</span><br><span class="line"></span><br><span class="line"><span class="comment">//EXPORT还支持指定导出API对象的最低库版本</span></span><br><span class="line"><span class="comment">//如加入在一个库中存在以下三条EXPORT</span></span><br><span class="line">EXPORT(<span class="string">&quot;print&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    alert(<span class="string">&quot;new version print&quot;</span>); </span><br><span class="line">&#125;);</span><br><span class="line">EXPORT(<span class="string">&quot;print:3&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    alert(<span class="string">&quot;older print&quot;</span>); </span><br><span class="line">&#125;);</span><br><span class="line">EXPORT(<span class="string">&quot;print:1&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    alert(<span class="string">&quot;first version print&quot;</span>); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//一般情况下，默认使用第一个print方法</span></span><br><span class="line"><span class="comment">//但当使用者指定的库版本＞1且≤3时，将使用第二个print方法</span></span><br><span class="line"><span class="comment">//若指定的库版本为1，则使用第三个print方法</span></span><br></pre></td></tr></table></figure><p>在模组中导入库时，使用<code>IMPORT</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMPORT(<span class="string">&quot;库名称&quot;</span>); <span class="comment">//导入整个库</span></span><br><span class="line">IMPORT(<span class="string">&quot;库名称&quot;</span>, <span class="string">&quot;API对象名称&quot;</span>); <span class="comment">//导入特定的API</span></span><br><span class="line">IMPORT(<span class="string">&quot;库名称:库版本&quot;</span>); <span class="comment">//指定库版本</span></span><br></pre></td></tr></table></figure><h3 id="原生模块和Java模块"><a href="#原生模块和Java模块" class="headerlink" title="原生模块和Java模块"></a>原生模块和Java模块</h3><p>在<code>nativeDirs</code>和<code>javaDirs</code>中与<code>buildDirs</code>相似，只需要指定<code>path</code>即可，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;nativeDirs&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;source/native/&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在指定的目录下必须有一个<code>manifest</code>文件来指定相关信息，对于原生模块，格式是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;shared&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>, <span class="comment">//此名称为编译后生成的so文件名称，如 libname.so</span></span><br><span class="line">        <span class="attr">&quot;include&quot;</span>: [ <span class="comment">//编译时包含的源码文件夹，可选</span></span><br><span class="line">            <span class="string">&quot;shared_headers&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;depends&quot;</span>: [ <span class="comment">//在编译的时候依赖的内置库，可选</span></span><br><span class="line">        <span class="string">&quot;innercore&quot;</span>,</span><br><span class="line">        <span class="string">&quot;nativejs&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时需要一个<code>main.cpp</code>文件包含基本的代码，你可以在官方的toolchain中使用NDK对其进行编译，也可以在Horzion中使用gcc编译。</p><p>对于Java模块，<code>manifest</code>文件的格式是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Toolchain示例模组</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;source-dirs&quot;</span>: [<span class="string">&quot;src&quot;</span>], <span class="comment">//源码文件夹</span></span><br><span class="line">    <span class="attr">&quot;library-dirs&quot;</span>: [<span class="string">&quot;lib&quot;</span>], <span class="comment">//JAR库文件夹</span></span><br><span class="line">    <span class="attr">&quot;verbose&quot;</span>: <span class="literal">true</span>, <span class="comment">//是否开启verbose输出</span></span><br><span class="line">    <span class="attr">&quot;options&quot;</span>: [], <span class="comment">//verbose选项</span></span><br><span class="line">    <span class="attr">&quot;boot-classes&quot;</span>: [<span class="string">&quot;com.sample_mod.sample_package.Boot&quot;</span>] <span class="comment">//要执行的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java编译可以在Toolchain中使用JDK完成，也可以在Horizon中完成。</p><p>要使用原生模块和Java模块，InnerCore提供了以下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMPORT_NATIVE(name, target); <span class="comment">//获取原生模块方法并注入到指定对象中</span></span><br><span class="line">WRAP_JAVA(name); <span class="comment">//获取Java对象并返回</span></span><br><span class="line">WRAP_NATIVE(name); <span class="comment">//获取原生模块并返回</span></span><br></pre></td></tr></table></figure><p>在Java模块中，得益于Rhino，所定义的Java类都可直接使用，而在原生模块中，需要<code>nativejs.h</code>头文件提供的方法才能创建可供JS使用的JS模块：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JS_MODULE_VERSION</span>(模块名称, <span class="number">1</span>); <span class="comment">//指定模块名称和版本</span></span><br><span class="line"><span class="built_in">JS_EXPORT</span>(模块名称, 方法名称, <span class="string">&quot;I()&quot;</span>, (JNIEnv* env) &#123; <span class="comment">//导出一个返回值为整型无参数的方法</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">NativeJS::<span class="built_in">wrapIntegerResult</span>(<span class="number">0</span>); <span class="comment">//返回 0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p>非常感谢您能读完本篇教程，因本人能力不足，对于教程中的疏漏与错误望各位指出斧正。</p><p>本系列教程将按照俄国社区先前编写的一份<a href="https://docs.google.com/spreadsheets/d/1KJokdmy4VZVGaPfe2JDwTKlii-wGQHmiUh5y2ORnSUw/edit#gid=0">课程表格(谷歌文档)</a>进行，下一篇将会简要讲解<strong>物品</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是ICMod开发教程的第0章，主要内容为&lt;strong&gt;模组结构&lt;/strong&gt;，&lt;strong&gt;编程语言&lt;/strong&gt;和&lt;strong&gt;库&lt;/strong&gt;，适用版本为InnerCore 2.x（在玩家社区中通常以Horizon指代），注意发布时间。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于InnerCore包</title>
    <link href="https://weifeng233.github.io/2022/04/07/%E5%85%B3%E4%BA%8EInnerCore%E5%8C%85/"/>
    <id>https://weifeng233.github.io/2022/04/07/%E5%85%B3%E4%BA%8EInnerCore%E5%8C%85/</id>
    <published>2022-04-07T12:42:10.438Z</published>
    <updated>2022-04-07T16:45:12.887Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文翻译自<a href="https://docs.mineprogramming.org/#/en/page/apps/horizon/packs">官方文档</a>，UI文本与<a href="https://gitlab.com/zhekasmirnov/horizon-cloud-config/-/commit/3632102ba431ba23c09374117b077af9b756e773#80bd4c0508d1d611d9ac5282791e8bebf5656c81">InnerCore b113</a>一致</p><h2 id="这个包有什么？"><a href="#这个包有什么？" class="headerlink" title="这个包有什么？"></a>这个包有什么？</h2><p>在InnerCore包的主菜单中有以下五个按钮：</p><ol><li><strong>游玩</strong> - 用于开始游戏的按钮</li><li><strong>原生模组</strong> - 位于屏幕右侧用于打开原生模组菜单的按钮</li><li><strong>模组管理器</strong> - 此游戏的模组管理器<ol><li>下载模组 - 允许你任意下载模组</li><li>我的模组 - 用于管理你已安装的模组</li><li>我的模组集 - 管理已安装的由开发者创作的现成整合包</li><li>模组更新 - 可更新的模组列表</li><li>访问网站 - 打开此游戏的一个成熟的模组网站</li></ol></li><li><strong>首选项和链接</strong><ol><li>首选项<ol><li><strong>禁用加载屏幕</strong> - 显示正在加载模组的页面，在某些设备上禁用后可能会提升加载速度</li><li><strong>开发人员模式</strong> - 对模组开发者相当实用，包括在支持的模组中启用调试模式</li><li><strong>使用旧版工作台 UI</strong> - 如果原版工作台对于一些配方无效，则可以恢复至之前的工作台UI</li><li><strong>基于时间限制更新</strong> - 开启后，模组在一游戏刻中产生的最大更新数量将被限制，否则将无限制，简单说就是模组每刻最多能调用的次数</li><li><strong>每刻最大的更新次数</strong> - 调整_更新次数限制_</li><li><strong>建立高级线程优先级</strong> - 更高的优先级可使TPS更稳定（这意味着更稳定的操作和响应时间），但可能会冻结线程和降低帧率</li><li><strong>服务端线程优先级</strong> - 调整_线程优先级_</li><li><strong>FPS阈值</strong> - 当FPS低于该阈值时，将会降低服务端线程优先级</li><li><strong>更多的线程数</strong> - 额外的更新线程，对于性能较强的设备上可以提升负载性能，注意，该功能仍处于实验性阶段，可能会不稳定</li><li><strong>更多的线程优先级</strong> - 调整_额外线程的优先级_</li><li><strong>自动保存</strong> - 允许你在游戏意外停止运行时保存存档和模组数据</li><li><strong>自动保存优先级</strong> - 两次保存之间间隔的秒数</li><li><strong>启用套接字服务器</strong> - 允许局域网内的玩家通过Socket协议进入你的世界</li><li><strong>优先化本地网络协议</strong> - 使用原生协议（默认情况下Socket协议有更高的优先级）</li><li><strong>（开发人员用）强制本地化本地协议</strong> - 使用原生协议进行本地客户端与服务端的通信，该选项仅用于调试模组，<strong>切勿在正常游戏中使用！</strong></li><li><strong>(For developers)Dump additional information</strong> - 在世界加载期间导出与开发相关的信息，dump文件会与log放在相同文件夹</li></ol></li><li>指南和链接 - 包含指南和社交网络链接的标签页</li><li>开发小组 - 开发者，测试员和模组开发者的贡献名单</li><li>关于</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://docs.mineprogramming.org/#/en/page/apps/horizon/packs&quot;&gt;官方文档&lt;/a&gt;，UI文本与&lt;a href=&quot;https://gitlab.com/zhekasmirnov/hor</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CraftTweaker使用教程</title>
    <link href="https://weifeng233.github.io/2022/01/15/CraftTweaker/"/>
    <id>https://weifeng233.github.io/2022/01/15/CraftTweaker/</id>
    <published>2022-01-15T06:40:12.563Z</published>
    <updated>2022-01-22T15:50:15.431Z</updated>
    
    <content type="html"><![CDATA[<p>CraftTweaker（以下简称CrT）是由麦穗开发与同名的Java版模组有类似功能的魔改类模组。</p><p>本文将简要介绍如何编写和使用CrT脚本。</p><h2 id="加载脚本"><a href="#加载脚本" class="headerlink" title="加载脚本"></a>加载脚本</h2><p>CrT在运行时会读取<strong>当前加载模组集</strong>对应文件夹下<code>script</code>文件夹内的<strong>所有后缀为js的文件</strong>并为每一个脚本创建独立的沙盒以独立运行。</p><p>你可以在包对应文件夹内的<code>innercore/preferences.json</code>文件中的<code>pack_selected</code>键对应的属性得知当前所加载的模组集对应的路径，无论如何，<code>script</code>文件夹都应与<code>mods</code>文件夹在同一级文件夹内。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能放置脚本的文件夹</span></span><br><span class="line"><span class="comment">//pack_name/innercore/script/</span></span><br><span class="line"><span class="comment">//mod_pack_name/script/</span></span><br></pre></td></tr></table></figure><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>与<strong>ICMod</strong>一样，CrT脚本使用<strong>Rhino</strong>引擎运行，语言为<strong>JavaScript</strong>，支持ES5与部分ES6特性。</p><h3 id="预置函数"><a href="#预置函数" class="headerlink" title="预置函数"></a>预置函数</h3><p>CrT为CrT脚本提供了两个预置函数，分别为<code>$</code>和<code>require</code>，下文将分别介绍这两个函数的详细用法：</p><h4 id><a href="#" class="headerlink" title="$"></a>$</h4><p><code>$</code>用于创建<code>ItemStack</code>对象，是CrT和ICMod通用的物品格式。</p><h5 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $ 的格式如下</span></span><br><span class="line">$(<span class="string">&quot;type:name:data*count&quot;</span>);</span><br><span class="line"><span class="comment">/* type - ID的类型，分为方块 - block 和 物品 - item</span></span><br><span class="line"><span class="comment"> * name - ID的名称，如bedrock, stick等</span></span><br><span class="line"><span class="comment"> * data - 物品的特殊值/损坏值（可选）</span></span><br><span class="line"><span class="comment"> * count - 物品的数量（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//举例：</span></span><br><span class="line">$(<span class="string">&quot;block:bedrock&quot;</span>); <span class="comment">//基岩</span></span><br><span class="line">$(<span class="string">&quot;block:wool:6*32&quot;</span>); <span class="comment">//半组粉红色羊毛</span></span><br><span class="line">$(<span class="string">&quot;item:stick*64&quot;</span>); <span class="comment">//一组木棍</span></span><br><span class="line">$(<span class="string">&quot;item:diamond_shovel:1560&quot;</span>); <span class="comment">//一把快要坏掉的钻石锹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ItemStack 对象包含的值如下</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">index</span>: string, <span class="comment">//索引，即ID的名称</span></span><br><span class="line">    <span class="attr">id</span>: number, <span class="comment">//物品的数字ID</span></span><br><span class="line">    <span class="attr">data</span>: number, <span class="comment">//物品的特殊值/损坏值</span></span><br><span class="line">    <span class="attr">count</span>: number, <span class="comment">//物品的数量</span></span><br><span class="line">    <span class="attr">_condition</span>: <span class="function"><span class="keyword">function</span>, //合成条件，物品在工作台中参与合成时执行，详见下文</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ItemStack 对象有以下方法</span></span><br><span class="line">toItem(); <span class="comment">//返回 toItem 对象，详见下文</span></span><br><span class="line">toBlock(); <span class="comment">//返回 toBlock 对象，详见下文</span></span><br><span class="line">onUse(state); <span class="comment">// state - function 类型，为物品注册使用回调（点击方块时触发），返回该 ItemStack 自身</span></span><br><span class="line">getMaxStack(); <span class="comment">//返回 number 类型，该物品的最大堆叠数量</span></span><br><span class="line">only(state); <span class="comment">// state - function 类型，合成条件，详见下文，返回该 ItemStack 自身</span></span><br><span class="line">transformDamage(damage); <span class="comment">// damage - number 类型，设置物品在合成时增加的损坏值（或指消耗的耐久值），仅调用该方法而不传入参数将设置为1，返回该 ItemStack 自身</span></span><br><span class="line">reuse(); <span class="comment">//设置该物品在合成中不会消耗，返回该 ItemStack 自身</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toItem 对象有以下方法</span></span><br><span class="line">getMaxDamage(); <span class="comment">//返回 number 类型，该物品的最大特殊值/损坏值</span></span><br><span class="line">isTool(); <span class="comment">//返回 boolean 类型，该物品是否为工具（包含武器，装备等）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toBlock 对象有以下方法</span></span><br><span class="line">onPlace(state); <span class="comment">// state - function 类型，为方块注册放置回调，返回该 toBlock 自身</span></span><br><span class="line">getTileID(); <span class="comment">//返回 number 类型，该方块的数字ID（范围[0, 2048]）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回调相关示例，合成相关示例见下文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//极为经典的铁剑点地爆炸，因为在CrT所创建的沙盒中无法使用CEAPI，因此使用Rhino提供的调用Java的功能直接调用Java方法</span></span><br><span class="line">$(<span class="string">&quot;item:iron_sword&quot;</span>).onUse(<span class="function"><span class="keyword">function</span> (<span class="params">coords, item, block, isExternal, player</span>) </span>&#123;</span><br><span class="line">    com.zhekasmirnov.innercore.api.NativeAPI.explode(coords.x, coords.y, coords.z, <span class="number">10</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在基岩上放置基岩时爆炸</span></span><br><span class="line">$(<span class="string">&quot;block:bedrock&quot;</span>).toBlock().onPlace(<span class="function"><span class="keyword">function</span> (<span class="params">coords, item, block, player, region</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pos = coords.relative;</span><br><span class="line">    <span class="keyword">if</span> (!region.getBlock(pos.x, pos.y, pos.z).id) &#123;</span><br><span class="line">    region.setBlock(pos.x, pos.y, pos.z, $(<span class="string">&quot;block:bedrock&quot;</span>).id, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (block.id === $(<span class="string">&quot;block:bedrock&quot;</span>).id) &#123;</span><br><span class="line">    region.explode(pos.x, pos.y + <span class="number">1</span>, pos.z, <span class="number">100</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="require"><a href="#require" class="headerlink" title="require"></a>require</h4><p><code>require</code>可用于获取CrT的自定义API，在没有其他模组添加API的情况下，默认可获取的API有<code>furnace</code>和<code>recipes</code></p><h5 id="格式：-1"><a href="#格式：-1" class="headerlink" title="格式："></a>格式：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;api_name&quot;</span>); <span class="comment">//返回 api_name 对象</span></span><br></pre></td></tr></table></figure><h5 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为一般情况下只需要获取一次API对象，而且没有修改名称的必要，故赋值为常量</span></span><br><span class="line"><span class="keyword">const</span> Furnace = <span class="built_in">require</span>(<span class="string">&quot;furnace&quot;</span>); <span class="comment">//CrT预置的熔炉类</span></span><br><span class="line"><span class="keyword">const</span> Recipes = <span class="built_in">require</span>(<span class="string">&quot;recipes&quot;</span>); <span class="comment">//CrT预置的合成类</span></span><br></pre></td></tr></table></figure><p>下面将详细介绍<code>furnace</code>和<code>recipes</code>的详细用法</p><h4 id="furnace"><a href="#furnace" class="headerlink" title="furnace"></a>furnace</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们已经获取到了 furnace 对象并赋值给 Furnace，为方便，下文均使用 Furnace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Furnace 有三条函数可用</span></span><br><span class="line">Furnace.remove(input); <span class="comment">// input - ItemStack 类型，输入物品，移除某物品的熔炉配方</span></span><br><span class="line">Furnace.addRecipe(input, output); <span class="comment">// input - ItemStack 类型，输入物品，output - ItemStack 类型，输出物品，添加一条熔炉配方</span></span><br><span class="line">Furnace.setFuel(input, time); <span class="comment">// input - ItemStack 类型，燃料物品，time - number 类型，燃烧时间，设置某物品作为燃料的燃烧时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//举例：</span></span><br><span class="line">Furnace.remove($(<span class="string">&quot;block:iron_ore&quot;</span>)); <span class="comment">//移除铁矿石的熔炉配方</span></span><br><span class="line">Furnace.addRecipe($(<span class="string">&quot;item:rotten_flesh&quot;</span>), $(<span class="string">&quot;item:leather&quot;</span>)); <span class="comment">//经典的腐肉烧皮革</span></span><br><span class="line">Furnace.setFuel($(<span class="string">&quot;block:hay_block&quot;</span>), <span class="number">900</span>); <span class="comment">//将干草块设置为燃料，燃烧时间为4.5个物品</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注：200燃烧时间为一个物品</span></span><br></pre></td></tr></table></figure><h4 id="recipes"><a href="#recipes" class="headerlink" title="recipes"></a>recipes</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同上，下文均使用Recipes</span></span><br><span class="line"><span class="comment">//至此，我们可以说明上文的一些“详见下文”了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Recipes 有三条函数可用</span></span><br><span class="line">Recipes.remove(output); <span class="comment">// output - ItemStick 类型，输出物品，移除某物品的合成配方</span></span><br><span class="line">Recipes.addShaped(output, input); <span class="comment">// output - ItemStack 类型，输出物品，input - array 类型，包含输入物品的二维数组，添加有序合成</span></span><br><span class="line">Recipes.addShapeless(output, item); <span class="comment">// output - ItemStack 类型，输出物品，input - array 类型，包含输入物品的一维数组，添加无序合成</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//举例：</span></span><br><span class="line"><span class="comment">//移除工业模组中铜块合成配方（该函数在目前版本的IC暂不可移除原版合成配方）</span></span><br><span class="line">Recipes.remove($(<span class="string">&quot;block:blockCopper&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加基岩的合成配方，摆放方式如下所示</span></span><br><span class="line"><span class="comment"> * ABA</span></span><br><span class="line"><span class="comment"> * BAB</span></span><br><span class="line"><span class="comment"> * ABA</span></span><br><span class="line"><span class="comment"> * 其中 A 代表黑曜石，B 代表石头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Recipes.addShaped($(<span class="string">&quot;block:bedrock*3&quot;</span>), [[$(<span class="string">&quot;block:obsidian&quot;</span>), $(<span class="string">&quot;block:stone&quot;</span>), $(<span class="string">&quot;block:obsidian&quot;</span>)], [$(<span class="string">&quot;block:stone&quot;</span>), $(<span class="string">&quot;block:obsidian&quot;</span>), $(<span class="string">&quot;block:stone&quot;</span>)], [$(<span class="string">&quot;block:obsidian&quot;</span>), $(<span class="string">&quot;block:stone&quot;</span>), $(<span class="string">&quot;block:obsidian&quot;</span>)]]);</span><br><span class="line"><span class="comment">//你可以像下面这样写成多行以便阅读</span></span><br><span class="line">Recipes.addShaped($(<span class="string">&quot;block:bedrock*3&quot;</span>), [</span><br><span class="line">    [$(<span class="string">&quot;block:obsidian&quot;</span>), $(<span class="string">&quot;block:stone&quot;</span>), $(<span class="string">&quot;block:obsidian&quot;</span>)],</span><br><span class="line">    [$(<span class="string">&quot;block:stone&quot;</span>), $(<span class="string">&quot;block:obsidian&quot;</span>), $(<span class="string">&quot;block:stone&quot;</span>)],</span><br><span class="line">    [$(<span class="string">&quot;block:obsidian&quot;</span>), $(<span class="string">&quot;block:stone&quot;</span>), $(<span class="string">&quot;block:obsidian&quot;</span>)]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于不需要放物品的格子，留空或者填null即可</span></span><br><span class="line"><span class="comment">/* 添加用石头合成石镐的合成配方，摆放方式如下所示</span></span><br><span class="line"><span class="comment"> * AAA</span></span><br><span class="line"><span class="comment"> *  B</span></span><br><span class="line"><span class="comment"> *  B</span></span><br><span class="line"><span class="comment"> * 其中 A 代表石头，B 代表木棍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//如果你有够强迫症可以写这样（虽然对于强迫症我更建议写到一行，眼不见心不烦）</span></span><br><span class="line">Recipes.addShaped($(<span class="string">&quot;item:stone_pickaxe&quot;</span>), [</span><br><span class="line">    [$(<span class="string">&quot;block:stone&quot;</span>), $(<span class="string">&quot;block:stone&quot;</span>), $(<span class="string">&quot;block:stone&quot;</span>)],</span><br><span class="line">    [<span class="literal">null</span>            , $(<span class="string">&quot;item:stick&quot;</span>) , <span class="literal">null</span>            ],</span><br><span class="line">    [<span class="literal">null</span>            , $(<span class="string">&quot;item:stick&quot;</span>) , <span class="literal">null</span>            ]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加有不被消耗物品的合成</span></span><br><span class="line"><span class="comment">//使用铁锭和海洋之心合成三叉戟，其中海洋之心可以重复使用</span></span><br><span class="line">Recipes.addShaped($(<span class="string">&quot;item:trident&quot;</span>), [[$(<span class="string">&quot;item:iron_ingot&quot;</span>), $(<span class="string">&quot;item:iron_ingot&quot;</span>), $(<span class="string">&quot;item:iron_ingot&quot;</span>)], [<span class="literal">null</span>, $(<span class="string">&quot;item:heart_of_the_sea&quot;</span>).reuse(), <span class="literal">null</span>], [<span class="literal">null</span>, $(<span class="string">&quot;item:iron_ingot&quot;</span>), <span class="literal">null</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加无序合成与有序合成的方式十分相像，而且在添加输入物品时可以设置数量（有序合成则只能设置输出物品的数量），但要注意的是输入物品的总数不能超过9个</span></span><br><span class="line"><span class="comment">//截止至V1.1.0版本的CrT，有设置输入物品数量的配方会有部分物品不会消耗的BUG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为蘑菇煲添加两条合成配方，使其只需要任意两个蘑菇即可合成</span></span><br><span class="line">Recipes.addShapeless($(<span class="string">&quot;item:mushroom_stew&quot;</span>), [$(<span class="string">&quot;block:brown_mushroom&quot;</span>), $(<span class="string">&quot;block:brown_mushroom&quot;</span>), $(<span class="string">&quot;item:bowl&quot;</span>)]);</span><br><span class="line">Recipes.addShapeless($(<span class="string">&quot;item:mushroom_stew&quot;</span>), [$(<span class="string">&quot;block:red_mushroom&quot;</span>), $(<span class="string">&quot;block:brown_mushroom&quot;</span>), $(<span class="string">&quot;item:bowl&quot;</span>)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加消耗物品耐久的配方</span></span><br><span class="line"><span class="comment">//使用毒马铃薯合成马铃薯，并消耗剪刀1耐久值</span></span><br><span class="line"><span class="comment">//特殊值-1代表任意特殊值均可</span></span><br><span class="line">Recipes.addShapeless($(<span class="string">&quot;item:potato&quot;</span>), [$(<span class="string">&quot;item:shears:-1&quot;</span>).transformDamage(), $(<span class="string">&quot;item:poisonous_potato&quot;</span>)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义合成事件</span></span><br><span class="line"><span class="comment">//使用水桶与爆裂紫颂果合成紫颂果，并返还桶</span></span><br><span class="line">Recipes.addShapeless($(<span class="string">&quot;item:chorus_fruit&quot;</span>), [$(<span class="string">&quot;item:chorus_fruit_popped&quot;</span>), $(<span class="string">&quot;item:water_bucket&quot;</span>).only(<span class="function"><span class="keyword">function</span> (<span class="params">api, index, item, output</span>) </span>&#123;</span><br><span class="line">    item.id = $(<span class="string">&quot;item:bucket&quot;</span>).id;</span><br><span class="line">&#125;)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//木板与剪刀合成随机1-4根木棍并消耗剪刀相应的耐久值</span></span><br><span class="line">Recipes.addShapeless($(<span class="string">&quot;item:stick&quot;</span>), [$(<span class="string">&quot;block:planks&quot;</span>), $(<span class="string">&quot;item:shears:-1&quot;</span>).only(<span class="function"><span class="keyword">function</span> (<span class="params">api, index, item, output</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">4</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> max = $(<span class="string">&quot;item:shears&quot;</span>).toItem().getMaxDamage();</span><br><span class="line">    item.data += count;</span><br><span class="line">    <span class="keyword">if</span> (item.data &gt;= max) &#123;</span><br><span class="line">        count += max - item.data;</span><br><span class="line">        item.id = item.data = item.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    output.count = count;</span><br><span class="line">&#125;)]);</span><br></pre></td></tr></table></figure><h2 id="模组联动"><a href="#模组联动" class="headerlink" title="模组联动"></a>模组联动</h2><p>如果你是模组开发者，你可以通过<code>ModAPI</code>调用CrT提供的方法来拓展CrT</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CrT有以下方法可以通过ModAPI调用</span></span><br><span class="line">addAPI(name, state); <span class="comment">// name - string 类型，API名称，state - object 类型，API对象，像CrT添加自定义API以在脚本中使用</span></span><br><span class="line"><span class="built_in">require</span>(name); <span class="comment">// name - string 类型，API名称，同上文require</span></span><br><span class="line">requireGlobal(command); <span class="comment">// command - string 类型，要执行的代码，在CrT的中执行一段代码，慎用</span></span><br></pre></td></tr></table></figure><hr><p>好了，你已经学会如何使用CrT了，快去试着制作整合包吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CraftTweaker（以下简称CrT）是由麦穗开发与同名的Java版模组有类似功能的魔改类模组。&lt;/p&gt;
&lt;p&gt;本文将简要介绍如何编写和使用CrT脚本。&lt;/p&gt;
&lt;h2 id=&quot;加载脚本&quot;&gt;&lt;a href=&quot;#加载脚本&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>模组集</title>
    <link href="https://weifeng233.github.io/2022/01/01/%E6%A8%A1%E7%BB%84%E9%9B%86/"/>
    <id>https://weifeng233.github.io/2022/01/01/%E6%A8%A1%E7%BB%84%E9%9B%86/</id>
    <published>2022-01-01T10:12:49.659Z</published>
    <updated>2022-01-01T12:56:17.977Z</updated>
    
    <content type="html"><![CDATA[<p>模组集是在2.2.1b85更新中加入的功能。</p><p><img src="/2022/01/01/%E6%A8%A1%E7%BB%84%E9%9B%86/20220101180209.png" alt="20220101180209"></p><h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><p>模组集将一些互相兼容的模组整合为一个整体，通常包含附加代码或者模组以提高模组集成度和游戏玩法一致性。</p><p>在此更新中，模组将无法安装在模组集之外，因此InnerCore会创建一个默认模组集，你可以在其之中找到你之前安装的所有模组并通过模组管理器添加新模组。你可以到模组管理器的<strong>我的模组集</strong>中下载现成的模组集。要加载一个模组集只需要点击模组集页面上的<strong>选择</strong>按钮。</p><p><img src="/2022/01/01/%E6%A8%A1%E7%BB%84%E9%9B%86/20220101183027.png" alt="20220101183027"></p><p>无论何时都只能加载一个模组集。模组集默认到受更改保护，即模组集内的模组不会被模组管理器更新除非模组集有更新，以及你不能向模组集移除或添加模组，如果你尝试这样做会出现如下警告：</p><p><img src="/2022/01/01/%E6%A8%A1%E7%BB%84%E9%9B%86/20220101180729.png" alt="尝试修改一个受保护的模组集"></p><p>只有当你明白你在做什么时才允许修改模组集，当模组集被修改之后，模组集中的模组将开启更新功能，同时模组集会失去更新功能。</p><h2 id="创建你自己的模组集"><a href="#创建你自己的模组集" class="headerlink" title="创建你自己的模组集"></a>创建你自己的模组集</h2><p>你可以基于现有的模组集或默认模组集来创建你自己的模组集。使用模组集页面的<strong>克隆</strong>选项即可完成此工作（在目前版本中，部分设备可能无法克隆默认模组集，下文会讲如何使用文件管理器手动操作）</p><p><img src="/2022/01/01/%E6%A8%A1%E7%BB%84%E9%9B%86/20220101184036.png" alt="20220101184036"></p><p>生成的模组集会在对应的InnerCore包的<em><strong>modpacks</strong></em>文件夹内。接下来你可以使用模组管理器来安装所需的模组，也可以将你自己编写的模组添加到模组集的mods文件夹中。除此之外，你还可以添加模组集图标<em><strong>pack_icon.png</strong></em>，以及必须创建模组集清单文件<em><strong>modpacks.json</strong></em>，其中可包含以下字段：</p><ul><li>name - 模组集的短名称，将会作为其ID</li><li>displayedName - 模组集的展示名称</li><li>versionName - 模组集当前的版本名称</li><li>versionCode - 模组集当前的版本号</li><li>author - 模组集的作者名称</li><li>description - 模组集的简介</li></ul><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;coop-tech&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;displayedName&quot;</span>: <span class="string">&quot;Cooperative Tech&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;versionName&quot;</span>: <span class="string">&quot;1.01-beta​&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;versionCode&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;zheka_smirnov&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Simple small modpack, that contains few tech and utility mods and supports multiplayer.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦模组集构建完成，可以使用模组集界面内的<strong>压缩文件</strong>选项创建一个压缩存档保存在对应InnerCore包的<em><strong>modpacks-archive</strong></em>文件夹内，你可以在模组管理器的模组集页面重装模组集的压缩文档。</p><p><img src="/2022/01/01/%E6%A8%A1%E7%BB%84%E9%9B%86/20220101200640.png" alt="20220101200640"></p><h2 id="模组配置"><a href="#模组配置" class="headerlink" title="模组配置"></a>模组配置</h2><p>首先，你应该知道每个ICMod都有一个<em><strong>config.json</strong></em>文件用于存储的模组的配置信息，在模组集中应将模组的压缩文件统一放在模组集的<em><strong>config</strong></em>文件夹内，并按<em><strong>模组文件夹名-config.json</strong></em>的格式命名（文件夹名称中的空格需要使用-代替），此外，你还可以在该文件夹中创建一个<em><strong>.keep-unchanged</strong></em>文件夹用于存放不允许玩家修改的配置信息。</p><p><em><strong>注意：</strong></em>如果一个模组的配置信息不在config文件夹内时InnerCore会自动创建一个仅包含<em>enabled</em>字段的json文件，此操作可能会使模组无法读取到需要的配置信息而导致报错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;模组集是在2.2.1b85更新中加入的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/01/01/%E6%A8%A1%E7%BB%84%E9%9B%86/20220101180209.png&quot; alt=&quot;20220101180209&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;功能概</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用JavaScript实现的MCBE史莱姆区块算法</title>
    <link href="https://weifeng233.github.io/2021/08/29/%E4%BD%BF%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E7%9A%84MCBE%E5%8F%B2%E8%8E%B1%E5%A7%86%E5%8C%BA%E5%9D%97%E7%AE%97%E6%B3%95/"/>
    <id>https://weifeng233.github.io/2021/08/29/%E4%BD%BF%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E7%9A%84MCBE%E5%8F%B2%E8%8E%B1%E5%A7%86%E5%8C%BA%E5%9D%97%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-29T15:11:08.237Z</published>
    <updated>2022-01-11T16:53:28.415Z</updated>
    
    <content type="html"><![CDATA[<p>直接将origin0110使用C的<a href="https://github.com/origin0110/SlimeChunkFinder/blob/main/slimechunkfinder.c">代码</a>简单地用JS写一遍，在此记录：</p><p>2022/1/12：减少不必要的转无符号运算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSeed</span>(<span class="params">x, z</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * <span class="number">0x1f1f1f1f</span> ^ z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSlimeChunk</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> m = <span class="number">1</span> + <span class="built_in">Math</span>.imul(s ^ s &gt;&gt;&gt; <span class="number">30</span>, <span class="number">0x6c078965</span>);</span><br><span class="line">s = s &amp; <span class="number">0x80000000</span> | m &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; <span class="number">398</span>; i++)</span><br><span class="line">m = i + <span class="built_in">Math</span>.imul(m ^ m &gt;&gt;&gt; <span class="number">30</span>, <span class="number">0x6c078965</span>);</span><br><span class="line"></span><br><span class="line">m ^= (s &gt;&gt;&gt; <span class="number">1</span>) ^ (s &amp; <span class="number">1</span> ? <span class="number">0x9908b0df</span> : <span class="number">0x0</span>);</span><br><span class="line"></span><br><span class="line">m ^= m &gt;&gt;&gt; <span class="number">11</span>;</span><br><span class="line">m ^= m &lt;&lt; <span class="number">0x7</span> &amp; <span class="number">0x9d2c5680</span>;</span><br><span class="line">m ^= m &lt;&lt; <span class="number">0xf</span> &amp; <span class="number">0xefc60000</span>;</span><br><span class="line">m ^= m &gt;&gt;&gt; <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !((m &gt;&gt;&gt; <span class="number">0</span>) % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;直接将origin0110使用C的&lt;a href=&quot;https://github.com/origin0110/SlimeChunkFinder/blob/main/slimechunkfinder.c&quot;&gt;代码&lt;/a&gt;简单地用JS写一遍，在此记录：&lt;/p&gt;
&lt;p&gt;2022/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UI PART2</title>
    <link href="https://weifeng233.github.io/2021/08/14/UI-2/"/>
    <id>https://weifeng233.github.io/2021/08/14/UI-2/</id>
    <published>2021-08-13T17:51:44.941Z</published>
    <updated>2021-08-29T15:18:35.562Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注意：本教程仅为简单介绍UI的窗口，不会涉及详细的函数。如果想要了解更多请阅读官方文档。</strong></p><p>在上期教程中我们简要介绍了ICMod的UI构成与基本控件，接下来将详细介绍控件用法以及如何组成一个“精美”的界面。</p><h2 id="StandardWindow"><a href="#StandardWindow" class="headerlink" title="StandardWindow"></a>StandardWindow</h2><p><em><strong>在此纠正上一篇专栏的严重错误：StandartWindow在现在版本的InnerCore中已经弃用，使用StandardWindow替代。</strong></em></p><blockquote><p>你可以永远相信StandardWindow。 —Prosto Sostavil</p></blockquote><p><code>StandardWindow</code>是一个由三部分组成的<code>WindowGroup</code>，分别为<code>main</code>, <code>inventory</code>和<code>header</code>，对应关系如下图：</p><p><img src="/2021/08/14/UI-2/1629395365943.png" alt="StandartWindow"></p><p>Standard样式与原版的PocketUI相似，默认自带一个展示玩家背包的可滑动界面以及常规的关闭界面按钮和界面名称等，非常适合用作一般的方块实体的互动界面。</p><p>在此使用工业的火力发电机界面作为示例：</p><p><img src="/2021/08/14/UI-2/Screenshot_1.jpg" alt="火力发电机界面截图"></p><p>这是一个简单的界面，但基本上包含了常用控件，让我们简要分析一下其代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码使用TypeScript编写且分不同部分在多个文件中，为方便讲解取主要代码并使用JavaScript重写</span></span><br><span class="line"><span class="keyword">const</span> GUI_SCALE = <span class="number">3.2</span>; <span class="comment">//声明GUI_SCALE常量，以便统一模组内各界面</span></span><br><span class="line"><span class="keyword">new</span> UI.StandardWindow(&#123;</span><br><span class="line">    <span class="attr">standard</span>: &#123;</span><br><span class="line">        <span class="attr">header</span>: &#123;<span class="attr">text</span>: &#123;<span class="attr">text</span>: Translation.translate(<span class="string">&quot;Generator&quot;</span>)&#125;&#125;, <span class="comment">//此处使用Translate类函数以实现多语言，详见官方文档</span></span><br><span class="line">        <span class="attr">inventory</span>: &#123;<span class="attr">standard</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">        <span class="attr">background</span>: &#123;<span class="attr">standard</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">drawing</span>: [<span class="comment">//两个scale元素对应的当其为空时的贴图</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;bitmap&quot;</span>, <span class="attr">x</span>: <span class="number">530</span>, <span class="attr">y</span>: <span class="number">144</span>, <span class="attr">bitmap</span>: <span class="string">&quot;energy_bar_background&quot;</span>, <span class="attr">scale</span>: GUI_SCALE&#125;,</span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;bitmap&quot;</span>, <span class="attr">x</span>: <span class="number">450</span>, <span class="attr">y</span>: <span class="number">150</span>, <span class="attr">bitmap</span>: <span class="string">&quot;fire_background&quot;</span>, <span class="attr">scale</span>: GUI_SCALE&#125;,</span><br><span class="line">],</span><br><span class="line">    <span class="attr">elements</span>: &#123;</span><br><span class="line"><span class="string">&quot;energyScale&quot;</span>: &#123;<span class="attr">type</span>: <span class="string">&quot;scale&quot;</span>, <span class="attr">x</span>: <span class="number">530</span> + GUI_SCALE * <span class="number">4</span>, <span class="attr">y</span>: <span class="number">144</span>, <span class="attr">direction</span>: <span class="number">0</span>, <span class="attr">value</span>: <span class="number">0.5</span>, <span class="attr">bitmap</span>: <span class="string">&quot;energy_bar_scale&quot;</span>, <span class="attr">scale</span>: GUI_SCALE&#125;, <span class="comment">//注意此处x的值比对应的bitmap加了GUI_SCALE*4，这是因为它的贴图两端各少了4个像素，以便完整显示进度</span></span><br><span class="line"><span class="string">&quot;burningScale&quot;</span>: &#123;<span class="attr">type</span>: <span class="string">&quot;scale&quot;</span>, <span class="attr">x</span>: <span class="number">450</span>, <span class="attr">y</span>: <span class="number">150</span>, <span class="attr">direction</span>: <span class="number">1</span>, <span class="attr">value</span>: <span class="number">0.5</span>, <span class="attr">bitmap</span>: <span class="string">&quot;fire_scale&quot;</span>, <span class="attr">scale</span>: GUI_SCALE&#125;,</span><br><span class="line"><span class="string">&quot;slotEnergy&quot;</span>: &#123;<span class="attr">type</span>: <span class="string">&quot;slot&quot;</span>, <span class="attr">x</span>: <span class="number">441</span>, <span class="attr">y</span>: <span class="number">75</span>&#125;,</span><br><span class="line"><span class="string">&quot;slotFuel&quot;</span>: &#123;<span class="attr">type</span>: <span class="string">&quot;slot&quot;</span>, <span class="attr">x</span>: <span class="number">441</span>, <span class="attr">y</span>: <span class="number">212</span>&#125;,</span><br><span class="line"><span class="string">&quot;textInfo1&quot;</span>: &#123;<span class="attr">type</span>: <span class="string">&quot;text&quot;</span>, <span class="attr">x</span>: <span class="number">642</span>, <span class="attr">y</span>: <span class="number">142</span>, <span class="attr">width</span>: <span class="number">300</span>, <span class="attr">height</span>: <span class="number">30</span>, <span class="attr">text</span>: <span class="string">&quot;0/&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;textInfo2&quot;</span>: &#123;<span class="attr">type</span>: <span class="string">&quot;text&quot;</span>, <span class="attr">x</span>: <span class="number">642</span>, <span class="attr">y</span>: <span class="number">172</span>, <span class="attr">width</span>: <span class="number">300</span>, <span class="attr">height</span>: <span class="number">30</span>, <span class="attr">text</span>: <span class="string">&quot;10000&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看出在StandardWindow中使用的是绝对坐标，而且可与贴图像素对应，因此只需要耐心的慢慢调整就能够得到一个不错的界面。</p><h3 id="与方块实体互动"><a href="#与方块实体互动" class="headerlink" title="与方块实体互动"></a>与方块实体互动</h3><p>此部分不是本教程的主要内容，因此将简要带过。</p><p>在IC中，注册方块实体的函数为<code>TileEntity.registerPrototype(blockID: number, customPrototype: TileEntityPrototype): void</code>，参数只有两个：<code>方块ID</code>和<code>方块实体原型</code>。</p><p>方块实体原型是一个JS对象，包含方块实体的数据和事件。要将创建的StandardWindow对象与方块实体绑定则需要在方块实体原型中设置<code>getGuiScreen</code>函数并返回界面对象。这样IC会自动为该界面对象创建相应的容器对象，你可以在方块实体原型的函数中使用<code>this.container</code>来获得容器对象并使用其提供的方法与界面交互。</p><h3 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h3><p>StandardWindow的可玩性远不止如此，你可以试着除去StandardWindow的默认控件，并从0开始自定义界面，或者在方块实体原型的<code>getGuiScreen</code>方法中编写逻辑以使在不同的情况下打开不同的界面。</p><p>示例为我去年3月份初次尝试UI时所写的会根据MC设置的UI档案切换StandardWindow的方块实体（<em>PS：图二的界面标题有偏移Bug，在之后的版本中已被修复</em>）。整个界面从开始构思到完成大概用了5天时间(大部分时间用在编写库上，但如今得益于WindowGroup，可以更快地完成该任务。</p><p><img src="/2021/08/14/UI-2/%E6%88%AA%E5%B1%8F_20200317_235539.jpg" alt="PocketUI"></p><p><img src="/2021/08/14/UI-2/%E6%88%AA%E5%B1%8F_20200318_010817.jpg" alt="ClassicUI"></p><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p><code>Window</code>是最基本的窗口，相较于StandardWindow，Window更为灵活，适合用作弹窗或者HUD。</p><p>在创建一个Window对象的时候，可以像StandardWindow那样传入一个包含Drawing和Elements等的对象。但能够突出Window特色的是location参数，你可以自定义Window的大小，在屏幕上的位置，内边距和可滑动窗口大小（<em>PS：Window内的<code>unit</code>为此Window宽度的千分之一）。</em></p><p>值得一提，内边距<code>padding</code>的会覆盖<code>x|y|width|height</code>的效果。</p><p>举个简单的空白窗口界面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一些常量</span></span><br><span class="line"><span class="keyword">const</span> GUI_SCALE = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> WIDTH = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> HEIGHT = UI.getScreenHeight();</span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line"><span class="keyword">let</span> testWindow = <span class="keyword">new</span> UI.Window(&#123;</span><br><span class="line">    <span class="attr">location</span>: &#123; <span class="comment">//此处运算是为方便居中</span></span><br><span class="line">        <span class="attr">x</span>: (WIDTH - <span class="number">300</span>) / <span class="number">2</span>,</span><br><span class="line">        <span class="attr">y</span>: (HEIGHT - <span class="number">225</span>) / <span class="number">2</span>,</span><br><span class="line">        <span class="attr">width</span>: <span class="number">300</span>,</span><br><span class="line">        <span class="attr">height</span>: <span class="number">225</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">drawing</span>: [ <span class="comment">//贴图是从拆原版包扒的XD</span></span><br><span class="line">        &#123;<span class="attr">type</span>: <span class="string">&quot;background&quot;</span>, <span class="attr">color</span>: android.graphics.Color.TRANSPARENT&#125;,</span><br><span class="line">        &#123;<span class="attr">type</span>: <span class="string">&quot;frame&quot;</span>, <span class="attr">bitmap</span>: <span class="string">&quot;background_panel&quot;</span>, <span class="attr">width</span>: <span class="number">1000</span>, <span class="attr">height</span>: <span class="number">750</span>, <span class="attr">scale</span>: GUI_SCALE&#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">elements</span>: &#123;</span><br><span class="line">        <span class="string">&quot;closeButton&quot;</span>: &#123;<span class="attr">type</span>: <span class="string">&quot;closeButton&quot;</span>, <span class="attr">x</span>: <span class="number">904</span>, <span class="attr">y</span>: <span class="number">26</span>, <span class="attr">bitmap</span>: <span class="string">&quot;close_button_default&quot;</span>, <span class="attr">bitmap2</span>: <span class="string">&quot;close_button_pressed&quot;</span>, <span class="attr">scale</span>: GUI_SCALE&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//一些常规设置</span></span><br><span class="line">testWindow.setCloseOnBackPressed(<span class="literal">true</span>);</span><br><span class="line">testWindow.setBlockingBackground(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2021/08/14/UI-2/1629399367119.png" alt="空白窗口"></p><h2 id="TabbedWindow"><a href="#TabbedWindow" class="headerlink" title="TabbedWindow"></a>TabbedWindow</h2><p><code>TabbedWindow</code>可用于创建标签式窗口，如原版的玩家背包一样，具有多个可切换的标签页。</p><p>TabbedWindow和StandardWindow一样，都继承自WindowGroup。在创建TabbedWindow对象时，所传入的参数与Window相同，与之不同的是TabbedWindow多了一些函数。</p><p>使用<code>new UI.TabbedWindow()</code>创建一个空白的TabbedWindow，效果如下<em>（PS：部分异形屏可能会被遮挡部分边界）</em>：</p><p><img src="/2021/08/14/UI-2/%E6%88%AA%E5%B1%8F_20210821_234419.jpg" alt="空白TabbedWindow"></p><p>简单地说明一下这个窗口，左上角的关闭按钮是一个索引值为0的<code>FakeTab</code>（<em>PS：FakeTab指没有对应标签页的标签</em>），标签页的上限为12个，即索引值的范围为<code>0-11</code>（左侧为<code>0-5</code>，右侧为<code>6-11</code>）。</p><p>要添加一个标签页可以使用<code>setTab(index: number, tabOverlay: ElementSet, tabContent: WindowContent, isAlwaysSelected?: boolean): void</code>函数，<code>index</code>即标签页的索引值，<code>tabOverlay</code>是标签的元素集（如关闭按钮），tabContent即为标签页展示的窗口内容，格式与之前介绍的基本无异。</p><p>因为setTab函数并不返回创建的Window对象，所以你需要用到<code>getWindowForTab(index: number): Window</code>来函数获取对应索引值的Window实例化对象，以完成对其的动态修改。</p><h2 id="WindowGroup"><a href="#WindowGroup" class="headerlink" title="WindowGroup"></a>WindowGroup</h2><p><code>WindowGroup</code>是StandardWindow和TabbedWindow的父类，其方法基本上都可以在StandardWindow和TabbedWindow中使用。</p><p>WindowGroup诞生的目的是为了能够将复杂的界面模块化，以便提高代码的复用率并降低调试难度，使开发效率提高，最为典型的例子就是IC中的工作台界面（<em>PS：此处不谈其交互逻辑，仅谈其界面</em>）。</p><p><img src="/2021/08/14/UI-2/1629564243594.png" alt="工作台界面"></p><p>该界面由三部分组成，分别为<code>Main</code>·，<code>Slots</code>和<code>Grid</code>，对应下图中的青色，粉色和黄色部分：</p><p><img src="/2021/08/14/UI-2/1629565268865.png" alt="工作台页面结构"></p><p>阅读<code>workbench.js</code>中工作台界面部分的代码，可以看出该三部分都是先定义WindowContent的JSON描述，然后一一创建Window对象，并使用<code>addWindowInstance(name: string, window: Window): void</code>函数将Window对象添加到WindowGroup对象并声明其对应的名称ID。你也可以直接使用<code>addWindow(name: string, content: WindowContent): Window</code>函数向WindowGroup添加窗口。</p><hr><p>至此，关于UI界面的内容就基本上介绍完毕，当然全部内容不止这些，你需要认真地查阅官方文档以及去学习他人的优秀作品。<br>另外，虽然本教程对于UI与容器的互动只是简单地带过，但此部分内容是相当重要的，应当注重学习（<em>PS：谁让你们当时评论不提容器和方块实体呢XD</em>）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;注意：本教程仅为简单介绍UI的窗口，不会涉及详细的函数。如果想要了解更多请阅读官方文档。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上期教程中我们简要介绍了ICMod的UI构成与基本控件，接下来将详细介绍控件用法以及如何组成一个“精美”的界面。&lt;/p&gt;
&lt;h2 id</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UI PART1</title>
    <link href="https://weifeng233.github.io/2021/06/26/UI-1/"/>
    <id>https://weifeng233.github.io/2021/06/26/UI-1/</id>
    <published>2021-06-26T06:57:07.355Z</published>
    <updated>2021-06-26T07:03:05.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Try hard.</p><p>-Zheka Smirnov</p></blockquote><p><em>本文的部分名词与描述或许与别处有出入以至于错误，欢迎在评论区指出</em></p><p>相较于原版MC，IC的UI系统并不有多复杂，可简单地用下图概括<br><img src="/2021/06/26/UI-1/icmod_ui.png" alt="ICMod UI"></p><p>尽管这张图看似过于简略，但事实的确如此。快速掌握UI的基本控件等内容并不困难，但难点是如何用它们拼凑出美观且实用的用户界面</p><p><em>PS：本文不会讲到每一个控件及其函数，更详细的内容可见<a href="https://docs.mineprogramming.org/modules/ui.html">官方文档</a></em></p><p>首先在IC中，用户界面的控件的大小和单位都是使用同一的unit单位，1unit = 窗口宽度/1000</p><h2 id="UI资源"><a href="#UI资源" class="headerlink" title="UI资源"></a>UI资源</h2><p>UI所使用到的贴图存放于构筑文件(build.config)所指定的gui类型的资源文件夹，在使用时只需要输入文件名即可(不包含后缀与文件夹)</p><p>除此之外，还有：</p><p>color: 颜色，即Android的Color类，可使用android.graphics.Color.rgb(r, g, b)等自定义颜色</p><p>font: 字体，包含三个属性，{size: 文本大小, color: 文本颜色, shadow: 文本阴影}，其中文本阴影为范围[0, 1]的浮点数</p><p>frame: 边框，一般使用大小为16x16的贴图，在使用时会被自动拉伸至所需大小</p><h2 id="Drawing"><a href="#Drawing" class="headerlink" title="Drawing"></a>Drawing</h2><p>Drawing，顾名思义就是在界面中进行绘制，在UI的描述对象中Drawing为一个包含绘制指令的数组</p><p><em>描述对象：用于设定UI以及在UI打开时对其进行动态修改</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="attr">drawing</span>: [</span><br><span class="line">    &#123;<span class="comment">/*指令1*/</span>&#125;,</span><br><span class="line">    &#123;<span class="comment">/*指令2*/</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>常用标准指令如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;background&quot;</span>, <span class="attr">color</span>: 颜色&#125; <span class="comment">//填充背景颜色</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;bitmap&quot;</span>, <span class="attr">bitmap</span>: 贴图, <span class="attr">x</span>: <span class="built_in">Number</span>, <span class="attr">y</span>: <span class="built_in">Number</span>, <span class="attr">width</span>: <span class="built_in">Number</span>, <span class="attr">height</span>: <span class="built_in">Number</span>, <span class="attr">scale</span>: <span class="built_in">Number</span>&#125; <span class="comment">//绘制贴图，scale - 贴图像素和unit的缩放比例，默认1像素=1unit</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;frame&quot;</span>, <span class="attr">x</span>: <span class="built_in">Number</span>, <span class="attr">y</span>: <span class="built_in">Number</span>, <span class="attr">width</span>: <span class="built_in">Number</span>, <span class="attr">height</span>: <span class="built_in">Number</span>, <span class="attr">bitmap</span>: 贴图, <span class="attr">bg</span>: 颜色, <span class="attr">scale</span>: <span class="built_in">Number</span>&#125; <span class="comment">//绘制边框，bg - 边框背景颜色</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;text&quot;</span>, <span class="attr">text</span>: <span class="built_in">String</span>, <span class="attr">x</span>: <span class="built_in">Number</span>, <span class="attr">y</span>: <span class="built_in">Number</span>, <span class="attr">font</span>: 字体&#125; <span class="comment">//绘制文本</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;line&quot;</span>, <span class="attr">x1</span>: <span class="built_in">Number</span>, <span class="attr">y1</span>: <span class="built_in">Number</span>, <span class="attr">x2</span>: <span class="built_in">Number</span>, <span class="attr">y2</span>: <span class="built_in">Number</span>, <span class="attr">width</span>: <span class="built_in">Number</span>, <span class="attr">height</span>: <span class="built_in">Number</span>, <span class="attr">color</span>: 颜色&#125; <span class="comment">//绘制直线，width - 直线粗细</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;custom&quot;</span>, <span class="attr">onDraw</span>: <span class="built_in">Function</span>(canvas, scale)&#125; <span class="comment">//自定义绘制，onDraw - 在绘制时调用的函数，传参包括当前绘制的Canvas对象和scale数值，无返回值</span></span><br></pre></td></tr></table></figure><p><em>PS：custom drawing的canvas为Android的Canvas类</em></p><h2 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h2><p>Elements，指UI中的控件，与Drawing不同的是Elements在描述对象里为一个包含各控件的对象</p><p>Elements中的每一个控件都有其唯一且独特的名称，即每一个对象都有其唯一的建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="attr">elements</span>: &#123;</span><br><span class="line">    <span class="string">&quot;名称1&quot;</span>: &#123;<span class="comment">/*元素1*/</span>&#125;,</span><br><span class="line">    <span class="string">&quot;名称2&quot;</span>: &#123;<span class="comment">/*元素2*/</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个元素都有以下基本属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;type&quot;</span>, <span class="comment">//元素类型</span></span><br><span class="line">    <span class="attr">x</span>: number, <span class="comment">//x坐标</span></span><br><span class="line">    <span class="attr">y</span>: number, <span class="comment">//y坐标</span></span><br><span class="line">    <span class="attr">z</span>: number, <span class="comment">//z坐标，用于区分控件层次防止混乱重叠</span></span><br><span class="line">    <span class="attr">clicker</span>: Click对象 <span class="comment">//控件点击对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处控件点击对象指一个包含短时点击事件和长时点击事件函数的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">onClick</span>: <span class="function"><span class="keyword">function</span>(<span class="params">position, container, tileEntity, <span class="built_in">window</span>, canvas, scale</span>) </span>&#123;</span><br><span class="line">          <span class="comment">//container - 界面打开的容器</span></span><br><span class="line">          <span class="comment">//tileEntity - 如果界面是为某方块实体打开的，它就会传出它，否则传出null</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">onLongClick</span>: <span class="function"><span class="keyword">function</span>(<span class="params">position, container, tileEntity, <span class="built_in">window</span>, canvas, scale</span>) </span>&#123;</span><br><span class="line">          <span class="comment">//container - 界面打开的容器</span></span><br><span class="line">          <span class="comment">//tileEntity - 如果界面是为某方块实体打开的，它就会传出它，否则传出null</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，常用元素如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;slot&quot;</span>, <span class="attr">x</span>: <span class="built_in">Number</span>, <span class="attr">y</span>: <span class="built_in">Number</span>, <span class="attr">size</span>: <span class="built_in">Number</span>, <span class="attr">visual</span>: <span class="built_in">Boolean</span>/<span class="built_in">Function</span>(id, data, count), <span class="attr">bitmap</span>: 贴图, <span class="attr">clicker</span>: Click对象&#125; <span class="comment">//物品格，visual - 是否可选中</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;invSlot&quot;</span>, <span class="attr">x</span>: <span class="built_in">Number</span>, <span class="attr">y</span>: <span class="built_in">Number</span>, <span class="attr">size</span>: <span class="built_in">Number</span>, <span class="attr">index</span>: <span class="built_in">Number</span>, <span class="attr">bitmap</span>: 贴图&#125; <span class="comment">//背包物品格，index - 对应背包物品格id</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;button&quot;</span>, <span class="attr">x</span>: <span class="built_in">Number</span>, <span class="attr">y</span>: <span class="built_in">Number</span>, <span class="attr">bitmap</span>: 贴图, <span class="attr">bitmap2</span>: 贴图, <span class="attr">scale</span>: <span class="built_in">Number</span>, <span class="attr">clicker</span>: Click对象&#125; <span class="comment">//按钮，bitmap2 - 按下时贴图，button的Click对象与其他的稍有不同，其点击事件函数的参数为(container, tileEntity, position, window, canvas, scale)</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;closeButton&quot;</span>, <span class="attr">x</span>: <span class="built_in">Number</span>, <span class="attr">y</span>: <span class="built_in">Number</span>, <span class="attr">global</span>: <span class="built_in">Boolean</span>, <span class="attr">bitmap</span>: 贴图, <span class="attr">bitmap2</span>: 贴图, <span class="attr">scale</span>: <span class="built_in">Number</span>&#125; <span class="comment">//关闭窗口按钮，global - 为真时将关闭窗口组内所有窗口，否则只关闭所在单窗口，详见下文</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;scale&quot;</span>, <span class="attr">x</span>: <span class="built_in">Number</span>, <span class="attr">y</span>: <span class="built_in">Number</span>, <span class="attr">direction</span>: <span class="built_in">Number</span>, <span class="attr">bitmap</span>: 贴图, <span class="attr">scale</span>: <span class="built_in">Number</span>, <span class="attr">invert</span>: <span class="built_in">Number</span>, <span class="attr">overlay</span>: 贴图, <span class="attr">overlayScale</span>: <span class="built_in">Number</span>, <span class="attr">overlayOffset</span>: &#123;<span class="attr">x</span>: <span class="built_in">Number</span>, <span class="attr">y</span>: <span class="built_in">Number</span>&#125;&#125; <span class="comment">//刻度表或进度栏，direction - 朝向，详见下文，invert - 是否翻转贴图，overlay - 重叠在scale上的贴图，Scale和Offset分别为其缩放比例和相对scale元素的位置</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;text&quot;</span>, <span class="attr">x</span>: <span class="built_in">Number</span>, <span class="attr">y</span>: <span class="built_in">Number</span>, <span class="attr">width</span>: <span class="built_in">Number</span>, <span class="attr">height</span>: <span class="built_in">Number</span>, <span class="attr">text</span>: <span class="built_in">String</span>, <span class="attr">font</span>: 字体&#125; <span class="comment">//文本</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;fps&quot;</span>, <span class="attr">interpolate</span>: <span class="built_in">Boolean</span>, <span class="attr">period</span>: <span class="built_in">Number</span>, <span class="attr">font</span>: 字体, <span class="attr">multiline</span>: <span class="built_in">Boolean</span>, <span class="attr">format</span>: <span class="built_in">Boolean</span>, <span class="attr">maxCharsPerLine</span>: <span class="built_in">Number</span>&#125;<span class="comment">//FPS文本</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;image&quot;</span>, <span class="attr">x</span>: <span class="built_in">Number</span>, <span class="attr">y</span>: <span class="built_in">Number</span>, <span class="attr">bitmap</span>: 贴图, <span class="attr">scale</span>: <span class="built_in">Number</span>, <span class="attr">overlay</span>: 贴图, <span class="attr">overlayScale</span>: <span class="built_in">Number</span>, <span class="attr">overlayOffset</span>: &#123;<span class="attr">x</span>: <span class="built_in">Number</span>, <span class="attr">y</span>: <span class="built_in">Number</span>&#125;, <span class="attr">clicker</span>: Click对象&#125; <span class="comment">//贴图</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">&quot;custom&quot;</span>, <span class="attr">onSetup</span>: <span class="built_in">Function</span>(element: Element), <span class="attr">onDraw</span>: <span class="built_in">Function</span>(element, canvas, scale), <span class="attr">onTouchReleased</span>: <span class="built_in">Function</span>(element), <span class="attr">onBindingUpdated</span>: <span class="built_in">Function</span>(element, name, value), <span class="attr">onReset</span>: <span class="built_in">Function</span>(element), <span class="attr">onRelease</span>: <span class="built_in">Function</span>(element), <span class="attr">onContainerInit</span>: <span class="built_in">Function</span>(element, container, elementName)&#125;<span class="comment">//自定义元素，各函数均无返回值</span></span><br></pre></td></tr></table></figure><p>除以上元素之外，还有Scroll，Switch，Tab等元素未被提及，但用法大同小异，建议自行按照官方文档进行尝试，这样才是最有效率的学习方法</p><p><em>direction参数:</em></p><p><em>0 - 朝右<br>1 - 朝上<br>2 - 朝左<br>3 - 朝下</em></p><hr><p>在简要介绍完Drawing和Elments后，在介绍重头戏Window之前先来补充一点其他内容</p><h3 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h3><p>用于修改Window的一些默认参数，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">params: &#123;</span><br><span class="line">     <span class="attr">slot</span>: <span class="string">&quot;格子贴图&quot;</span>,</span><br><span class="line">     <span class="attr">invSlot</span>: <span class="string">&quot;背包格子贴图&quot;</span>,</span><br><span class="line">     <span class="attr">frame</span>: <span class="string">&quot;平面边框贴图&quot;</span>,</span><br><span class="line">     <span class="attr">selection</span>: <span class="string">&quot;格子高亮贴图&quot;</span>,</span><br><span class="line">     <span class="attr">closeButton</span>: <span class="string">&quot;关闭按钮贴图&quot;</span>,</span><br><span class="line">     <span class="attr">closeButton2</span>: <span class="string">&quot;按下的关闭按钮贴图&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UI-getContext"><a href="#UI-getContext" class="headerlink" title="UI.getContext()"></a>UI.getContext()</h3><p>该函数用于获取Android UI线程的上下文，以便调用Android API来操控界面控件</p><h3 id="UI-getScreenHeight"><a href="#UI-getScreenHeight" class="headerlink" title="UI.getScreenHeight()"></a>UI.getScreenHeight()</h3><p>获取以unit为单位的屏幕高度，与之相同的还有UI.getScreenRelativeHeight()</p><h3 id="ElementSet"><a href="#ElementSet" class="headerlink" title="ElementSet"></a>ElementSet</h3><p>元素集合</p><h3 id="WindowLocation"><a href="#WindowLocation" class="headerlink" title="WindowLocation"></a>WindowLocation</h3><p>窗口位置及大小，使用unit作为单位，详细参数见官方文档</p><h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><p>窗口风格，有CLASSIC和DEFAULT两种</p><h3 id="Slot，FullSlot"><a href="#Slot，FullSlot" class="headerlink" title="Slot，FullSlot"></a>Slot，FullSlot</h3><p>窗口中的物品格对象，Slot包含物品的id、特殊值、数量和额外数据，FullSlot则在其基础上添加了如drop、set等方法</p><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p>在官方文档中，窗口(Window)有如下几个类：</p><ul><li>StandardWindow</li><li>StandartWindow</li><li>TabbedWindow</li><li>Window</li><li>WindowGroup</li></ul><p>在这里将暂先略讲StandartWindow，Window和WindowGroup</p><h3 id="StandartWindow"><a href="#StandartWindow" class="headerlink" title="StandartWindow"></a>StandartWindow</h3><p>定义为UI.StandartWindow类，以一个描述对象定义界面</p><p>描述对象格式(摘自BigFish和方法放寒假翻译的官方Wiki第8-2节)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">standart</span>: &#123;<span class="comment">//这种类型的界面标准参数在这里写入，它们允许你快速地设置基本的元素，例如标题、背景和背包</span></span><br><span class="line">          <span class="comment">//如果你想定义标准的元素，但是又不想改变默认值，那么就单写上值 - standart: true，例如inventory: &#123;standart: true&#125;</span></span><br><span class="line">          <span class="attr">header</span>: &#123;<span class="comment">//设定你是否需要一个标头，包含一个标题和和一个关闭按钮</span></span><br><span class="line">               <span class="attr">text</span>: &#123;<span class="comment">//必需的参数，如果你定义了标头</span></span><br><span class="line">                    <span class="attr">text</span>: <span class="string">&quot;标题文本&quot;</span>, <span class="comment">//文本内容，必需的参数</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">Font</span>: &#123;...&#125;, <span class="comment">//文本字体，如果你想改变默认值，就请定义它</span></span><br><span class="line">               <span class="attr">color</span>: 颜色, <span class="comment">//只有当你想改变标题颜色的时候才需要</span></span><br><span class="line">               <span class="attr">frame</span>: <span class="string">&quot;边框文本&quot;</span>, <span class="comment">//只有当你想改变标头边框的时候才需要</span></span><br><span class="line">               <span class="attr">width</span>: <span class="number">80</span>, <span class="comment">//表头的高度，以unit为单位</span></span><br><span class="line">               <span class="attr">hideButton</span>: <span class="literal">true</span>, <span class="comment">//定义并设置为true则移除关闭按钮</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">inventory</span>: &#123;<span class="comment">//要想定义标准背包，请使用inventory: &#123;standart: true&#125;</span></span><br><span class="line">               <span class="attr">width</span>: <span class="number">300</span>, <span class="comment">//背包窗口的宽度</span></span><br><span class="line">               <span class="attr">padding</span>: <span class="number">20</span>, <span class="comment">//背包窗口的内边距</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">background</span>: &#123;<span class="comment">//要定义一个默认背景，请使用background: &#123;standart: true&#125;</span></span><br><span class="line">               <span class="attr">color</span>: 颜色, <span class="comment">//如果你想改变背景的颜色就定义它</span></span><br><span class="line">               <span class="attr">bitmap</span>: <span class="string">&quot;背景图片&quot;</span>, <span class="comment">//如果你想添加一个背景图片就定义它</span></span><br><span class="line">               <span class="attr">frame</span>: <span class="string">&quot;边框贴图&quot;</span> <span class="comment">//如果你想添加一个边框就定义它</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">minHeight</span>: <span class="number">650</span>, <span class="comment">//如果以unit为单位的窗口高度小于这个参数的值，那么窗口将自动转变为滚动窗口，以此来保证它的内部大小的高度为minHeight units</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">params</span>: &#123;</span><br><span class="line">          <span class="comment">//自定义（改变默认材质）</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">drawing</span>: [<span class="comment">/*背景渲染指令*/</span>],</span><br><span class="line">     <span class="attr">elements</span>: &#123;<span class="comment">/*元素的描述*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StandartWindow是适用性最高的窗口，在多人游戏中表现优于Window，但尽管如此绝对布局仍是其一大缺点，在实际使用时需要考虑到不同的屏幕尺寸会造成的控件偏移。因此，<em><strong>尽量将控件放置在屏幕内部区域</strong></em></p><h3 id="Window-1"><a href="#Window-1" class="headerlink" title="Window"></a>Window</h3><p>相较于StandartWindow，Window的优点在于其灵活性，与默认为方块互动界面的StandartWindow不同，Window可以通过修改WindowLocation来显示在游戏界面上的任意位置，且可以通过适当修改padding值来尽可能避免控件偏移。</p><p><em>Window默认没有关闭按钮和玩家背包栏，在使用时需要按需自行添加</em></p><h3 id="WindowGroup"><a href="#WindowGroup" class="headerlink" title="WindowGroup"></a>WindowGroup</h3><p>StandartWindow和Window都是单个窗口，如果需要复杂的界面那么用多个窗口组合无疑是最最好的选择，将一个复杂窗口分为多个小窗口也可以提高调试效率。</p><p>WindowGroup的主要作用就是将多个Window整合在一起，将其组合布局在一起，例如现在的工作台界面就是一个包含3个Window的WindowGroup</p><h3 id="Hierarchic-UI库"><a href="#Hierarchic-UI库" class="headerlink" title="Hierarchic UI库"></a>Hierarchic UI库</h3><p><a href="https://github.com/zheka2304/innercore-hierarchic-ui">HierarchicUI</a>由Zheka开发，用于以json来定义分层式的UI，可以方便的创建绝对布局和线性布局，届时json会被解析为WindowGroup</p><p>此外，该库还可以定义视图布局并且对于一个视图可以灵活地嵌入到其他界面，并且基于它创建继承其全部属性的子视图，无疑让WindowGroup展示美观的复杂界面更加容易。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Try hard.&lt;/p&gt;
&lt;p&gt;-Zheka Smirnov&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;本文的部分名词与描述或许与别处有出入以至于错误，欢迎在评论区指出&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;相较于原版MC，IC的UI系统并不有多复杂，</summary>
      
    
    
    
    
  </entry>
  
</feed>
