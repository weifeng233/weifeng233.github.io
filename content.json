{"meta":{"title":"微风的博客","subtitle":"","description":"","author":"SugarBreeze","url":"https://weifeng233.github.io","root":"/"},"pages":[],"posts":[{"title":"内核课程 - 0：模组结构、编程语言和库","slug":"0","date":"2022-07-17T11:00:33.475Z","updated":"2022-07-17T13:19:56.560Z","comments":true,"path":"2022/07/17/0/","link":"","permalink":"https://weifeng233.github.io/2022/07/17/0/","excerpt":"","text":"本文是ICMod开发教程的第0章，主要内容为模组结构，编程语言和库，适用版本为InnerCore 2.x（在玩家社区中通常以Horizon指代），注意发布时间。 模组结构ICMod是以文件夹的形式放在对应InnerCore包下的innercore/mods文件夹，在发布时以ZIP格式的压缩包并通常使用.icmod作为文件后缀。 在ICMod中，许多文件的相对位置和名称都可以在build.config中指定，除了以下文件： 模组文件夹 │ build.config - 模组的结构信息和编译信息 │ config.json - 模组的配置文件 │ config.info.json - 模组配置文件的描述文件，包括本地化(翻译)和配置属性 │ mod.info - 模组信息 │ mod_icon.png - 模组图标 | └─.dex - 已编译的模组源码 先简单说一下mod.info的内容，包含以下信息： 123456&#123; &quot;name&quot;: &quot;模组名称&quot;, &quot;author&quot;: &quot;模组作者&quot;, &quot;version&quot;: &quot;模组版本&quot;, &quot;description&quot;: &quot;模组简介&quot;&#125; 至于配置文件以后会单独讲解，这里先按下不表。 build.config中的内容可由模组作者自行修改，这里举个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//EnergyTech(能源科技) - V4.0.2//该build.config由官方的toolchain自动生成，在较新的模组中是相当典型的例子&#123; &quot;defaultConfig&quot;:&#123; //主要参数 &quot;readme&quot;:&quot;this build config is generated automatically by mod development toolchain&quot;, &quot;api&quot;:&quot;CoreEngine&quot;, //指定API，还可以选择 AdaptedScript 但缺少了很多拓展功能，更贴近底层(Java层) &quot;buildType&quot;:&quot;develop&quot; //编译类型，通常建议在发布时更改为 release &#125;, &quot;compile&quot;:[ //可执行文件，应 launcher 和 mod 源码类型各至少有一个 &#123; &quot;path&quot;:&quot;source/main.js&quot;, &quot;sourceType&quot;:&quot;mod&quot; &#125;, &#123; &quot;path&quot;:&quot;source/launcher.js&quot;, &quot;sourceType&quot;:&quot;launcher&quot; &#125;, &#123; &quot;path&quot;:&quot;library/BlockEngine.js&quot;, &quot;sourceType&quot;:&quot;library&quot; &#125;, &#123; &quot;path&quot;:&quot;library/ChargeItem.js&quot;, &quot;sourceType&quot;:&quot;library&quot; &#125;, &#123; &quot;path&quot;:&quot;library/SoundLib.js&quot;, &quot;sourceType&quot;:&quot;library&quot; &#125; ], &quot;resources&quot;:[ //资源文件，如模组贴图和GUI贴图 &#123; &quot;path&quot;:&quot;resources/res&quot;, &quot;resourceType&quot;:&quot;resource&quot; &#125;, &#123; &quot;path&quot;:&quot;gui/gui&quot;, &quot;resourceType&quot;:&quot;gui&quot; &#125; ], &quot;nativeDirs&quot;:[], //原生模组模块文件夹 &quot;javaDirs&quot;:[], //Java模块文件夹 &quot;buildDirs&quot;:[] //可行性构建文件夹&#125; 可以看到在compile中指定了很多js文件，其中mod类型即为模组的主要代码；launcher类型的文件只能有一个，用于决定模组是否启动；library类型为库，除了像这样一个一个添加之外还可以在defaultConfig中指定libraryDir，这样将会将该目录下的所有文件当作库并尝试执行；除了以上三种之外还有另外两种类型，分别是在模组加载之前执行的preloader和仅能在其他类型中使用runCustomSource方法调用的custom类型，值得注意的是这两种类型除了部分常量之外无法使用IC提供的API（虽然可以通过rhino调用，但不建议也没必要）。 resources用于指定资源文件，没什么好说的，只需要注意GUI纹理资源需要单独指定。 nativeDirs和javaDirs的用法见下文，此处单讲buildDirs。buildDirs允许开发者将可执行文件分散成多个文件以方便开发，举个简单的例子： 123456&quot;buildDirs&quot;:[ &#123; &quot;dir&quot;:&quot;source/dev/&quot;, &quot;targetSource&quot;:&quot;source/main.js&quot; &#125; ] dir指定了可执行文件存放的文件夹，此文件夹内必须有一个includes文件逐行记录了各个文件的相对位置，InnerCore将会按顺序合并为一个文件并覆写到targetSource指定的文件中。此过程并非简单的文本拼接，不可将完整的代码文件随意拆分为两个文件，否则可能会导致错误。 编程语言ICMod主要使用的编程语言是JavaScript，使用Rhino作为引擎，支持ES5和极少一部分ES6特性和调用Java，主要劣势为运行速度相当慢，与主流JS引擎相差百倍，但对于大多数情况都是够用的。这里推荐几个JS学习资源： JavaScript编程精解，相当不错的入门书籍。 JavaScript | MDN，权威且全面，页面内还附有其他资源链接。 Rhino ES2015 Support，关于Rhino引擎对于ES6特性的实际支持情况。 但JS有一个特点，就是它是弱类型语言，对于一些更习惯强类型语言的开发者可以选择TypeScript，在官方的toolchain中就支持使用TS编写模组并在之后转译为JS供InnerCore使用。同样的，推荐一些教程： 官方文档，权威，最新。 TypeScript入门教程，菜鸟教程，中文，方便阅读但不是最新版本。 除了使用JS/TS，ICMod还允许使用Java或者Native模块来拓展API，需要有Java和C/C++知识并了解一些Android SDK/NDK开发，此处不再提供相关资源链接，但应注意始终以对应版本的官方文档为准，善用搜索引擎查找问题以及在提问前明确问题。 库库用于拓展API，可以是单个的JS文件也可以是以模块形式的DEX文件或者SO文件又或者是单独的模组，关于JS格式的库在模组中的存放位置已在前文叙述，这里仅将如何编写内容和使用。 JS库在库的开头，需要使用LIBRARY方法来描述库的基本信息： 123456789LIBRARY(&#123; name: &quot;名称&quot;, // 库的唯一识别名称，不应再修改 version: 版本, // 库的版本，必须为大于0的整数，更高版本的库会覆盖更低版本的 shared: false, // 如果为 true 则库将作为全局API，即所有使用该库的模组共用相同的API对象，否则仅作用于单个模组 api: &quot;CoreEngine&quot;, // 库使用的API dependencies: [&quot;name1:version1&quot;, //... ] //在库中导入的依赖库列表&#125;); 要导出库中的API，使用EXPORT方法： 12345678910111213141516EXPORT(&quot;API对象名称&quot;, API对象);//EXPORT还支持指定导出API对象的最低库版本//如加入在一个库中存在以下三条EXPORTEXPORT(&quot;print&quot;, function () &#123; alert(&quot;new version print&quot;); &#125;);EXPORT(&quot;print:3&quot;, function () &#123; alert(&quot;older print&quot;); &#125;);EXPORT(&quot;print:1&quot;, function () &#123; alert(&quot;first version print&quot;); &#125;);//一般情况下，默认使用第一个print方法//但当使用者指定的库版本＞1且≤3时，将使用第二个print方法//若指定的库版本为1，则使用第三个print方法 在模组中导入库时，使用IMPORT方法： 123IMPORT(&quot;库名称&quot;); //导入整个库IMPORT(&quot;库名称&quot;, &quot;API对象名称&quot;); //导入特定的APIIMPORT(&quot;库名称:库版本&quot;); //指定库版本 原生模块和Java模块在nativeDirs和javaDirs中与buildDirs相似，只需要指定path即可，如下： 12345&quot;nativeDirs&quot;: [ &#123; &quot;path&quot;: &quot;source/native/&quot; &#125;] 在指定的目录下必须有一个manifest文件来指定相关信息，对于原生模块，格式是这样的： 123456789101112&#123; &quot;shared&quot;: &#123; &quot;name&quot;: &quot;name&quot;, //此名称为编译后生成的so文件名称，如 libname.so &quot;include&quot;: [ //编译时包含的源码文件夹，可选 &quot;shared_headers&quot; ] &#125;, &quot;depends&quot;: [ //在编译的时候依赖的内置库，可选 &quot;innercore&quot;, &quot;nativejs&quot; ]&#125; 同时需要一个main.cpp文件包含基本的代码，你可以在官方的toolchain中使用NDK对其进行编译，也可以在Horzion中使用gcc编译。 对于Java模块，manifest文件的格式是这样的： 12345678//Toolchain示例模组&#123; &quot;source-dirs&quot;: [&quot;src&quot;], //源码文件夹 &quot;library-dirs&quot;: [&quot;lib&quot;], //JAR库文件夹 &quot;verbose&quot;: true, //是否开启verbose输出 &quot;options&quot;: [], //verbose选项 &quot;boot-classes&quot;: [&quot;com.sample_mod.sample_package.Boot&quot;] //要执行的类&#125; Java编译可以在Toolchain中使用JDK完成，也可以在Horizon中完成。 要使用原生模块和Java模块，InnerCore提供了以下方法： 123IMPORT_NATIVE(name, target); //获取原生模块方法并注入到指定对象中WRAP_JAVA(name); //获取Java对象并返回WRAP_NATIVE(name); //获取原生模块并返回 在Java模块中，得益于Rhino，所定义的Java类都可直接使用，而在原生模块中，需要nativejs.h头文件提供的方法才能创建可供JS使用的JS模块： 12345JS_MODULE_VERSION(模块名称, 1); //指定模块名称和版本JS_EXPORT(模块名称, 方法名称, &quot;I()&quot;, (JNIEnv* env) &#123; //导出一个返回值为整型无参数的方法 //... NativeJS::wrapIntegerResult(0); //返回 0&#125;); 非常感谢您能读完本篇教程，因本人能力不足，对于教程中的疏漏与错误望各位指出斧正。 本系列教程将按照俄国社区先前编写的一份课程表格(谷歌文档)进行，下一篇将会简要讲解物品。","categories":[],"tags":[]},{"title":"关于InnerCore包","slug":"关于InnerCore包","date":"2022-04-07T12:42:10.438Z","updated":"2022-04-07T16:45:12.887Z","comments":true,"path":"2022/04/07/关于InnerCore包/","link":"","permalink":"https://weifeng233.github.io/2022/04/07/%E5%85%B3%E4%BA%8EInnerCore%E5%8C%85/","excerpt":"","text":"注：本文翻译自官方文档，UI文本与InnerCore b113一致 这个包有什么？在InnerCore包的主菜单中有以下五个按钮： 游玩 - 用于开始游戏的按钮 原生模组 - 位于屏幕右侧用于打开原生模组菜单的按钮 模组管理器 - 此游戏的模组管理器 下载模组 - 允许你任意下载模组 我的模组 - 用于管理你已安装的模组 我的模组集 - 管理已安装的由开发者创作的现成整合包 模组更新 - 可更新的模组列表 访问网站 - 打开此游戏的一个成熟的模组网站 首选项和链接 首选项 禁用加载屏幕 - 显示正在加载模组的页面，在某些设备上禁用后可能会提升加载速度 开发人员模式 - 对模组开发者相当实用，包括在支持的模组中启用调试模式 使用旧版工作台 UI - 如果原版工作台对于一些配方无效，则可以恢复至之前的工作台UI 基于时间限制更新 - 开启后，模组在一游戏刻中产生的最大更新数量将被限制，否则将无限制，简单说就是模组每刻最多能调用的次数 每刻最大的更新次数 - 调整_更新次数限制_ 建立高级线程优先级 - 更高的优先级可使TPS更稳定（这意味着更稳定的操作和响应时间），但可能会冻结线程和降低帧率 服务端线程优先级 - 调整_线程优先级_ FPS阈值 - 当FPS低于该阈值时，将会降低服务端线程优先级 更多的线程数 - 额外的更新线程，对于性能较强的设备上可以提升负载性能，注意，该功能仍处于实验性阶段，可能会不稳定 更多的线程优先级 - 调整_额外线程的优先级_ 自动保存 - 允许你在游戏意外停止运行时保存存档和模组数据 自动保存优先级 - 两次保存之间间隔的秒数 启用套接字服务器 - 允许局域网内的玩家通过Socket协议进入你的世界 优先化本地网络协议 - 使用原生协议（默认情况下Socket协议有更高的优先级） （开发人员用）强制本地化本地协议 - 使用原生协议进行本地客户端与服务端的通信，该选项仅用于调试模组，切勿在正常游戏中使用！ (For developers)Dump additional information - 在世界加载期间导出与开发相关的信息，dump文件会与log放在相同文件夹 指南和链接 - 包含指南和社交网络链接的标签页 开发小组 - 开发者，测试员和模组开发者的贡献名单 关于","categories":[],"tags":[]},{"title":"CraftTweaker使用教程","slug":"CraftTweaker","date":"2022-01-15T06:40:12.563Z","updated":"2022-01-22T15:50:15.431Z","comments":true,"path":"2022/01/15/CraftTweaker/","link":"","permalink":"https://weifeng233.github.io/2022/01/15/CraftTweaker/","excerpt":"","text":"CraftTweaker（以下简称CrT）是由麦穗开发与同名的Java版模组有类似功能的魔改类模组。 本文将简要介绍如何编写和使用CrT脚本。 加载脚本CrT在运行时会读取当前加载模组集对应文件夹下script文件夹内的所有后缀为js的文件并为每一个脚本创建独立的沙盒以独立运行。 你可以在包对应文件夹内的innercore/preferences.json文件中的pack_selected键对应的属性得知当前所加载的模组集对应的路径，无论如何，script文件夹都应与mods文件夹在同一级文件夹内。 123//可能放置脚本的文件夹//pack_name/innercore/script///mod_pack_name/script/ 编写脚本编程语言与ICMod一样，CrT脚本使用Rhino引擎运行，语言为JavaScript，支持ES5与部分ES6特性。 预置函数CrT为CrT脚本提供了两个预置函数，分别为$和require，下文将分别介绍这两个函数的详细用法： $$用于创建ItemStack对象，是CrT和ICMod通用的物品格式。 格式：123456789101112131415161718192021// $ 的格式如下$(&quot;type:name:data*count&quot;);/* type - ID的类型，分为方块 - block 和 物品 - item * name - ID的名称，如bedrock, stick等 * data - 物品的特殊值/损坏值（可选） * count - 物品的数量（可选） *///举例：$(&quot;block:bedrock&quot;); //基岩$(&quot;block:wool:6*32&quot;); //半组粉红色羊毛$(&quot;item:stick*64&quot;); //一组木棍$(&quot;item:diamond_shovel:1560&quot;); //一把快要坏掉的钻石锹// ItemStack 对象包含的值如下&#123; index: string, //索引，即ID的名称 id: number, //物品的数字ID data: number, //物品的特殊值/损坏值 count: number, //物品的数量 _condition: function, //合成条件，物品在工作台中参与合成时执行，详见下文&#125; 用法：12345678910111213141516171819202122232425262728293031323334// ItemStack 对象有以下方法toItem(); //返回 toItem 对象，详见下文toBlock(); //返回 toBlock 对象，详见下文onUse(state); // state - function 类型，为物品注册使用回调（点击方块时触发），返回该 ItemStack 自身getMaxStack(); //返回 number 类型，该物品的最大堆叠数量only(state); // state - function 类型，合成条件，详见下文，返回该 ItemStack 自身transformDamage(damage); // damage - number 类型，设置物品在合成时增加的损坏值（或指消耗的耐久值），仅调用该方法而不传入参数将设置为1，返回该 ItemStack 自身reuse(); //设置该物品在合成中不会消耗，返回该 ItemStack 自身// toItem 对象有以下方法getMaxDamage(); //返回 number 类型，该物品的最大特殊值/损坏值isTool(); //返回 boolean 类型，该物品是否为工具（包含武器，装备等）// toBlock 对象有以下方法onPlace(state); // state - function 类型，为方块注册放置回调，返回该 toBlock 自身getTileID(); //返回 number 类型，该方块的数字ID（范围[0, 2048]）//回调相关示例，合成相关示例见下文//极为经典的铁剑点地爆炸，因为在CrT所创建的沙盒中无法使用CEAPI，因此使用Rhino提供的调用Java的功能直接调用Java方法$(&quot;item:iron_sword&quot;).onUse(function (coords, item, block, isExternal, player) &#123; com.zhekasmirnov.innercore.api.NativeAPI.explode(coords.x, coords.y, coords.z, 10, true);&#125;);//在基岩上放置基岩时爆炸$(&quot;block:bedrock&quot;).toBlock().onPlace(function (coords, item, block, player, region) &#123; let pos = coords.relative; if (!region.getBlock(pos.x, pos.y, pos.z).id) &#123; region.setBlock(pos.x, pos.y, pos.z, $(&quot;block:bedrock&quot;).id, 0); if (block.id === $(&quot;block:bedrock&quot;).id) &#123; region.explode(pos.x, pos.y + 1, pos.z, 100, false); &#125; &#125;&#125;); requirerequire可用于获取CrT的自定义API，在没有其他模组添加API的情况下，默认可获取的API有furnace和recipes 格式：1require(&quot;api_name&quot;); //返回 api_name 对象 用法：123//因为一般情况下只需要获取一次API对象，而且没有修改名称的必要，故赋值为常量const Furnace = require(&quot;furnace&quot;); //CrT预置的熔炉类const Recipes = require(&quot;recipes&quot;); //CrT预置的合成类 下面将详细介绍furnace和recipes的详细用法 furnace12345678910111213//我们已经获取到了 furnace 对象并赋值给 Furnace，为方便，下文均使用 Furnace// Furnace 有三条函数可用Furnace.remove(input); // input - ItemStack 类型，输入物品，移除某物品的熔炉配方Furnace.addRecipe(input, output); // input - ItemStack 类型，输入物品，output - ItemStack 类型，输出物品，添加一条熔炉配方Furnace.setFuel(input, time); // input - ItemStack 类型，燃料物品，time - number 类型，燃烧时间，设置某物品作为燃料的燃烧时间//举例：Furnace.remove($(&quot;block:iron_ore&quot;)); //移除铁矿石的熔炉配方Furnace.addRecipe($(&quot;item:rotten_flesh&quot;), $(&quot;item:leather&quot;)); //经典的腐肉烧皮革Furnace.setFuel($(&quot;block:hay_block&quot;), 900); //将干草块设置为燃料，燃烧时间为4.5个物品//注：200燃烧时间为一个物品 recipes12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//同上，下文均使用Recipes//至此，我们可以说明上文的一些“详见下文”了// Recipes 有三条函数可用Recipes.remove(output); // output - ItemStick 类型，输出物品，移除某物品的合成配方Recipes.addShaped(output, input); // output - ItemStack 类型，输出物品，input - array 类型，包含输入物品的二维数组，添加有序合成Recipes.addShapeless(output, item); // output - ItemStack 类型，输出物品，input - array 类型，包含输入物品的一维数组，添加无序合成//举例：//移除工业模组中铜块合成配方（该函数在目前版本的IC暂不可移除原版合成配方）Recipes.remove($(&quot;block:blockCopper&quot;));/* 添加基岩的合成配方，摆放方式如下所示 * ABA * BAB * ABA * 其中 A 代表黑曜石，B 代表石头 */Recipes.addShaped($(&quot;block:bedrock*3&quot;), [[$(&quot;block:obsidian&quot;), $(&quot;block:stone&quot;), $(&quot;block:obsidian&quot;)], [$(&quot;block:stone&quot;), $(&quot;block:obsidian&quot;), $(&quot;block:stone&quot;)], [$(&quot;block:obsidian&quot;), $(&quot;block:stone&quot;), $(&quot;block:obsidian&quot;)]]);//你可以像下面这样写成多行以便阅读Recipes.addShaped($(&quot;block:bedrock*3&quot;), [ [$(&quot;block:obsidian&quot;), $(&quot;block:stone&quot;), $(&quot;block:obsidian&quot;)], [$(&quot;block:stone&quot;), $(&quot;block:obsidian&quot;), $(&quot;block:stone&quot;)], [$(&quot;block:obsidian&quot;), $(&quot;block:stone&quot;), $(&quot;block:obsidian&quot;)]]);//对于不需要放物品的格子，留空或者填null即可/* 添加用石头合成石镐的合成配方，摆放方式如下所示 * AAA * B * B * 其中 A 代表石头，B 代表木棍 *///如果你有够强迫症可以写这样（虽然对于强迫症我更建议写到一行，眼不见心不烦）Recipes.addShaped($(&quot;item:stone_pickaxe&quot;), [ [$(&quot;block:stone&quot;), $(&quot;block:stone&quot;), $(&quot;block:stone&quot;)], [null , $(&quot;item:stick&quot;) , null ], [null , $(&quot;item:stick&quot;) , null ]]);//添加有不被消耗物品的合成//使用铁锭和海洋之心合成三叉戟，其中海洋之心可以重复使用Recipes.addShaped($(&quot;item:trident&quot;), [[$(&quot;item:iron_ingot&quot;), $(&quot;item:iron_ingot&quot;), $(&quot;item:iron_ingot&quot;)], [null, $(&quot;item:heart_of_the_sea&quot;).reuse(), null], [null, $(&quot;item:iron_ingot&quot;), null]]);//添加无序合成与有序合成的方式十分相像，而且在添加输入物品时可以设置数量（有序合成则只能设置输出物品的数量），但要注意的是输入物品的总数不能超过9个//截止至V1.1.0版本的CrT，有设置输入物品数量的配方会有部分物品不会消耗的BUG//为蘑菇煲添加两条合成配方，使其只需要任意两个蘑菇即可合成Recipes.addShapeless($(&quot;item:mushroom_stew&quot;), [$(&quot;block:brown_mushroom&quot;), $(&quot;block:brown_mushroom&quot;), $(&quot;item:bowl&quot;)]);Recipes.addShapeless($(&quot;item:mushroom_stew&quot;), [$(&quot;block:red_mushroom&quot;), $(&quot;block:brown_mushroom&quot;), $(&quot;item:bowl&quot;)]);//添加消耗物品耐久的配方//使用毒马铃薯合成马铃薯，并消耗剪刀1耐久值//特殊值-1代表任意特殊值均可Recipes.addShapeless($(&quot;item:potato&quot;), [$(&quot;item:shears:-1&quot;).transformDamage(), $(&quot;item:poisonous_potato&quot;)]);//自定义合成事件//使用水桶与爆裂紫颂果合成紫颂果，并返还桶Recipes.addShapeless($(&quot;item:chorus_fruit&quot;), [$(&quot;item:chorus_fruit_popped&quot;), $(&quot;item:water_bucket&quot;).only(function (api, index, item, output) &#123; item.id = $(&quot;item:bucket&quot;).id;&#125;)]);//木板与剪刀合成随机1-4根木棍并消耗剪刀相应的耐久值Recipes.addShapeless($(&quot;item:stick&quot;), [$(&quot;block:planks&quot;), $(&quot;item:shears:-1&quot;).only(function (api, index, item, output) &#123; let count = Math.floor(Math.random() * 4) + 1; let max = $(&quot;item:shears&quot;).toItem().getMaxDamage(); item.data += count; if (item.data &gt;= max) &#123; count += max - item.data; item.id = item.data = item.count = 0; &#125; output.count = count;&#125;)]); 模组联动如果你是模组开发者，你可以通过ModAPI调用CrT提供的方法来拓展CrT 1234//CrT有以下方法可以通过ModAPI调用addAPI(name, state); // name - string 类型，API名称，state - object 类型，API对象，像CrT添加自定义API以在脚本中使用require(name); // name - string 类型，API名称，同上文requirerequireGlobal(command); // command - string 类型，要执行的代码，在CrT的中执行一段代码，慎用 好了，你已经学会如何使用CrT了，快去试着制作整合包吧！","categories":[],"tags":[]},{"title":"模组集","slug":"模组集","date":"2022-01-01T10:12:49.659Z","updated":"2022-01-01T12:56:17.977Z","comments":true,"path":"2022/01/01/模组集/","link":"","permalink":"https://weifeng233.github.io/2022/01/01/%E6%A8%A1%E7%BB%84%E9%9B%86/","excerpt":"","text":"模组集是在2.2.1b85更新中加入的功能。 功能概述模组集将一些互相兼容的模组整合为一个整体，通常包含附加代码或者模组以提高模组集成度和游戏玩法一致性。 在此更新中，模组将无法安装在模组集之外，因此InnerCore会创建一个默认模组集，你可以在其之中找到你之前安装的所有模组并通过模组管理器添加新模组。你可以到模组管理器的我的模组集中下载现成的模组集。要加载一个模组集只需要点击模组集页面上的选择按钮。 无论何时都只能加载一个模组集。模组集默认到受更改保护，即模组集内的模组不会被模组管理器更新除非模组集有更新，以及你不能向模组集移除或添加模组，如果你尝试这样做会出现如下警告： 只有当你明白你在做什么时才允许修改模组集，当模组集被修改之后，模组集中的模组将开启更新功能，同时模组集会失去更新功能。 创建你自己的模组集你可以基于现有的模组集或默认模组集来创建你自己的模组集。使用模组集页面的克隆选项即可完成此工作（在目前版本中，部分设备可能无法克隆默认模组集，下文会讲如何使用文件管理器手动操作） 生成的模组集会在对应的InnerCore包的modpacks文件夹内。接下来你可以使用模组管理器来安装所需的模组，也可以将你自己编写的模组添加到模组集的mods文件夹中。除此之外，你还可以添加模组集图标pack_icon.png，以及必须创建模组集清单文件modpacks.json，其中可包含以下字段： name - 模组集的短名称，将会作为其ID displayedName - 模组集的展示名称 versionName - 模组集当前的版本名称 versionCode - 模组集当前的版本号 author - 模组集的作者名称 description - 模组集的简介 示例： 12345678&#123; &quot;name&quot;: &quot;coop-tech&quot;, &quot;displayedName&quot;: &quot;Cooperative Tech&quot;, &quot;versionName&quot;: &quot;1.01-beta​&quot;, &quot;versionCode&quot;: 2, &quot;author&quot;: &quot;zheka_smirnov&quot;, &quot;description&quot;: &quot;Simple small modpack, that contains few tech and utility mods and supports multiplayer.&quot;&#125; 一旦模组集构建完成，可以使用模组集界面内的压缩文件选项创建一个压缩存档保存在对应InnerCore包的modpacks-archive文件夹内，你可以在模组管理器的模组集页面重装模组集的压缩文档。 模组配置首先，你应该知道每个ICMod都有一个config.json文件用于存储的模组的配置信息，在模组集中应将模组的压缩文件统一放在模组集的config文件夹内，并按模组文件夹名-config.json的格式命名（文件夹名称中的空格需要使用-代替），此外，你还可以在该文件夹中创建一个.keep-unchanged文件夹用于存放不允许玩家修改的配置信息。 注意：如果一个模组的配置信息不在config文件夹内时InnerCore会自动创建一个仅包含enabled字段的json文件，此操作可能会使模组无法读取到需要的配置信息而导致报错。","categories":[],"tags":[]},{"title":"使用JavaScript实现的MCBE史莱姆区块算法","slug":"使用JavaScript实现的MCBE史莱姆区块算法","date":"2021-08-29T15:11:08.237Z","updated":"2022-01-11T16:53:28.415Z","comments":true,"path":"2021/08/29/使用JavaScript实现的MCBE史莱姆区块算法/","link":"","permalink":"https://weifeng233.github.io/2021/08/29/%E4%BD%BF%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E7%9A%84MCBE%E5%8F%B2%E8%8E%B1%E5%A7%86%E5%8C%BA%E5%9D%97%E7%AE%97%E6%B3%95/","excerpt":"","text":"直接将origin0110使用C的代码简单地用JS写一遍，在此记录： 2022/1/12：减少不必要的转无符号运算 12345678910111213141516171819function getSeed(x, z) &#123; return x * 0x1f1f1f1f ^ z;&#125;function isSlimeChunk(s) &#123; let m = 1 + Math.imul(s ^ s &gt;&gt;&gt; 30, 0x6c078965); s = s &amp; 0x80000000 | m &amp; 0x7fffffff; for (let i = 2; i &lt; 398; i++) m = i + Math.imul(m ^ m &gt;&gt;&gt; 30, 0x6c078965); m ^= (s &gt;&gt;&gt; 1) ^ (s &amp; 1 ? 0x9908b0df : 0x0); m ^= m &gt;&gt;&gt; 11; m ^= m &lt;&lt; 0x7 &amp; 0x9d2c5680; m ^= m &lt;&lt; 0xf &amp; 0xefc60000; m ^= m &gt;&gt;&gt; 18; return !((m &gt;&gt;&gt; 0) % 10);&#125;","categories":[],"tags":[]},{"title":"UI PART2","slug":"UI-2","date":"2021-08-13T17:51:44.941Z","updated":"2021-08-29T15:18:35.562Z","comments":true,"path":"2021/08/14/UI-2/","link":"","permalink":"https://weifeng233.github.io/2021/08/14/UI-2/","excerpt":"","text":"注意：本教程仅为简单介绍UI的窗口，不会涉及详细的函数。如果想要了解更多请阅读官方文档。 在上期教程中我们简要介绍了ICMod的UI构成与基本控件，接下来将详细介绍控件用法以及如何组成一个“精美”的界面。 StandardWindow在此纠正上一篇专栏的严重错误：StandartWindow在现在版本的InnerCore中已经弃用，使用StandardWindow替代。 你可以永远相信StandardWindow。 —Prosto Sostavil StandardWindow是一个由三部分组成的WindowGroup，分别为main, inventory和header，对应关系如下图： Standard样式与原版的PocketUI相似，默认自带一个展示玩家背包的可滑动界面以及常规的关闭界面按钮和界面名称等，非常适合用作一般的方块实体的互动界面。 在此使用工业的火力发电机界面作为示例： 这是一个简单的界面，但基本上包含了常用控件，让我们简要分析一下其代码： 123456789101112131415161718192021//源码使用TypeScript编写且分不同部分在多个文件中，为方便讲解取主要代码并使用JavaScript重写const GUI_SCALE = 3.2; //声明GUI_SCALE常量，以便统一模组内各界面new UI.StandardWindow(&#123; standard: &#123; header: &#123;text: &#123;text: Translation.translate(&quot;Generator&quot;)&#125;&#125;, //此处使用Translate类函数以实现多语言，详见官方文档 inventory: &#123;standard: true&#125;, background: &#123;standard: true&#125; &#125;, drawing: [//两个scale元素对应的当其为空时的贴图 &#123;type: &quot;bitmap&quot;, x: 530, y: 144, bitmap: &quot;energy_bar_background&quot;, scale: GUI_SCALE&#125;, &#123;type: &quot;bitmap&quot;, x: 450, y: 150, bitmap: &quot;fire_background&quot;, scale: GUI_SCALE&#125;, ], elements: &#123; &quot;energyScale&quot;: &#123;type: &quot;scale&quot;, x: 530 + GUI_SCALE * 4, y: 144, direction: 0, value: 0.5, bitmap: &quot;energy_bar_scale&quot;, scale: GUI_SCALE&#125;, //注意此处x的值比对应的bitmap加了GUI_SCALE*4，这是因为它的贴图两端各少了4个像素，以便完整显示进度 &quot;burningScale&quot;: &#123;type: &quot;scale&quot;, x: 450, y: 150, direction: 1, value: 0.5, bitmap: &quot;fire_scale&quot;, scale: GUI_SCALE&#125;, &quot;slotEnergy&quot;: &#123;type: &quot;slot&quot;, x: 441, y: 75&#125;, &quot;slotFuel&quot;: &#123;type: &quot;slot&quot;, x: 441, y: 212&#125;, &quot;textInfo1&quot;: &#123;type: &quot;text&quot;, x: 642, y: 142, width: 300, height: 30, text: &quot;0/&quot;&#125;, &quot;textInfo2&quot;: &#123;type: &quot;text&quot;, x: 642, y: 172, width: 300, height: 30, text: &quot;10000&quot;&#125; &#125;&#125;); 可以看出在StandardWindow中使用的是绝对坐标，而且可与贴图像素对应，因此只需要耐心的慢慢调整就能够得到一个不错的界面。 与方块实体互动此部分不是本教程的主要内容，因此将简要带过。 在IC中，注册方块实体的函数为TileEntity.registerPrototype(blockID: number, customPrototype: TileEntityPrototype): void，参数只有两个：方块ID和方块实体原型。 方块实体原型是一个JS对象，包含方块实体的数据和事件。要将创建的StandardWindow对象与方块实体绑定则需要在方块实体原型中设置getGuiScreen函数并返回界面对象。这样IC会自动为该界面对象创建相应的容器对象，你可以在方块实体原型的函数中使用this.container来获得容器对象并使用其提供的方法与界面交互。 更进一步StandardWindow的可玩性远不止如此，你可以试着除去StandardWindow的默认控件，并从0开始自定义界面，或者在方块实体原型的getGuiScreen方法中编写逻辑以使在不同的情况下打开不同的界面。 示例为我去年3月份初次尝试UI时所写的会根据MC设置的UI档案切换StandardWindow的方块实体（PS：图二的界面标题有偏移Bug，在之后的版本中已被修复）。整个界面从开始构思到完成大概用了5天时间(大部分时间用在编写库上，但如今得益于WindowGroup，可以更快地完成该任务。 WindowWindow是最基本的窗口，相较于StandardWindow，Window更为灵活，适合用作弹窗或者HUD。 在创建一个Window对象的时候，可以像StandardWindow那样传入一个包含Drawing和Elements等的对象。但能够突出Window特色的是location参数，你可以自定义Window的大小，在屏幕上的位置，内边距和可滑动窗口大小（PS：Window内的unit为此Window宽度的千分之一）。 值得一提，内边距padding的会覆盖x|y|width|height的效果。 举个简单的空白窗口界面的例子： 1234567891011121314151617181920212223//定义一些常量const GUI_SCALE = 5;const WIDTH = 1000;const HEIGHT = UI.getScreenHeight();//创建窗口let testWindow = new UI.Window(&#123; location: &#123; //此处运算是为方便居中 x: (WIDTH - 300) / 2, y: (HEIGHT - 225) / 2, width: 300, height: 225 &#125;, drawing: [ //贴图是从拆原版包扒的XD &#123;type: &quot;background&quot;, color: android.graphics.Color.TRANSPARENT&#125;, &#123;type: &quot;frame&quot;, bitmap: &quot;background_panel&quot;, width: 1000, height: 750, scale: GUI_SCALE&#125; ], elements: &#123; &quot;closeButton&quot;: &#123;type: &quot;closeButton&quot;, x: 904, y: 26, bitmap: &quot;close_button_default&quot;, bitmap2: &quot;close_button_pressed&quot;, scale: GUI_SCALE&#125; &#125;&#125;);//一些常规设置testWindow.setCloseOnBackPressed(true);testWindow.setBlockingBackground(true); 效果图： TabbedWindowTabbedWindow可用于创建标签式窗口，如原版的玩家背包一样，具有多个可切换的标签页。 TabbedWindow和StandardWindow一样，都继承自WindowGroup。在创建TabbedWindow对象时，所传入的参数与Window相同，与之不同的是TabbedWindow多了一些函数。 使用new UI.TabbedWindow()创建一个空白的TabbedWindow，效果如下（PS：部分异形屏可能会被遮挡部分边界）： 简单地说明一下这个窗口，左上角的关闭按钮是一个索引值为0的FakeTab（PS：FakeTab指没有对应标签页的标签），标签页的上限为12个，即索引值的范围为0-11（左侧为0-5，右侧为6-11）。 要添加一个标签页可以使用setTab(index: number, tabOverlay: ElementSet, tabContent: WindowContent, isAlwaysSelected?: boolean): void函数，index即标签页的索引值，tabOverlay是标签的元素集（如关闭按钮），tabContent即为标签页展示的窗口内容，格式与之前介绍的基本无异。 因为setTab函数并不返回创建的Window对象，所以你需要用到getWindowForTab(index: number): Window来函数获取对应索引值的Window实例化对象，以完成对其的动态修改。 WindowGroupWindowGroup是StandardWindow和TabbedWindow的父类，其方法基本上都可以在StandardWindow和TabbedWindow中使用。 WindowGroup诞生的目的是为了能够将复杂的界面模块化，以便提高代码的复用率并降低调试难度，使开发效率提高，最为典型的例子就是IC中的工作台界面（PS：此处不谈其交互逻辑，仅谈其界面）。 该界面由三部分组成，分别为Main·，Slots和Grid，对应下图中的青色，粉色和黄色部分： 阅读workbench.js中工作台界面部分的代码，可以看出该三部分都是先定义WindowContent的JSON描述，然后一一创建Window对象，并使用addWindowInstance(name: string, window: Window): void函数将Window对象添加到WindowGroup对象并声明其对应的名称ID。你也可以直接使用addWindow(name: string, content: WindowContent): Window函数向WindowGroup添加窗口。 至此，关于UI界面的内容就基本上介绍完毕，当然全部内容不止这些，你需要认真地查阅官方文档以及去学习他人的优秀作品。另外，虽然本教程对于UI与容器的互动只是简单地带过，但此部分内容是相当重要的，应当注重学习（PS：谁让你们当时评论不提容器和方块实体呢XD）。","categories":[],"tags":[]},{"title":"UI PART1","slug":"UI-1","date":"2021-06-26T06:57:07.355Z","updated":"2021-06-26T07:03:05.492Z","comments":true,"path":"2021/06/26/UI-1/","link":"","permalink":"https://weifeng233.github.io/2021/06/26/UI-1/","excerpt":"","text":"Try hard. -Zheka Smirnov 本文的部分名词与描述或许与别处有出入以至于错误，欢迎在评论区指出 相较于原版MC，IC的UI系统并不有多复杂，可简单地用下图概括 尽管这张图看似过于简略，但事实的确如此。快速掌握UI的基本控件等内容并不困难，但难点是如何用它们拼凑出美观且实用的用户界面 PS：本文不会讲到每一个控件及其函数，更详细的内容可见官方文档 首先在IC中，用户界面的控件的大小和单位都是使用同一的unit单位，1unit = 窗口宽度/1000 UI资源UI所使用到的贴图存放于构筑文件(build.config)所指定的gui类型的资源文件夹，在使用时只需要输入文件名即可(不包含后缀与文件夹) 除此之外，还有： color: 颜色，即Android的Color类，可使用android.graphics.Color.rgb(r, g, b)等自定义颜色 font: 字体，包含三个属性，{size: 文本大小, color: 文本颜色, shadow: 文本阴影}，其中文本阴影为范围[0, 1]的浮点数 frame: 边框，一般使用大小为16x16的贴图，在使用时会被自动拉伸至所需大小 DrawingDrawing，顾名思义就是在界面中进行绘制，在UI的描述对象中Drawing为一个包含绘制指令的数组 描述对象：用于设定UI以及在UI打开时对其进行动态修改 123456//格式drawing: [ &#123;/*指令1*/&#125;, &#123;/*指令2*/&#125;, ...] 常用标准指令如下： 123456&#123;type: &quot;background&quot;, color: 颜色&#125; //填充背景颜色&#123;type: &quot;bitmap&quot;, bitmap: 贴图, x: Number, y: Number, width: Number, height: Number, scale: Number&#125; //绘制贴图，scale - 贴图像素和unit的缩放比例，默认1像素=1unit&#123;type: &quot;frame&quot;, x: Number, y: Number, width: Number, height: Number, bitmap: 贴图, bg: 颜色, scale: Number&#125; //绘制边框，bg - 边框背景颜色&#123;type: &quot;text&quot;, text: String, x: Number, y: Number, font: 字体&#125; //绘制文本&#123;type: &quot;line&quot;, x1: Number, y1: Number, x2: Number, y2: Number, width: Number, height: Number, color: 颜色&#125; //绘制直线，width - 直线粗细&#123;type: &quot;custom&quot;, onDraw: Function(canvas, scale)&#125; //自定义绘制，onDraw - 在绘制时调用的函数，传参包括当前绘制的Canvas对象和scale数值，无返回值 PS：custom drawing的canvas为Android的Canvas类 ElementsElements，指UI中的控件，与Drawing不同的是Elements在描述对象里为一个包含各控件的对象 Elements中的每一个控件都有其唯一且独特的名称，即每一个对象都有其唯一的建 123456//格式elements: &#123; &quot;名称1&quot;: &#123;/*元素1*/&#125;, &quot;名称2&quot;: &#123;/*元素2*/&#125;, ...&#125; 每一个元素都有以下基本属性： 1234567&#123; type: &quot;type&quot;, //元素类型 x: number, //x坐标 y: number, //y坐标 z: number, //z坐标，用于区分控件层次防止混乱重叠 clicker: Click对象 //控件点击对象&#125; 此处控件点击对象指一个包含短时点击事件和长时点击事件函数的对象： 12345678910&#123; onClick: function(position, container, tileEntity, window, canvas, scale) &#123; //container - 界面打开的容器 //tileEntity - 如果界面是为某方块实体打开的，它就会传出它，否则传出null &#125;, onLongClick: function(position, container, tileEntity, window, canvas, scale) &#123; //container - 界面打开的容器 //tileEntity - 如果界面是为某方块实体打开的，它就会传出它，否则传出null &#125;&#125; 同样地，常用元素如下： 123456789&#123;type: &quot;slot&quot;, x: Number, y: Number, size: Number, visual: Boolean/Function(id, data, count), bitmap: 贴图, clicker: Click对象&#125; //物品格，visual - 是否可选中&#123;type: &quot;invSlot&quot;, x: Number, y: Number, size: Number, index: Number, bitmap: 贴图&#125; //背包物品格，index - 对应背包物品格id&#123;type: &quot;button&quot;, x: Number, y: Number, bitmap: 贴图, bitmap2: 贴图, scale: Number, clicker: Click对象&#125; //按钮，bitmap2 - 按下时贴图，button的Click对象与其他的稍有不同，其点击事件函数的参数为(container, tileEntity, position, window, canvas, scale)&#123;type: &quot;closeButton&quot;, x: Number, y: Number, global: Boolean, bitmap: 贴图, bitmap2: 贴图, scale: Number&#125; //关闭窗口按钮，global - 为真时将关闭窗口组内所有窗口，否则只关闭所在单窗口，详见下文&#123;type: &quot;scale&quot;, x: Number, y: Number, direction: Number, bitmap: 贴图, scale: Number, invert: Number, overlay: 贴图, overlayScale: Number, overlayOffset: &#123;x: Number, y: Number&#125;&#125; //刻度表或进度栏，direction - 朝向，详见下文，invert - 是否翻转贴图，overlay - 重叠在scale上的贴图，Scale和Offset分别为其缩放比例和相对scale元素的位置&#123;type: &quot;text&quot;, x: Number, y: Number, width: Number, height: Number, text: String, font: 字体&#125; //文本&#123;type: &quot;fps&quot;, interpolate: Boolean, period: Number, font: 字体, multiline: Boolean, format: Boolean, maxCharsPerLine: Number&#125;//FPS文本&#123;type: &quot;image&quot;, x: Number, y: Number, bitmap: 贴图, scale: Number, overlay: 贴图, overlayScale: Number, overlayOffset: &#123;x: Number, y: Number&#125;, clicker: Click对象&#125; //贴图&#123;type: &quot;custom&quot;, onSetup: Function(element: Element), onDraw: Function(element, canvas, scale), onTouchReleased: Function(element), onBindingUpdated: Function(element, name, value), onReset: Function(element), onRelease: Function(element), onContainerInit: Function(element, container, elementName)&#125;//自定义元素，各函数均无返回值 除以上元素之外，还有Scroll，Switch，Tab等元素未被提及，但用法大同小异，建议自行按照官方文档进行尝试，这样才是最有效率的学习方法 direction参数: 0 - 朝右1 - 朝上2 - 朝左3 - 朝下 在简要介绍完Drawing和Elments后，在介绍重头戏Window之前先来补充一点其他内容 自定义参数用于修改Window的一些默认参数，如下： 12345678params: &#123; slot: &quot;格子贴图&quot;, invSlot: &quot;背包格子贴图&quot;, frame: &quot;平面边框贴图&quot;, selection: &quot;格子高亮贴图&quot;, closeButton: &quot;关闭按钮贴图&quot;, closeButton2: &quot;按下的关闭按钮贴图&quot;,&#125; UI.getContext()该函数用于获取Android UI线程的上下文，以便调用Android API来操控界面控件 UI.getScreenHeight()获取以unit为单位的屏幕高度，与之相同的还有UI.getScreenRelativeHeight() ElementSet元素集合 WindowLocation窗口位置及大小，使用unit作为单位，详细参数见官方文档 Style窗口风格，有CLASSIC和DEFAULT两种 Slot，FullSlot窗口中的物品格对象，Slot包含物品的id、特殊值、数量和额外数据，FullSlot则在其基础上添加了如drop、set等方法 Window在官方文档中，窗口(Window)有如下几个类： StandardWindow StandartWindow TabbedWindow Window WindowGroup 在这里将暂先略讲StandartWindow，Window和WindowGroup StandartWindow定义为UI.StandartWindow类，以一个描述对象定义界面 描述对象格式(摘自BigFish和方法放寒假翻译的官方Wiki第8-2节)： 123456789101112131415161718192021222324252627282930&#123; standart: &#123;//这种类型的界面标准参数在这里写入，它们允许你快速地设置基本的元素，例如标题、背景和背包 //如果你想定义标准的元素，但是又不想改变默认值，那么就单写上值 - standart: true，例如inventory: &#123;standart: true&#125; header: &#123;//设定你是否需要一个标头，包含一个标题和和一个关闭按钮 text: &#123;//必需的参数，如果你定义了标头 text: &quot;标题文本&quot;, //文本内容，必需的参数 &#125;, Font: &#123;...&#125;, //文本字体，如果你想改变默认值，就请定义它 color: 颜色, //只有当你想改变标题颜色的时候才需要 frame: &quot;边框文本&quot;, //只有当你想改变标头边框的时候才需要 width: 80, //表头的高度，以unit为单位 hideButton: true, //定义并设置为true则移除关闭按钮 &#125;, inventory: &#123;//要想定义标准背包，请使用inventory: &#123;standart: true&#125; width: 300, //背包窗口的宽度 padding: 20, //背包窗口的内边距 &#125;, background: &#123;//要定义一个默认背景，请使用background: &#123;standart: true&#125; color: 颜色, //如果你想改变背景的颜色就定义它 bitmap: &quot;背景图片&quot;, //如果你想添加一个背景图片就定义它 frame: &quot;边框贴图&quot; //如果你想添加一个边框就定义它 &#125;, minHeight: 650, //如果以unit为单位的窗口高度小于这个参数的值，那么窗口将自动转变为滚动窗口，以此来保证它的内部大小的高度为minHeight units &#125;, params: &#123; //自定义（改变默认材质） &#125;, drawing: [/*背景渲染指令*/], elements: &#123;/*元素的描述*/&#125;&#125; StandartWindow是适用性最高的窗口，在多人游戏中表现优于Window，但尽管如此绝对布局仍是其一大缺点，在实际使用时需要考虑到不同的屏幕尺寸会造成的控件偏移。因此，尽量将控件放置在屏幕内部区域 Window相较于StandartWindow，Window的优点在于其灵活性，与默认为方块互动界面的StandartWindow不同，Window可以通过修改WindowLocation来显示在游戏界面上的任意位置，且可以通过适当修改padding值来尽可能避免控件偏移。 Window默认没有关闭按钮和玩家背包栏，在使用时需要按需自行添加 WindowGroupStandartWindow和Window都是单个窗口，如果需要复杂的界面那么用多个窗口组合无疑是最最好的选择，将一个复杂窗口分为多个小窗口也可以提高调试效率。 WindowGroup的主要作用就是将多个Window整合在一起，将其组合布局在一起，例如现在的工作台界面就是一个包含3个Window的WindowGroup Hierarchic UI库HierarchicUI由Zheka开发，用于以json来定义分层式的UI，可以方便的创建绝对布局和线性布局，届时json会被解析为WindowGroup 此外，该库还可以定义视图布局并且对于一个视图可以灵活地嵌入到其他界面，并且基于它创建继承其全部属性的子视图，无疑让WindowGroup展示美观的复杂界面更加容易。","categories":[],"tags":[]}],"categories":[],"tags":[]}