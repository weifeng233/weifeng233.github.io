{"meta":{"title":"微风的博客","subtitle":"","description":"","author":"SugarBreeze","url":"https://weifeng233.github.io","root":"/"},"pages":[],"posts":[{"title":"模组集","slug":"模组集","date":"2022-01-01T10:12:49.659Z","updated":"2022-01-01T12:56:17.977Z","comments":true,"path":"2022/01/01/模组集/","link":"","permalink":"https://weifeng233.github.io/2022/01/01/%E6%A8%A1%E7%BB%84%E9%9B%86/","excerpt":"","text":"模组集是在2.2.1b85更新中加入的功能。 功能概述模组集将一些互相兼容的模组整合为一个整体，通常包含附加代码或者模组以提高模组集成度和游戏玩法一致性。 在此更新中，模组将无法安装在模组集之外，因此InnerCore会创建一个默认模组集，你可以在其之中找到你之前安装的所有模组并通过模组管理器添加新模组。你可以到模组管理器的我的模组集中下载现成的模组集。要加载一个模组集只需要点击模组集页面上的选择按钮。 无论何时都只能加载一个模组集。模组集默认到受更改保护，即模组集内的模组不会被模组管理器更新除非模组集有更新，以及你不能向模组集移除或添加模组，如果你尝试这样做会出现如下警告： 只有当你明白你在做什么时才允许修改模组集，当模组集被修改之后，模组集中的模组将开启更新功能，同时模组集会失去更新功能。 创建你自己的模组集你可以基于现有的模组集或默认模组集来创建你自己的模组集。使用模组集页面的克隆选项即可完成此工作（在目前版本中，部分设备可能无法克隆默认模组集，下文会讲如何使用文件管理器手动操作） 生成的模组集会在对应的InnerCore包的modpacks文件夹内。接下来你可以使用模组管理器来安装所需的模组，也可以将你自己编写的模组添加到模组集的mods文件夹中。除此之外，你还可以添加模组集图标pack_icon.png，以及必须创建模组集清单文件modpacks.json，其中可包含以下字段： name - 模组集的短名称，将会作为其ID displayedName - 模组集的展示名称 versionName - 模组集当前的版本名称 versionCode - 模组集当前的版本号 author - 模组集的作者名称 description - 模组集的简介 示例： 12345678&#123; &quot;name&quot;: &quot;coop-tech&quot;, &quot;displayedName&quot;: &quot;Cooperative Tech&quot;, &quot;versionName&quot;: &quot;1.01-beta​&quot;, &quot;versionCode&quot;: 2, &quot;author&quot;: &quot;zheka_smirnov&quot;, &quot;description&quot;: &quot;Simple small modpack, that contains few tech and utility mods and supports multiplayer.&quot;&#125; 一旦模组集构建完成，可以使用模组集界面内的压缩文件选项创建一个压缩存档保存在对应InnerCore包的modpacks-archive文件夹内，你可以在模组管理器的模组集页面重装模组集的压缩文档。 模组配置首先，你应该知道每个ICMod都有一个config.json文件用于存储的模组的配置信息，在模组集中应将模组的压缩文件统一放在模组集的config文件夹内，并按模组文件夹名-config.json的格式命名（文件夹名称中的空格需要使用-代替），此外，你还可以在该文件夹中创建一个.keep-unchanged文件夹用于存放不允许玩家修改的配置信息。 注意：如果一个模组的配置信息不在config文件夹内时InnerCore会自动创建一个仅包含enabled字段的json文件，此操作可能会使模组无法读取到需要的配置信息而导致报错。","categories":[],"tags":[]},{"title":"使用JavaScript实现的MCBE史莱姆区块算法","slug":"使用JavaScript实现的MCBE史莱姆区块算法","date":"2021-08-29T15:11:08.237Z","updated":"2022-01-11T16:39:52.910Z","comments":true,"path":"2021/08/29/使用JavaScript实现的MCBE史莱姆区块算法/","link":"","permalink":"https://weifeng233.github.io/2021/08/29/%E4%BD%BF%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E7%9A%84MCBE%E5%8F%B2%E8%8E%B1%E5%A7%86%E5%8C%BA%E5%9D%97%E7%AE%97%E6%B3%95/","excerpt":"","text":"直接将origin0110使用C的代码简单地用JS写一遍，在此记录： 2022/1/12：减少不必要的转无符号运算 12345678910111213141516171819function getSeed(x, z) &#123; return x * 0x1f1f1f1f ^ z;&#125;function isSlimeChunk(s) &#123; let m = 1 + Math.imul(s ^ s &gt;&gt;&gt; 30, 0x6c078965); s = s &amp; 0x80000000 | m &amp; 0x7fffffff; for (let i = 2; i &lt; 398; i++) m = i + Math.imul(m ^ m &gt;&gt;&gt; 30, 0x6c078965); m ^= (s &gt;&gt;&gt; 1) ^ (s &amp; 1 ? 0x9908b0df : 0x0); m ^= m &gt;&gt;&gt; 11; m ^= m &lt;&lt; 07 &amp; 0x9d2c5680; m ^= m &lt;&lt; 15 &amp; 0xefc60000; m ^= m &gt;&gt;&gt; 18; return !((m &gt;&gt;&gt; 0) % 10);&#125;","categories":[],"tags":[]},{"title":"UI PART2","slug":"UI-2","date":"2021-08-13T17:51:44.941Z","updated":"2021-08-29T15:18:35.562Z","comments":true,"path":"2021/08/14/UI-2/","link":"","permalink":"https://weifeng233.github.io/2021/08/14/UI-2/","excerpt":"","text":"注意：本教程仅为简单介绍UI的窗口，不会涉及详细的函数。如果想要了解更多请阅读官方文档。 在上期教程中我们简要介绍了ICMod的UI构成与基本控件，接下来将详细介绍控件用法以及如何组成一个“精美”的界面。 StandardWindow在此纠正上一篇专栏的严重错误：StandartWindow在现在版本的InnerCore中已经弃用，使用StandardWindow替代。 你可以永远相信StandardWindow。 —Prosto Sostavil StandardWindow是一个由三部分组成的WindowGroup，分别为main, inventory和header，对应关系如下图： Standard样式与原版的PocketUI相似，默认自带一个展示玩家背包的可滑动界面以及常规的关闭界面按钮和界面名称等，非常适合用作一般的方块实体的互动界面。 在此使用工业的火力发电机界面作为示例： 这是一个简单的界面，但基本上包含了常用控件，让我们简要分析一下其代码： 123456789101112131415161718192021//源码使用TypeScript编写且分不同部分在多个文件中，为方便讲解取主要代码并使用JavaScript重写const GUI_SCALE = 3.2; //声明GUI_SCALE常量，以便统一模组内各界面new UI.StandardWindow(&#123; standard: &#123; header: &#123;text: &#123;text: Translation.translate(&quot;Generator&quot;)&#125;&#125;, //此处使用Translate类函数以实现多语言，详见官方文档 inventory: &#123;standard: true&#125;, background: &#123;standard: true&#125; &#125;, drawing: [//两个scale元素对应的当其为空时的贴图 &#123;type: &quot;bitmap&quot;, x: 530, y: 144, bitmap: &quot;energy_bar_background&quot;, scale: GUI_SCALE&#125;, &#123;type: &quot;bitmap&quot;, x: 450, y: 150, bitmap: &quot;fire_background&quot;, scale: GUI_SCALE&#125;, ], elements: &#123; &quot;energyScale&quot;: &#123;type: &quot;scale&quot;, x: 530 + GUI_SCALE * 4, y: 144, direction: 0, value: 0.5, bitmap: &quot;energy_bar_scale&quot;, scale: GUI_SCALE&#125;, //注意此处x的值比对应的bitmap加了GUI_SCALE*4，这是因为它的贴图两端各少了4个像素，以便完整显示进度 &quot;burningScale&quot;: &#123;type: &quot;scale&quot;, x: 450, y: 150, direction: 1, value: 0.5, bitmap: &quot;fire_scale&quot;, scale: GUI_SCALE&#125;, &quot;slotEnergy&quot;: &#123;type: &quot;slot&quot;, x: 441, y: 75&#125;, &quot;slotFuel&quot;: &#123;type: &quot;slot&quot;, x: 441, y: 212&#125;, &quot;textInfo1&quot;: &#123;type: &quot;text&quot;, x: 642, y: 142, width: 300, height: 30, text: &quot;0/&quot;&#125;, &quot;textInfo2&quot;: &#123;type: &quot;text&quot;, x: 642, y: 172, width: 300, height: 30, text: &quot;10000&quot;&#125; &#125;&#125;); 可以看出在StandardWindow中使用的是绝对坐标，而且可与贴图像素对应，因此只需要耐心的慢慢调整就能够得到一个不错的界面。 与方块实体互动此部分不是本教程的主要内容，因此将简要带过。 在IC中，注册方块实体的函数为TileEntity.registerPrototype(blockID: number, customPrototype: TileEntityPrototype): void，参数只有两个：方块ID和方块实体原型。 方块实体原型是一个JS对象，包含方块实体的数据和事件。要将创建的StandardWindow对象与方块实体绑定则需要在方块实体原型中设置getGuiScreen函数并返回界面对象。这样IC会自动为该界面对象创建相应的容器对象，你可以在方块实体原型的函数中使用this.container来获得容器对象并使用其提供的方法与界面交互。 更进一步StandardWindow的可玩性远不止如此，你可以试着除去StandardWindow的默认控件，并从0开始自定义界面，或者在方块实体原型的getGuiScreen方法中编写逻辑以使在不同的情况下打开不同的界面。 示例为我去年3月份初次尝试UI时所写的会根据MC设置的UI档案切换StandardWindow的方块实体（PS：图二的界面标题有偏移Bug，在之后的版本中已被修复）。整个界面从开始构思到完成大概用了5天时间(大部分时间用在编写库上，但如今得益于WindowGroup，可以更快地完成该任务。 WindowWindow是最基本的窗口，相较于StandardWindow，Window更为灵活，适合用作弹窗或者HUD。 在创建一个Window对象的时候，可以像StandardWindow那样传入一个包含Drawing和Elements等的对象。但能够突出Window特色的是location参数，你可以自定义Window的大小，在屏幕上的位置，内边距和可滑动窗口大小（PS：Window内的unit为此Window宽度的千分之一）。 值得一提，内边距padding的会覆盖x|y|width|height的效果。 举个简单的空白窗口界面的例子： 1234567891011121314151617181920212223//定义一些常量const GUI_SCALE = 5;const WIDTH = 1000;const HEIGHT = UI.getScreenHeight();//创建窗口let testWindow = new UI.Window(&#123; location: &#123; //此处运算是为方便居中 x: (WIDTH - 300) / 2, y: (HEIGHT - 225) / 2, width: 300, height: 225 &#125;, drawing: [ //贴图是从拆原版包扒的XD &#123;type: &quot;background&quot;, color: android.graphics.Color.TRANSPARENT&#125;, &#123;type: &quot;frame&quot;, bitmap: &quot;background_panel&quot;, width: 1000, height: 750, scale: GUI_SCALE&#125; ], elements: &#123; &quot;closeButton&quot;: &#123;type: &quot;closeButton&quot;, x: 904, y: 26, bitmap: &quot;close_button_default&quot;, bitmap2: &quot;close_button_pressed&quot;, scale: GUI_SCALE&#125; &#125;&#125;);//一些常规设置testWindow.setCloseOnBackPressed(true);testWindow.setBlockingBackground(true); 效果图： TabbedWindowTabbedWindow可用于创建标签式窗口，如原版的玩家背包一样，具有多个可切换的标签页。 TabbedWindow和StandardWindow一样，都继承自WindowGroup。在创建TabbedWindow对象时，所传入的参数与Window相同，与之不同的是TabbedWindow多了一些函数。 使用new UI.TabbedWindow()创建一个空白的TabbedWindow，效果如下（PS：部分异形屏可能会被遮挡部分边界）： 简单地说明一下这个窗口，左上角的关闭按钮是一个索引值为0的FakeTab（PS：FakeTab指没有对应标签页的标签），标签页的上限为12个，即索引值的范围为0-11（左侧为0-5，右侧为6-11）。 要添加一个标签页可以使用setTab(index: number, tabOverlay: ElementSet, tabContent: WindowContent, isAlwaysSelected?: boolean): void函数，index即标签页的索引值，tabOverlay是标签的元素集（如关闭按钮），tabContent即为标签页展示的窗口内容，格式与之前介绍的基本无异。 因为setTab函数并不返回创建的Window对象，所以你需要用到getWindowForTab(index: number): Window来函数获取对应索引值的Window实例化对象，以完成对其的动态修改。 WindowGroupWindowGroup是StandardWindow和TabbedWindow的父类，其方法基本上都可以在StandardWindow和TabbedWindow中使用。 WindowGroup诞生的目的是为了能够将复杂的界面模块化，以便提高代码的复用率并降低调试难度，使开发效率提高，最为典型的例子就是IC中的工作台界面（PS：此处不谈其交互逻辑，仅谈其界面）。 该界面由三部分组成，分别为Main·，Slots和Grid，对应下图中的青色，粉色和黄色部分： 阅读workbench.js中工作台界面部分的代码，可以看出该三部分都是先定义WindowContent的JSON描述，然后一一创建Window对象，并使用addWindowInstance(name: string, window: Window): void函数将Window对象添加到WindowGroup对象并声明其对应的名称ID。你也可以直接使用addWindow(name: string, content: WindowContent): Window函数向WindowGroup添加窗口。 至此，关于UI界面的内容就基本上介绍完毕，当然全部内容不止这些，你需要认真地查阅官方文档以及去学习他人的优秀作品。另外，虽然本教程对于UI与容器的互动只是简单地带过，但此部分内容是相当重要的，应当注重学习（PS：谁让你们当时评论不提容器和方块实体呢XD）。","categories":[],"tags":[]},{"title":"UI PART1","slug":"UI-1","date":"2021-06-26T06:57:07.355Z","updated":"2021-06-26T07:03:05.492Z","comments":true,"path":"2021/06/26/UI-1/","link":"","permalink":"https://weifeng233.github.io/2021/06/26/UI-1/","excerpt":"","text":"Try hard. -Zheka Smirnov 本文的部分名词与描述或许与别处有出入以至于错误，欢迎在评论区指出 相较于原版MC，IC的UI系统并不有多复杂，可简单地用下图概括 尽管这张图看似过于简略，但事实的确如此。快速掌握UI的基本控件等内容并不困难，但难点是如何用它们拼凑出美观且实用的用户界面 PS：本文不会讲到每一个控件及其函数，更详细的内容可见官方文档 首先在IC中，用户界面的控件的大小和单位都是使用同一的unit单位，1unit = 窗口宽度/1000 UI资源UI所使用到的贴图存放于构筑文件(build.config)所指定的gui类型的资源文件夹，在使用时只需要输入文件名即可(不包含后缀与文件夹) 除此之外，还有： color: 颜色，即Android的Color类，可使用android.graphics.Color.rgb(r, g, b)等自定义颜色 font: 字体，包含三个属性，{size: 文本大小, color: 文本颜色, shadow: 文本阴影}，其中文本阴影为范围[0, 1]的浮点数 frame: 边框，一般使用大小为16x16的贴图，在使用时会被自动拉伸至所需大小 DrawingDrawing，顾名思义就是在界面中进行绘制，在UI的描述对象中Drawing为一个包含绘制指令的数组 描述对象：用于设定UI以及在UI打开时对其进行动态修改 123456//格式drawing: [ &#123;/*指令1*/&#125;, &#123;/*指令2*/&#125;, ...] 常用标准指令如下： 123456&#123;type: &quot;background&quot;, color: 颜色&#125; //填充背景颜色&#123;type: &quot;bitmap&quot;, bitmap: 贴图, x: Number, y: Number, width: Number, height: Number, scale: Number&#125; //绘制贴图，scale - 贴图像素和unit的缩放比例，默认1像素=1unit&#123;type: &quot;frame&quot;, x: Number, y: Number, width: Number, height: Number, bitmap: 贴图, bg: 颜色, scale: Number&#125; //绘制边框，bg - 边框背景颜色&#123;type: &quot;text&quot;, text: String, x: Number, y: Number, font: 字体&#125; //绘制文本&#123;type: &quot;line&quot;, x1: Number, y1: Number, x2: Number, y2: Number, width: Number, height: Number, color: 颜色&#125; //绘制直线，width - 直线粗细&#123;type: &quot;custom&quot;, onDraw: Function(canvas, scale)&#125; //自定义绘制，onDraw - 在绘制时调用的函数，传参包括当前绘制的Canvas对象和scale数值，无返回值 PS：custom drawing的canvas为Android的Canvas类 ElementsElements，指UI中的控件，与Drawing不同的是Elements在描述对象里为一个包含各控件的对象 Elements中的每一个控件都有其唯一且独特的名称，即每一个对象都有其唯一的建 123456//格式elements: &#123; &quot;名称1&quot;: &#123;/*元素1*/&#125;, &quot;名称2&quot;: &#123;/*元素2*/&#125;, ...&#125; 每一个元素都有以下基本属性： 1234567&#123; type: &quot;type&quot;, //元素类型 x: number, //x坐标 y: number, //y坐标 z: number, //z坐标，用于区分控件层次防止混乱重叠 clicker: Click对象 //控件点击对象&#125; 此处控件点击对象指一个包含短时点击事件和长时点击事件函数的对象： 12345678910&#123; onClick: function(position, container, tileEntity, window, canvas, scale) &#123; //container - 界面打开的容器 //tileEntity - 如果界面是为某方块实体打开的，它就会传出它，否则传出null &#125;, onLongClick: function(position, container, tileEntity, window, canvas, scale) &#123; //container - 界面打开的容器 //tileEntity - 如果界面是为某方块实体打开的，它就会传出它，否则传出null &#125;&#125; 同样地，常用元素如下： 123456789&#123;type: &quot;slot&quot;, x: Number, y: Number, size: Number, visual: Boolean/Function(id, data, count), bitmap: 贴图, clicker: Click对象&#125; //物品格，visual - 是否可选中&#123;type: &quot;invSlot&quot;, x: Number, y: Number, size: Number, index: Number, bitmap: 贴图&#125; //背包物品格，index - 对应背包物品格id&#123;type: &quot;button&quot;, x: Number, y: Number, bitmap: 贴图, bitmap2: 贴图, scale: Number, clicker: Click对象&#125; //按钮，bitmap2 - 按下时贴图，button的Click对象与其他的稍有不同，其点击事件函数的参数为(container, tileEntity, position, window, canvas, scale)&#123;type: &quot;closeButton&quot;, x: Number, y: Number, global: Boolean, bitmap: 贴图, bitmap2: 贴图, scale: Number&#125; //关闭窗口按钮，global - 为真时将关闭窗口组内所有窗口，否则只关闭所在单窗口，详见下文&#123;type: &quot;scale&quot;, x: Number, y: Number, direction: Number, bitmap: 贴图, scale: Number, invert: Number, overlay: 贴图, overlayScale: Number, overlayOffset: &#123;x: Number, y: Number&#125;&#125; //刻度表或进度栏，direction - 朝向，详见下文，invert - 是否翻转贴图，overlay - 重叠在scale上的贴图，Scale和Offset分别为其缩放比例和相对scale元素的位置&#123;type: &quot;text&quot;, x: Number, y: Number, width: Number, height: Number, text: String, font: 字体&#125; //文本&#123;type: &quot;fps&quot;, interpolate: Boolean, period: Number, font: 字体, multiline: Boolean, format: Boolean, maxCharsPerLine: Number&#125;//FPS文本&#123;type: &quot;image&quot;, x: Number, y: Number, bitmap: 贴图, scale: Number, overlay: 贴图, overlayScale: Number, overlayOffset: &#123;x: Number, y: Number&#125;, clicker: Click对象&#125; //贴图&#123;type: &quot;custom&quot;, onSetup: Function(element: Element), onDraw: Function(element, canvas, scale), onTouchReleased: Function(element), onBindingUpdated: Function(element, name, value), onReset: Function(element), onRelease: Function(element), onContainerInit: Function(element, container, elementName)&#125;//自定义元素，各函数均无返回值 除以上元素之外，还有Scroll，Switch，Tab等元素未被提及，但用法大同小异，建议自行按照官方文档进行尝试，这样才是最有效率的学习方法 direction参数: 0 - 朝右1 - 朝上2 - 朝左3 - 朝下 在简要介绍完Drawing和Elments后，在介绍重头戏Window之前先来补充一点其他内容 自定义参数用于修改Window的一些默认参数，如下： 12345678params: &#123; slot: &quot;格子贴图&quot;, invSlot: &quot;背包格子贴图&quot;, frame: &quot;平面边框贴图&quot;, selection: &quot;格子高亮贴图&quot;, closeButton: &quot;关闭按钮贴图&quot;, closeButton2: &quot;按下的关闭按钮贴图&quot;,&#125; UI.getContext()该函数用于获取Android UI线程的上下文，以便调用Android API来操控界面控件 UI.getScreenHeight()获取以unit为单位的屏幕高度，与之相同的还有UI.getScreenRelativeHeight() ElementSet元素集合 WindowLocation窗口位置及大小，使用unit作为单位，详细参数见官方文档 Style窗口风格，有CLASSIC和DEFAULT两种 Slot，FullSlot窗口中的物品格对象，Slot包含物品的id、特殊值、数量和额外数据，FullSlot则在其基础上添加了如drop、set等方法 Window在官方文档中，窗口(Window)有如下几个类： StandardWindow StandartWindow TabbedWindow Window WindowGroup 在这里将暂先略讲StandartWindow，Window和WindowGroup StandartWindow定义为UI.StandartWindow类，以一个描述对象定义界面 描述对象格式(摘自BigFish和方法放寒假翻译的官方Wiki第8-2节)： 123456789101112131415161718192021222324252627282930&#123; standart: &#123;//这种类型的界面标准参数在这里写入，它们允许你快速地设置基本的元素，例如标题、背景和背包 //如果你想定义标准的元素，但是又不想改变默认值，那么就单写上值 - standart: true，例如inventory: &#123;standart: true&#125; header: &#123;//设定你是否需要一个标头，包含一个标题和和一个关闭按钮 text: &#123;//必需的参数，如果你定义了标头 text: &quot;标题文本&quot;, //文本内容，必需的参数 &#125;, Font: &#123;...&#125;, //文本字体，如果你想改变默认值，就请定义它 color: 颜色, //只有当你想改变标题颜色的时候才需要 frame: &quot;边框文本&quot;, //只有当你想改变标头边框的时候才需要 width: 80, //表头的高度，以unit为单位 hideButton: true, //定义并设置为true则移除关闭按钮 &#125;, inventory: &#123;//要想定义标准背包，请使用inventory: &#123;standart: true&#125; width: 300, //背包窗口的宽度 padding: 20, //背包窗口的内边距 &#125;, background: &#123;//要定义一个默认背景，请使用background: &#123;standart: true&#125; color: 颜色, //如果你想改变背景的颜色就定义它 bitmap: &quot;背景图片&quot;, //如果你想添加一个背景图片就定义它 frame: &quot;边框贴图&quot; //如果你想添加一个边框就定义它 &#125;, minHeight: 650, //如果以unit为单位的窗口高度小于这个参数的值，那么窗口将自动转变为滚动窗口，以此来保证它的内部大小的高度为minHeight units &#125;, params: &#123; //自定义（改变默认材质） &#125;, drawing: [/*背景渲染指令*/], elements: &#123;/*元素的描述*/&#125;&#125; StandartWindow是适用性最高的窗口，在多人游戏中表现优于Window，但尽管如此绝对布局仍是其一大缺点，在实际使用时需要考虑到不同的屏幕尺寸会造成的控件偏移。因此，尽量将控件放置在屏幕内部区域 Window相较于StandartWindow，Window的优点在于其灵活性，与默认为方块互动界面的StandartWindow不同，Window可以通过修改WindowLocation来显示在游戏界面上的任意位置，且可以通过适当修改padding值来尽可能避免控件偏移。 Window默认没有关闭按钮和玩家背包栏，在使用时需要按需自行添加 WindowGroupStandartWindow和Window都是单个窗口，如果需要复杂的界面那么用多个窗口组合无疑是最最好的选择，将一个复杂窗口分为多个小窗口也可以提高调试效率。 WindowGroup的主要作用就是将多个Window整合在一起，将其组合布局在一起，例如现在的工作台界面就是一个包含3个Window的WindowGroup Hierarchic UI库HierarchicUI由Zheka开发，用于以json来定义分层式的UI，可以方便的创建绝对布局和线性布局，届时json会被解析为WindowGroup 此外，该库还可以定义视图布局并且对于一个视图可以灵活地嵌入到其他界面，并且基于它创建继承其全部属性的子视图，无疑让WindowGroup展示美观的复杂界面更加容易。","categories":[],"tags":[]}],"categories":[],"tags":[]}