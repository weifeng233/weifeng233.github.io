{"meta":{"title":"微风的博客","subtitle":"","description":"","author":"SugarBreeze","url":"https://weifeng233.github.io","root":"/"},"pages":[],"posts":[{"title":"半小时速通Rust","slug":"半小时速通Rust","date":"2024-02-16T19:20:11.922Z","updated":"2024-02-16T19:21:26.931Z","comments":true,"path":"2024/02/17/半小时速通Rust/","link":"","permalink":"https://weifeng233.github.io/2024/02/17/%E5%8D%8A%E5%B0%8F%E6%97%B6%E9%80%9F%E9%80%9ARust/","excerpt":"","text":"编程语言不学Rust，就如同游戏不玩原神 本文翻译自A half-hour to learn Rust letlet用于声明变量绑定(binding) 12let x; // 声明 xx = 42; // 将 42 赋值给 x 也可以写成一行： 1let x = 42; 可以通过:来显式指定变量类型，即类型注释： 1234let x: i32; // `i32` 为 32 位有符号整型x = 42;// 在Rust中，整型有 i8, i16, i32, i64, 128// 以及对应的无符号类型 u8, u16, u32, u64, u128 也可以写成一行： 1let x: i32 = 42; 如果你在声明变量后，初始化前使用变量，则会被编译器阻止： 123let x;foobar(x); // error: borrow of possibly-uninitialized variable: `x`x = 42; 这样则没问题： 123let x;x = 42;foobar(x); // `x` 的类型将会根据此处推断 下划线_是一个特殊的变量名称，即缺省名称。通常使用_说明丢弃一些东西： 123let _ = 42; // 将不会做任何事，因为 42 是一个常量let _ = get_thing(); // 调用 `get_thing` 但丢弃返回值 变量可以以下划线开头，除了编译器不会警告它们未被使用之外与普通变量名一样： 12// `_x` 可能最终会被用到，但是目前代码还没有完成，并且当前不想看到编译器对其的警告let _x = 42; 可以引入相同名称的变量绑定，进而隐藏原先的变量绑定： 123let x = 13;let x = x + 3;// 之后使用 `x` 仅指代第二个 `x`， 第一个 `x` 不再存在 Tuple元组(Tuple)可以将其视作不同类型值的定长集合： 123let pair = (&#x27;a&#x27;, 17);pair.0 // &#x27;a&#x27;pair.1 // 17 若要给元组添加类型注释，则可以： 1let pair: (char, i32) = (&#x27;a&#x27;, 17); 在进行赋值的时候元组可以被解构，即可以分解为独立的字段： 1let (some_char, some_int) = (&#x27;a&#x27;, 17); 在函数返回元组时非常有用： 1let (left, right) = slice.split_at(middle); 当然，在结构元组的时候也可以使用_来丢弃其中一部分： 1let (_, right) = slice.split_at(middle); 语句和表达式分号标志着语句的结束： 123let x = 3;let y = 5;let z = x + y; 这意味着语句可以跨越多行： 1234let x = vec![1, 2, 3, 4, 5, 6, 7, 8] .iter() .map(|x| x + 3) .fold(0, |x, y| x + y); （后文会对其作讲解） fnfn用于声明函数这是一个无返回值的函数： 123fn greet() &#123; println!(&quot;Hi there!&quot;);&#125; 这是一个返回 32 位有符号整型的函数。用箭头来表示其返回值类型： 123fn fair_dice_roll() -&gt; i32 &#123; 4&#125; 花括号对&#123;&#125;用于声明块(Block)，它有自己的作用域： 12345678910// 该程序会先输出 &quot;in&quot; 然后是 &quot;out&quot;fn main() &#123; let x = &quot;out&quot;; &#123; // 此处是另一个 `x` let x = &quot;in&quot;; println!(&quot;&#123;&#125;&quot;, x); &#125; println!(&quot;&#123;&#125;&quot;, x);&#125; 块也是表达式，这意味着其计算结果也是一个值。 123// 以下两行是等价的let x = 42;let x = &#123; 42 &#125;; 在一个块内可以有多条语句： 12345let x = &#123; let y = 1; // 第一条语句 let z = 2; // 第二条语句 y + z // 这里是*尾巴* - 整个块会被认定的表达式&#125;; 这就是为什么”省略函数末尾的分号“与return是相同的，即以下写法是等效的： 1234567fn fair_dice_roll() -&gt; i32 &#123; return 4;&#125;fn fair_dice_roll() -&gt; i32 &#123; 4&#125; if 条件也是表达式： 1234567fn fair_dice_roll() -&gt; i32 &#123; if feeling_lucky &#123; 6 &#125; else &#123; 4 &#125;&#125; match也是表达式： 123456fn fair_dice_roll() -&gt; i32 &#123; match feeling_lucky &#123; true =&gt; 6, false =&gt; 4, &#125;&#125; 表达式总会返回值，能返回值的就是表达式，表达式不能以分号结尾，否则就变成了语句，不再返回值，若表达式不返回值，则会隐式地返回一个()。点.通常用于访问值的字段： 12345let a = (10, 20);a.0; // 10let amos = get_some_struct();amos.nickname; // &quot;fasterthanlime&quot; 或者对值调用方法： 12let nick = &quot;fasterthanlime&quot;;nick.len(); // 14 双冒号::与其类似，但是它使用在命名空间上。在此示例中，std是一个包(crate)（或者说库），cmp是一个模块(module)（或者说源文件），以及min是一个函数(function)： 1let least = std::cmp::min(3, 8); // 3 use可用于从其他命名空间引入名称到作用域： 123use std::cmp::min;let least = min(7, 1); // 1 使用use时，花括号还有另一种含义，即 glob。如果我们想同时导入min和max，我们可以使用以下任意一种方式： 123456use std::cmp::min;use std::cmp::max;use std::cmp::&#123;min, max&#125;;use std::&#123;cmp::min, cmp::max&#125;; 通配符*允许你从命名空间导入所有符号： 12// 这将会将 `min` 和 `max` 以及许多其他东西导入到当前作用域use std::cmp::*; 类型也是命名空间，方法可以作为常规函数调用： 12let x = &quot;amos&quot;.len(); // 4let x = str::len(&quot;amos&quot;); // 4 str是原始类型，但默认情况下许多非原始类型也包含在作用域内： 12345// `Vec` 是一个常规的结构体，不是原始类型let v = Vec::new();// 与上面的代码相同，但是使用了 `Vec` 的完整路径let v = std::vec::Vec::new(); 这之所以有效是因为 Rust 会在每个模块的开头插入以下代码： 1use std::prelude::v1::*; 这会重新导出很多符号，例如Vec，String，Option和Result。 struct结构体使用struct关键字声明： 1234struct Vec2 &#123; x: f64, // 64 位浮点数，即双精度 y: f64,&#125; 它们可以通过结构体字面量初始化： 123let v1 = Vec2 &#123; x: 1.0, y: 3.0&#125;;let v2 = Vec2 &#123; y: 2.0, x: 4.0&#125;;// 顺序不需要关注，只需要关注名称 有一种简便写法可以从另一个结构体初始化剩余的字段： 1234let v3 = Vec2 &#123; x: 14.0, ..v2&#125; 这被称为”结构体更新语法“，只能用在最后一个位置，且后面不能跟逗号。注意，其余字段可以表示所有字段： 1let v4 = Vec2 &#123; ..v3 &#125;; 模式结构体与元组一样，可以被解构。就和以下是一个有效的let模式一样： 1let (left, right) slice.split_at(middle); 以下也是如此： 123let v = Vec2 &#123; x: 3.0, y: 6.0&#125;;let Vec2 &#123; x, y &#125; = v;// `x` 为 3.0， `y` 为 6.0 以及这样： 12let Vec2 &#123; x, ..&#125; = v;// 将会忽略 `v.y` 模式是 Rust 中的特殊语法，它用来匹配类型中的结构和数据，它往往和 match 表达式联用，以实现强大的模式匹配能力。模式一般由以下内容组合而成： 字面值 解构的数组、枚举、结构体或者元组 变量 通配符 占位符let模式可以用作if的条件：1234567891011121314151617181920212223struct Number &#123; odd: bool, value: i32,&#125;fn main() &#123; let one = Number &#123; odd: true, value: 1 &#125;; let two = Number &#123; odd: false, value: 2 &#125;; print_number(one); print_number(two);&#125;fn print_number(n: Number) &#123; if let Number &#123; odd: true, value &#125; = n &#123; println!(&quot;Odd number: &#123;&#125;&quot;, value); &#125; else if let Number &#123; odd: false, value &#125; = n &#123; println!(&quot;Even number: &#123;&#125;&quot;, value); &#125;&#125;// 将会输出：// Odd number: 1// Even number: 2 match分支同样同于模式，就像if let：12345678fn print_number(n: Number) &#123; match n &#123; Number &#123; odd: true, value &#125; =&gt; println!(&quot;Odd number: &#123;&#125;&quot;, value), Number &#123; odd: false, value &#125; =&gt; println!(&quot;Even number: &#123;&#125;&quot;, value), &#125;&#125;// 输出与之前相同 match是穷尽式的，即至少有一个分支被匹配。12345678fn print_number(n: Number) &#123; match n &#123; Number &#123; value: 1, .. &#125; =&gt; println!(&quot;One&quot;), Number &#123; value: 2, .. &#125; =&gt; println!(&quot;Two&quot;), Number &#123; value, .. &#125; =&gt; println!(&quot;&#123;&#125;&quot;, value), // 如果最后一个分支不存在，那么编译器将会报错 &#125;&#125; 如果很难做到匹配所有分支，那么则可以使用_来匹配所有剩余的情况：1234567fn print_number(n: Number) &#123; match n.value &#123; 1 =&gt; println!(&quot;One&quot;), 2 =&gt; println!(&quot;Two&quot;), _ =&gt; println!(&quot;&#123;&#125;&quot;, n.value), &#125;&#125; 你可以在自己的类型上声明方法：12345678910struct Number &#123; odd: bool, value: i32,&#125;impl Number &#123; fn is_strictly_positive(self) -&gt; bool &#123; self.value &gt; 0 &#125;&#125; 并像通常一样使用它们：12345678fn main() &#123; let minus_two = Number &#123; odd: false, value: -2, &#125;; println!(&quot;positive? &#123;&#125;&quot;, minus_two.is_strictly_positive()); // 输出 &quot;positive? false&quot;&#125; mut默认情况下，变量绑定是不可变的，这意味着它们的内部状态不能被改变：12345678fn main() &#123; let n = Number &#123; odd: true, value: 17, &#125;; n.odd = false; // error: cannot assign to `n.odd`, // as `n` is not declared to be mutable&#125; 同时它们也不能被重新赋值：12345678910fn main() &#123; let n = Number &#123; odd: true, value: 17, &#125;; n = Number &#123; odd: false, value: 22, &#125;; // error: cannot assign twice to immutable variable `n`&#125; mut可使变量绑定可变：1234567fn main() &#123; let mut n = Number &#123; odd: true, value: 17, &#125; n.value = 19; // 一切顺利&#125; 特征特征(trait)是指多种类型可以共有的共同点：123trait Signed &#123; fn is_strictly_negative(self) -&gt; bool;&#125; 你可以实现： 对任何人的类型使用你的特征 将任何人的特征用于你的类型 不能将外来特征用于外来类型这被称作孤儿规则(orphan rules)，更为规范的定义是如果你想要为类型 A 实现特征 T，那么 A 或者 T 至少有一个是在当前作用域中定义的。这是一个将我们的特征用在我们的类型上的实现：12345678910impl Signed for Number &#123; fn is_strictly_negative(self) -&gt; bool &#123; self.value &lt; 0 &#125;&#125;fn main() &#123; let n = Number &#123; odd: false, value: -44 &#125;; println!(&quot;&#123;&#125;&quot;, n.is_strictly_negative()); // 输出 &quot;true&quot;&#125; 将我们的特征用在外来类型（甚至是原始类型）上：12345678910impl Signed for i32 &#123; fn is_strictly_negative(self) -&gt; bool &#123; self &lt; 0 &#125;&#125;fn main() &#123; let n: i32 = -44; println!(&quot;&#123;&#125;&quot;, n.is_strictly_negative()); // 输出 &quot;true&quot;&#125; 将外来特征用在我们的类型上：1234567891011121314151617// `Neg` 特征用于重载 `-`，即一元减运算符impl std::ops::Neg for Number &#123; type Output = Number; fn neg(self) -&gt; Number &#123; Number &#123; value: -self.value, odd: self.odd, &#125; &#125;&#125;fn main() &#123; let n = Number &#123; odd: true, value: 987 &#125;; let m = -n; // 因为我们实现了 `Neg` 所以可以这样做 println!(&quot;&#123;&#125;&quot;, m.value); // 输出 &quot;-987&quot;&#125; 一个impl块使用代表一种类型，所以在该块里Self表示该类型：12345678910impl std::ops::Neg for Number &#123; type Output = Self; fn neg(self) -&gt; Self &#123; Self &#123; value: -self.value, odd: self.odd, &#125; &#125;&#125; 有一些特征是标记(marker)，它们并不是指该类型实现了某些方法，而是指可以用该类型完成某些事情。例如，i32实现了特征Copy（简单说i32是Copy），所以以下是可行的：12345fn main() &#123; let a: i32 = 15; let b = a; // `a` 被复制 let c = a; // `a` 再次被复制&#125; 同时以下也可行：123456789fn print_i32(x: i32) &#123; println!(&quot;x = &#123;&#125;&quot;, x);&#125;fn main() &#123; let a: i32 = 15; print_i32(a); // `a` 被复制 print_i32(a); // `a` 再次被复制&#125; 但是Number结构体不是Copy，所以以下是不可行的：123456fn main() &#123; let n = Number &#123; odd: true, value: 51 &#125;; let m = n; // `n` 被移动至 `m` let o = n; // error: use of moved value: `n` // 因为试图使用一个已经被移动过的值而报错&#125; 以下也是如此：123456789fn print_number(n: Number) &#123; println!(&quot;&#123;&#125; number &#123;&#125;&quot;, if n.odd &#123; &quot;odd&quot; &#125; else &#123; &quot;even&quot; &#125;, n.value);&#125;fn main() &#123; let n = Number &#123; odd: true, value: 51 &#125;; print_number(n); // `n` 被移动 print_number(n); // error: use of moved value: `n`&#125; 但是如果print_number使用不可变引用，那么它就可以工作：123456789fn print_number(n: &amp;Number) &#123; println!(&quot;&#123;&#125; number &#123;&#125;&quot;, if n.odd &#123; &quot;odd&quot; &#125; else &#123; &quot;even&quot; &#125;, n.value);&#125;fn main() &#123; let n = Number &#123; odd: true, value: 51 &#125;; print_number(&amp;n); // `n` 被引用给这次调用 print_number(&amp;n); // `n` 再次被引用&#125; 如果函数采用可变引用，那么也可以工作，前提是我们的变量绑定也是mut。123456789101112131415fn invert(n: &amp;mut Number) &#123; n.value = -n.value;&#125;fn print_number(n: &amp;Number) &#123; println!(&quot;&#123;&#125; number &#123;&#125;&quot;, if n.odd &#123; &quot;odd&quot; &#125; else &#123; &quot;even&quot; &#125;, n.value);&#125;fn main() &#123; // 这一次 `n` 是可变的 let mut n = Number &#123; odd: true, value: 51 &#125;; print_number(&amp;n); invert(&amp;mut n); // `n 被可变引用，一切都是明确的 print_number(&amp;n);&#125; 特征方法还可以通过引用或者可变引用获取self：12345impl std::clone::Clone for Number &#123; fn clone(&amp;self) -&gt; Self &#123; Self &#123; ..*self &#125; &#125;&#125; 当调用特征方法时，接受者被隐式引用：12345678fn main() &#123; let n = Number &#123; odd: true, value: 51 &#125;; let mut m = n.clone(); m.value += 100; print_number(&amp;n); print_number(&amp;m);&#125; 为了强调这一点，以下写法是等效的：123let m = n.clone();let m = std::clone::Clone::clone(&amp;n); 像Copy这样的标记特征没有方法：123456// 注意：`Copy` 需要 `Clone` 也被实现impl std::clone::Clone for Number &#123; fn clone(&amp;self) -&gt; Self &#123; Self &#123; ..*self &#125; &#125;&#125; 现在Clone仍然可以被使用：12345fn main() &#123; let n = Number &#123; odd: true, value: 51 &#125;; let m = n.clone(); let o = n.clone();&#125; 但是Number的值不会再被移动：12345fn main() &#123; let n = Number &#123; odd: trie, value: 51 &#125;; let m = n; // `m` 是 `n` 的一个拷贝 let o = n; // 同样，`n` 不再会被移动或引用&#125; 有些特征非常常见，可以使用derive属性自动实现：1234567#[derive(Clone, Copy)]struct Number &#123; odd: bool, value: i32,&#125;// 这将会展开成 `impl Clone for Number` 和 `impl Copy for Number` 块 泛型(Generics)函数可以是泛型化的：123fn foobar&lt;T&gt;(arg: T) &#123; // 与 `arg` 相关的操作&#125; 它们可以有多个类型参数，然后可以在函数的声明及其主体中使用这些参数，而不是具体类型：123fn foobar&lt;L, R&gt;(left: L, right: R) &#123; // 与 `left` 和 `right` 相关的操作&#125; 类型参数通常由约束(constraint)，所以实际上你可以用它们来做一些事情。最简单的约束是特征名称：1234567fn print&lt;T: Display&gt;(value: T) &#123; println!(&quot;value = &#123;&#125;&quot;, value);&#125;fn print&lt;T: Debug&gt;(value: T) &#123; println!(&quot;value = &#123;:?&#125;&quot;, value);&#125; 类型参数约束由一种更长的语法：123456fn print&lt;T&gt;(value: T)where T: Display,&#123; println!(&quot;value = &#123;&#125;&quot;, value);&#125; 约束可以更复杂：它们可能需要类型参数实现多个特征：12345678910111213use std::fmt::Debug;fn compare&lt;T&gt;(left: T, right: T)where T:Debug + PartialEq,&#123; println!(&quot;&#123;:?&#125; &#123;&#125; &#123;:?&#125;&quot;, left, if left == right &#123; &quot;==&quot; &#125; else &#123; &quot;!=&quot; &#125;, right);&#125;fn main() &#123; compare(&quot;tea&quot;, &quot;coffee&quot;); // 输出 &quot;tea != coffee&quot;&#125; 泛型函数可以被认为是命名空间，包含无穷个具有不同具体类型的函数。与包，模块和类型相同，可以对泛型函数使用::12345fn main() &#123; use std::any::type_name; println!(&quot;&#123;&#125;&quot;, type_name::&lt;i32&gt;()); // 输出 &quot;i32&quot; println!(&quot;&#123;&#125;&quot;, type_name::&lt;(f64, char)&gt;()); // 输出 &quot;(f64, char)&quot;&#125; 这被亲切地称为 turbofish 语法，因为::&lt;&gt;看起来像一条鱼。结构也可以泛型化：123456789101112131415struct Pair&lt;T&gt; &#123; a: T, b: T,&#125;fn print_type_name&lt;T&gt;(_val: &amp;T) &#123; println!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;());&#125;fn main() &#123; let p1 = Pair &#123; a: 3, b: 9&#125;; let p2 = Pair &#123; a: true, b: false&#125;; print_type_name(&amp;p1); print_type_name(&amp;p2);&#125; 标准库类型Vec（或者说堆分配的数组）是泛型化的：12345678fn main() &#123; let mut v1 = Vec::new(); v1.push(1); let mut v2 = Vec::new(); v2.push(false); print_type_name(&amp;v1); // prints &quot;Vec&lt;i32&gt;&quot; print_type_name(&amp;v2); // prints &quot;Vec&lt;bool&gt;&quot;&#125; 宏说到Vec，它带有一个宏，可以提供或多或少的”vec 字面量“：123456fn main() &#123; let v1 = vec![1, 2, 3]; let v2 = vec![true, false, true]; print_type_name(&amp;v1); print_type_name(&amp;v2);&#125; 所有的name!()，name![]和name!&#123;&#125;都会调用宏。宏只是展开成常规代码。实际上println是一个宏：123fn main() &#123; println!(&quot;&#123;&#125;&quot;, &quot;Hello there!&quot;);&#125; 这会展开成具有相同效果的东西：1234fn main() &#123; use std::io::&#123;self, Write&#125;; io::stdout().lock().write_all(b&quot;Hello there!\\n&quot;).unwrap();&#125; panic也是一个宏，它会猛烈地停止执行并显示错误消息和文件名 / 行号：123fn main() &#123; panic!(&quot;This panics&quot;);&#125; 有些方法也会出现panic。例如，Option类型可以包含某些内容，也可以不包含任何内容。如果.unwrap()被调用，并且它不包括任何内容，那么就会发生panic：123456789fn main() &#123; let o1: Option&lt;i32&gt; = Some(128); o1.unwrap(); // this is fine let o2: Option&lt;i32&gt; = None; o2.unwrap(); // this panics!&#125;// output: thread &#x27;main&#x27; panicked at &#x27;called `Option::unwrap()` on a `None` value&#x27;, src/libcore/option.rs:378:21 Option不是一个结构体，它是一个枚举(enum)，有两个成员：1234567891011121314151617181920212223242526num Option&lt;T&gt; &#123; None, Some(T),&#125;impl&lt;T&gt; Option&lt;T&gt; &#123; fn unwrap(self) -&gt; T &#123; // 枚举成员可以被用在模式中： match self &#123; Self::Some(t) =&gt; t, Self::None =&gt; panic!(&quot;.unwrap() called on a None option&quot;), &#125; &#125;&#125;use self::Option::&#123;None, Some&#125;;fn main() &#123; let o1: Option&lt;i32&gt; = Some(128); o1.unwrap(); // this is fine let o2: Option&lt;i32&gt; = None; o2.unwrap(); // this panics!&#125;// output: thread &#x27;main&#x27; panicked at &#x27;.unwrap() called on a None option&#x27;, src/main.rs:11:27 Result也是一个枚举，它可以包含某些内容，也可以包含错误：1234enum Result&lt;T, E&gt; &#123; Ok(T), Err(E),&#125; 若调用unwrap时包含错误，那么它也会panic。变量绑定变量绑定拥有一个”生命周期“：123456789fn main() &#123; // `x` 还不存在 &#123; let x = 42; // `x` 开始存在 println!(&quot;x = &#123;&#125;&quot;, x); // `x` 停止存在 &#125; // `x` 不再存在&#125; 同样，引用也有生命周期：1234567891011fn main() &#123; // `x` 还不存在 &#123; let x = 42; // `x` 开始存在 let x_ref = &amp;x; // `x_ref` 开始存在 - 它引用 `x` println!(&quot;x_ref = &#123;&#125;&quot;, x_ref); // `x_ref` 停止存在 // `x` 停止存在 &#125; // `x` 不再存在&#125; 引用的生命周期不能超过它引用的变量绑定的生命周期：12345678fn main() &#123; let x_ref = &#123; let x = 42; &amp;x &#125;; println!(&quot;x_ref = &#123;&#125;&quot;, x_ref); // error: `x` does not live long enough&#125; 变量绑定可以不可变地被多次引用：1234567fn main() &#123; let x = 42; let x_ref1 = &amp;x; let x_ref2 = &amp;x; let x_ref3 = &amp;x; println!(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, x_ref1, x_ref2, x_ref3);&#125; 当被引用时，变量绑定不能改变：1234567fn main() &#123; let mut x = 42; let x_ref = &amp;x; x = 13; println!(&quot;x_ref = &#123;&#125;&quot;, x_ref); // error: cannot assign to `x` because it is borrowed&#125; 当被不可变引用时，变量不能被可变引用：1234567fn main() &#123; let mut x = 42; let x_ref1 = &amp;x; let x_ref2 = &amp;mut x; // error: cannot borrow `x` as mutable because it is also borrowed as immutable println!(&quot;x_ref1 = &#123;&#125;&quot;, x_ref1);&#125; 函数参数中的引用也有生命周期：123fn print(x: &amp;i32) &#123; // `x` 是从外部被引用的，可用在该次函数调用的全过程&#125; 具有引用参数的函数可以通过具有不同声明周期的引用来调用，因此： 所有接受引用的函数都是泛型化的 生命周期是泛型参数生命周期的参数以单引号&#39;开头：12345// 隐式（匿名）生命周期fn print(x: &amp;i32) &#123;&#125;// 命名生命周期fn print&lt;&#x27;a&gt;(x: &amp;&#x27;a i32) &#123;&#125; 使返回的引用的生命周期取决于参数的生命周期：1234567891011121314struct Number &#123; value: i32,&#125;fn number_value&lt;&#x27;a&gt;(num: &amp;&#x27;a Number) -&gt; &amp;&#x27;a i32 &#123; &amp;num.value&#125;fn main() &#123; let n = Number &#123; value: 47 &#125;; let v = number_value(&amp;n); // `v` 是 `n` 的不可变引用，因此 `v` 的生命周期不能超过 `n`. // 当 `v` 存在时，`n` 不能被可变引用，改变，移动等&#125; 当只有一个生命周期输入时，不需要命名，所有变量都具有相同的生命周期，因此以下两个函数是等效的：1234567fn number_value&lt;&#x27;a&gt;(num: &amp;&#x27;a Number) -&gt; &amp;&#x27;a i32 &#123; &amp;num.value&#125;fn number_value(num: &amp;Number) -&gt; &amp;i32 &#123; &amp;num.value&#125; 结构体也可以使用生命周期泛型，使其可以保存引用： 123456789struct NumRef&lt;&#x27;a&gt; &#123; x: &amp;&#x27;a i32,&#125;fn main() &#123; let x: i32 = 99; let x_ref = NumRef &#123; x: &amp;x &#125;; // `x_ref` 的生命周期不能长于 `x`&#125; 增加个相关函数： 12345678910111213struct NumRef&lt;&#x27;a&gt; &#123; x: &amp;&#x27;a i32,&#125;fn as_num_ref&lt;&#x27;a&gt;(x: &amp;&#x27;a i32) -&gt; NumRef&lt;&#x27;a&gt; &#123; NumRef &#123; x: &amp;x &#125;&#125;fn main() &#123; let x: i32 = 99; let x_ref = NumRef &#123; x: &amp;x &#125;; // `x_ref` 的生命周期不能长于 `x`&#125; 在函数中省写生命周期： 12345678910111213struct NumRef&lt;&#x27;a&gt; &#123; x: &amp;&#x27;a i32,&#125;fn as_num_ref(x: &amp;i32) -&gt; NumRef&lt;&#x27;_&gt; &#123; NumRef &#123; x: &amp;x &#125;&#125;fn main() &#123; let x: i32 = 99; let x_ref = NumRef &#123; x: &amp;x &#125;; // `x_ref` 的生命周期不能长于 `x`&#125; impl块也可以这样操作： 123456789101112impl&lt;&#x27;a&gt; NumRef&lt;&#x27;a&gt; &#123; fn as_i32_ref(&amp;&#x27;a self) -&gt; &amp;&#x27;a i32 &#123; self.x &#125;&#125;fn main() &#123; let x: i32 = 99; let x_num_ref = NumRef &#123; x: &amp;x &#125;; let x_i32_ref = x_num_ref.as_i32_ref(); // 引用的生命周期都不能长于 `x`&#125; 你也可以这样省写： 12345impl&lt;&#x27;a&gt; NumRef&lt;&#x27;a&gt; &#123; fn as_i32_ref(&amp;self) -&gt; &amp;i32 &#123; self.x &#125;&#125; 如果你不需要用到变量名，那可以更简单： 12345impl NumRef&lt;&#x27;_&gt; &#123; fn as_i32_ref(&amp;self) -&gt; &amp;i32 &#123; self.x &#125;&#125; 有一个特殊的生命周期，即静态&#39;static，代表在整个程序的生命周期中都保持有效。字符串字面量是&#39;static的： 123456789struct Person &#123; name: &amp;&#x27;static str,&#125;fn main() &#123; let p = Person &#123; name: &quot;fasterthanlime&quot; &#125;;&#125; 但是持有字符串(owned string)不是静态的： 123456789struct Person &#123; name: &amp;&#x27;static str,&#125;fn main() &#123; let name = format!(&quot;fasterthan&#123;&#125;&quot;, &quot;lime&quot;); let p = Person &#123; name: &amp;name &#125;; // error: `name` does not live long enough&#125; 在上面的示例中，name不是&amp;&#39;static str而是String。它是被动态分配并且会被释放的，即其生命周期小于整个程序（即使其恰好位于main中）如果要将非&#39;static字符串存储在Person中，有以下两种方法：A. 使用生命周期泛型： 123456789struct Person&lt;&#x27;a&gt; &#123; name: &amp;&#x27;a str,&#125;fn main() &#123; let name = format!(&quot;fasterthan&#123;&#125;&quot;, &quot;lime&quot;); let p = Person &#123; name: &amp;name &#125;; // `p` 的生命周期不能长于 `name`&#125; B. 获取字符串的所有权 123456789struct Person &#123; name: String,&#125;fn main() &#123; let name = format!(&quot;faterthan&#123;&#125;&quot;, &quot;lime&quot;); let p = Person &#123; name: name &#125;; // `name` 被移动到 `p`，它们的生命周期不再被限制&#125; 另外，在结构体字面量中，如果即将字段设置为同名的变量绑定时，可以简写： 123let p = Person &#123; name: name &#125;;// 可悲简写为let p = Person &#123; name &#125;; 对于 Rust 中的许多类型，都有所有权(owned)和无所有权(non-owned)两种变体： 字符串：String 是有所有权的，&amp;str 是引用 路径：PathBuf 是有所有权的，&amp;Path 是引用 集合：Vec&lt;T&gt; 是有所有权的，&amp;[T] 是引用在 Rust 中，所有权有以下规则： Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)切片切片(slice)是对多个连续元素的引用。你可以引用一个向量的切片，例如：12345678fn main() &#123; let v = vec![1, 2, 3, 4, 5]; let v2 = &amp;v[2..4]; println!(&quot;v2 = &#123;:?&#125;&quot;, v2);&#125;// 输出：// v2 = [3, 4] 上面的操作并不神奇。索引操作符foo[index]重载了Index和IndexMut特征。..语法只是范围(range)字面量，范围是标准库中定义的结构体。切片区间可以是开放的，右边界可以是闭的，如果前面有=的话。12345678910fn main() &#123; // 大于等于 0 println!(&quot;&#123;:?&#125;&quot;, (0..).contains(&amp;100)); // true // 严格小于 20 println!(&quot;&#123;:?&#125;&quot;, (..20).contains(&amp;20)); // false // 小于等于 0 println!(&quot;&#123;:?&#125;&quot;, (..=20).contains(&amp;20)); // true // 只包含 3, 4, 5 println!(&quot;&#123;:?&#125;&quot;, (3..6).contions(&amp;4)); // true&#125; 引用规则同样适用于切片：123456789fn tail(s: &amp;[u8]) -&gt; &amp;[u8] &#123; &amp;s[1..]&#125;fn main() &#123; let x = &amp;[1, 2, 3, 4, 5]; let y = tail(x); println!(&quot;y = &#123;:?&#125;&quot;, y);&#125; 一样地，tail函数也可以这样写：123fn tail&lt;&#x27;a&gt;(s: &amp;&#x27;a [u8]) -&gt; &amp;&#x27;a [u8] &#123; &amp;s[1..]&#125; 以下代码是合规的：1234567fn main() &#123; let y = &#123; let x = &amp;[1, 2, 3, 4, 5]; tail(x) &#125;; println!(&quot;y = &#123;:?&#125;&quot;, y);&#125; 但这只是因为&amp;[1, 2, 3, 4, 5]是一个&#39;static数组。所以以下是不可行的：12345678fn main() &#123; let y = &#123; let v = vec![1, 2, 3, 4, 5]; tail(&amp;v); //error: `v` does not live long enough &#125;; println!(&quot;y = &#123;:?&#125;&quot;, y);&#125; 这是因为向量是堆分配的(heap-allocated)，并且它的生命周期不是&#39;static&amp;str值实际上是切片。1234567891011121314fn file_ext(name: &amp;str) -&gt; Option&lt;&amp;str&gt; &#123; // 这不会返回一个新的字符串 // 而是返回参数的一个切片 name.split(&quot;.&quot;).last()&#125;fn main() &#123; let name = &quot;Read me. Or don&#x27;t.txt&quot;; if let Some(ext) = file_ext(name) &#123; println!(&quot;file extension: &#123;&#125;&quot;, ext); &#125; else &#123; println!(&quot;no file extension&quot;); &#125;&#125; 所以引用规则也同样适用：12345678fn main() &#123; let ext = &#123; let name = String::from(&quot;Read me. Or don&#x27;t.txt&quot;); file_ext(&amp;name).unwarp_or(&quot;&quot;) // error: `name` does not live long enough &#125;; println!(&quot;extension: &#123;:?&#125;&quot;, ext);&#125; Result可能会出错的函数通常会返回Result：123456789fn main() &#123; let s = std::str::from_utf8(&amp;[240, 159, 141, 137]); println!(&quot;&#123;:?&#125;&quot;, s); // 输出：Ok(&quot;🍉&quot;) let s = std::str::from_utf8(&amp;[195, 40]); println!(&quot;&#123;:?&#125;&quot;, s); // 输出：Err(Utf8Error &#123; valid_up_to: 0, error_len: Some(1) &#125;)&#125; 如果你想在出错的时候panic，则可以使用.unwarp()：12345678910fn main() &#123; let s = std::str::from_utf8(&amp;[240, 159, 141, 137]).unwrap(); println!(&quot;&#123;:?&#125;&quot;, s); // 输出：&quot;🍉&quot; let s = std::str::from_utf8(&amp;[195, 40]).unwrap(); // 输出：thread &#x27;main&#x27; panicked at &#x27;called `Result::unwrap()` // on an `Err` value: Utf8Error &#123; valid_up_to: 0, error_len: Some(1) &#125;&#x27;, // src/libcore/result.rs:1165:5&#125; 或者expect()，用来自定义报错消息：12345fn main() &#123; let s = std::str::from_utf8(&amp;[195, 40]).expect(&quot;valid utf-8&quot;); // 输出：thread &#x27;main&#x27; panicked at &#x27;valid utf-8: Utf8Error // &#123; valid_up_to: 0, error_len: Some(1) &#125;&#x27;, src/libcore/result.rs:1165:5&#125; 或者你可以使用match：1234567fn main() &#123; match std::str::from_utf8(&amp;[240, 159, 141, 137]) &#123; Ok(s) =&gt; println!(&quot;&#123;&#125;&quot;, s). Err(e) =&gt; println!(e), &#125; // 输出：🍉&#125; 或者使用if let：123456fn main() &#123; if let Ok(s) = std::std::from_utf8(&amp;[240, 159, 141, 137]) &#123; println!(&quot;&#123;&#125;&quot;, s); &#125; // 输出：🍉&#125; 或者你可以将错误提升出来：1234567fn main() -&gt; Result&lt;(), std::str::Utf8Error&gt; &#123; match std::str::from_utf8(&amp;[240, 159, 141, 137]) &#123; Ok(s) =&gt; println!(&quot;&#123;&#125;&quot;, s), Err(e) =&gt; return Err(e), &#125; Ok(())&#125; 你可以使用?来以更简洁的方式完成此操作：12345fn main() -&gt; Result&lt;(), std::str::Utf8Error&gt; &#123; let s = std::str::from_utf8(&amp;[240, 159, 141, 137])?; println!(&quot;&#123;&#125;&quot;, s); Ok(())&#125; *运算符可用于取消引用(dereference)，但是你在访问字段和调用方法的时候并不需要用到：123456789101112struct Point &#123; x: f64, y: f64,&#125;fn main() &#123; let p = Point &#123; x: 1.0, y: 3.0 &#125;; let p_ref = &amp;p; println!(&quot;(&#123;&#125;, &#123;&#125;)&quot;, p_ref.x, p_ref.y);&#125;// 输出 `(1, 3)` 只有当类型为Copy的时候才能这样操作：123456789101112131415161718struct Point &#123; x: f64, y: f64,&#125;fn negate(p: Point) -&gt; Point &#123; Point &#123; x: -p.x, y: -p.y, &#125;&#125;fn main() &#123; let p = Point &#123; x: 1.0, y: 3.0 &#125;; let p_ref = &amp;p; negate(*p_ref); // error: cannot move out of `*p_ref` which is behind a shared reference&#125; 12345678910111213141516171819// 现在 `Point` 是 `Copy`#[derive(Clone, Copy)]struct Point &#123; x: f64, y: f64,&#125;fn negate(p: Point) -&gt; Point &#123; Point &#123; x: -p.x, y: -p.y, &#125;&#125;fn main() &#123; let p = Point &#123; x: 1.0, y: 3.0 &#125;; let p_ref = &amp;p; negate(*p_ref); // 并且现在不会报错了&#125; 闭包闭包(closure)只是Fn，FnMut和FnOnce类型的函数加上捕获传递的上下文。它们的参数是被一对管道(|)包括，用逗号分隔的。它们不需要花括号，除非你需要多条语句。 12345678910111213141516fn for_each_planet&lt;F&gt;(f: F) where F: Fn(&amp;&#x27;static str)&#123; f(&quot;Earth&quot;); f(&quot;Mars&quot;); f(&quot;Jupiter&quot;);&#125; fn main() &#123; for_each_planet(|planet| println!(&quot;Hello, &#123;&#125;&quot;, planet));&#125;// 输出：// Hello, Earth// Hello, Mars// Hello, Jupiter 引用规则同样适用： 12345678910111213fn for_each_planet&lt;F&gt;(f: F) where F: Fn(&amp;&#x27;static str)&#123; f(&quot;Earth&quot;); f(&quot;Mars&quot;); f(&quot;Jupiter&quot;);&#125; fn main() &#123; let greeting = String::from(&quot;Good to see you&quot;); for_each_planet(|planet| println!(&quot;&#123;&#125;, &#123;&#125;&quot;, greeting, planet)); // 我们的闭包引用了 `greeting`，所以其生命周期不能长于它&#125; 例如以下是无法工作的： 1234567891011121314fn for_each_planet&lt;F&gt;(f: F) where F: Fn(&amp;&#x27;static str) + &#x27;static // `F` 必须是 &quot;&#x27;static&quot; 生命周期&#123; f(&quot;Earth&quot;); f(&quot;Mars&quot;); f(&quot;Jupiter&quot;);&#125;fn main() &#123; let greeting = String::from(&quot;Good to see you&quot;); for_each_planet(|planet| println!(&quot;&#123;&#125;, &#123;&#125;&quot;, greeting, planet)); // error: closure may outlive the current function, but it borrows // `greeting`, which is owned by the current function&#125; 但是这样可以： 12345fn main() &#123; let greeting = String::from(&quot;You&#x27;re doing great&quot;); for_each_planet(move |planet| println!(&quot;&#123;&#125;, &#123;&#125;&quot;, greeting, planet)); // `greeting` 不再被引用，它被移动到该闭包&#125; FnMut需要被可变引用才能被调用，因此一次传参只能调用一次。以下是可行的： 1234567891011fn foobar&lt;F&gt;(f: F) where F: Fn(i32) -&gt; i32&#123; println!(&quot;&#123;&#125;&quot;, f(f(2))); &#125; fn main() &#123; foobar(|x| x * 2);&#125;// 输出：8 但以下不能： 12345678910fn foobar&lt;F&gt;(mut f: F) where F: FnMut(i32) -&gt; i32&#123; println!(&quot;&#123;&#125;&quot;, f(f(2))); // error: cannot borrow `f` as mutable more than once at a time&#125; fn main() &#123; foobar(|x| x * 2);&#125; 这样则可行： 123456789101112fn foobar&lt;F&gt;(mut f: F) where F: FnMut(i32) -&gt; i32&#123; let tmp = f(2); println!(&quot;&#123;&#125;&quot;, f(tmp)); &#125; fn main() &#123; foobar(|x| x * 2);&#125;// 输出：8 FnMut的存在是因为某些闭包会可变引用本地变量： 12345678910111213141516fn foobar&lt;F&gt;(mut f: F) where F: FnMut(i32) -&gt; i32&#123; let tmp = f(2); println!(&quot;&#123;&#125;&quot;, f(tmp)); &#125; fn main() &#123; let mut acc = 2; foobar(|x| &#123; acc += 1; x * acc &#125;);&#125;// 输出：24 这些闭包不能传递给需要Fn的函数： 1234567891011121314151617fn foobar&lt;F&gt;(f: F) where F: Fn(i32) -&gt; i32&#123; println!(&quot;&#123;&#125;&quot;, f(f(2))); &#125; fn main() &#123; let mut acc = 2; foobar(|x| &#123; acc += 1; // error: cannot assign to `acc`, as it is a // captured variable in a `Fn` closure. // the compiler suggests &quot;changing foobar // to accept closures that implement `FnMut`&quot; x * acc &#125;);&#125; FnOnce闭包只能调用一次。它们的存在是因为某些闭包会移出在捕获时就已被移动的变量： 12345678910111213fn foobar&lt;F&gt;(f: F) where F: FnOnce() -&gt; String&#123; println!(&quot;&#123;&#125;&quot;, f()); &#125; fn main() &#123; let s = String::from(&quot;alright&quot;); foobar(move || s); // `s` 被移动到我们的闭包中 // 并且我们的闭包通过返回将其移动到调用这中 // 记住 `String` 不是 `Copy`&#125; 这是默认强制执行的，因为FnOnce闭包需要移动才能被调用。例如以下是不可行的： 1234567fn foobar&lt;F&gt;(f: F) where F: FnOnce() -&gt; String&#123; println!(&quot;&#123;&#125;&quot;, f()); println!(&quot;&#123;&#125;&quot;, f()); // error: use of moved value: `f`&#125; 如果你对我们的闭包是否确实移动了s有疑问，以下也是不可行的： 123456fn main() &#123; let s = String::from(&quot;alright&quot;); foobar(move || s); foobar(move || s); // 使用了被移动的值：`s`&#125; 但是这是可行的： 12345fn main() &#123; let s = String::from(&quot;alright&quot;); foobar(|| s.clone()); foobar(|| s.clone());&#125; 这是带有两个参数的闭包： 1234567891011121314fn foobar&lt;F&gt;(x: i32, y: i32, is_greater: F) where F: Fn(i32, i32) -&gt; bool&#123; let (greater, smaller) = if is_greater(x, y) &#123; (x, y) &#125; else &#123; (y, x) &#125;; println!(&quot;&#123;&#125; is greater than &#123;&#125;&quot;, greater, smaller);&#125; fn main() &#123; foobar(32, 64, |x, y| x &gt; y);&#125; 这是一个忽略其两个参数的闭包： 123fn main() &#123; foobar(32, 64, |_, _| panic!(&quot;Comparing is futile!&quot;));&#125; 这是一个有点吓人的闭包（指输出）： 12345678910111213141516fn countdown&lt;F&gt;(count: usize, tick: F) where F: Fn(usize)&#123; for i in (1..=count).rev() &#123; tick(i); &#125;&#125; fn main() &#123; countdown(3, |i| println!(&quot;tick &#123;&#125;...&quot;, i));&#125;// 输出：// tick 3...// tick 2...// tick 1... 这是马桶闭包： 123fn main() &#123; countdown(3, |_| ());&#125; 之所以这么称呼是因为|_| ()看起来像马桶。 for in任何可迭代的东西都可以在for in循环中使用。我们刚刚演示了在范围上使用，但实际上它也适用于向量： 12345fn main() &#123; for i in vec![52, 49, 21] &#123; println!(&quot;I like the number &#123;&#125;&quot;, i); &#125;&#125; 或者是切片： 12345678910fn main() &#123; for i in &amp;[52, 49, 21] &#123; println!(&quot;I like thw number &#123;&#125;&quot;, i); &#125;&#125;// 输出：// I like the number 52// I like the number 49// I like the number 21 或者是一个实际的迭代器(iterator)： 12345678910111213fn main() &#123; // 注意：`&amp;str` 还有个 `.bytes()` 迭代器 // Rust 的 `char` 类型是一个 Unicode 标量值 for c in &quot;rust&quot;.chars() &#123; println!(&quot;Give me a &#123;&#125;&quot;, c); &#125;&#125;// 输出：// Give me a r// Give me a u// Give me a s// Give me a t 即使迭代器的成员被过滤(filter)，映射(map)和展平(flat)： 123456789101112fn main() &#123; for c in &quot;SuRPRISE INbOUND&quot; .chars() .filter(|c| c.is_lowercase()) .flat_map(|c| c.to_uppercase()) &#123; print!(&quot;&#123;&#125;&quot;, c); &#125; println!();&#125;// 输出：UB 你可以从函数中返回一个闭包： 12345678910111213fn make_tester(answer: String) -&gt; impl Fn(&amp;str) -&gt; bool &#123; move |challenge| &#123; challenge == answer &#125;&#125;fn main() &#123; // 你可以使用 `.into()` 在类型变种间实施转换 // 例如 `&amp;&#x27;static str` 和 `String` let test = make_tester(&quot;hunter2&quot;.into()); println!(&quot;&#123;&#125;&quot;, test(&quot;******&quot;)); println!(&quot;&#123;&#125;&quot;, test(&quot;hunter2&quot;));&#125; 你甚至可以将函数参数的引用移动到它所返回的闭包中： 123456789101112131415fn make_tester&lt;&#x27;a&gt;(answer: &amp;&#x27;a str) -&gt; impl Fn(&amp;str) -&gt; bool + &#x27;a &#123; move |challenge| &#123; challenge == answer &#125;&#125;fn main() &#123; let test = make_tester(&quot;hunter2&quot;); println!(&quot;&#123;&#125;&quot;, test(&quot;*******&quot;)); println!(&quot;&#123;&#125;&quot;, test(&quot;hunter2&quot;));&#125;// 输出：// false// true 以及，省写生命周期： 12345fn make_tester(answer: &amp;str) -&gt; impl Fn(&amp;str) -&gt; bool + &#x27;_ &#123; move |challenge| &#123; challenge == answer &#125;&#125; 到此，本文就结束了，现在你应该能够阅读他人的 Rust 代码。如果你想更进一步的学习，那么你可以查看： Rust语言圣经 Rust By Example 锈书但无论如何，希望你能记住： If you didn’t code, you didn’t learn.","categories":[],"tags":[]},{"title":"InnerCore 第三方服务端 Zote Core 介绍","slug":"zote-core-loader","date":"2024-01-18T07:41:04.712Z","updated":"2024-02-23T07:30:01.466Z","comments":true,"path":"2024/01/18/zote-core-loader/","link":"","permalink":"https://weifeng233.github.io/2024/01/18/zote-core-loader/","excerpt":"","text":"Zote Core Loader介绍Zore Core 是一个基于 InnerCore 1.16.200 的服务器核心，设计用于提供独特的模组游戏体验。该服务器核心基于Nukkit-MOT ，它可以非常容易地通过替换对应的库来更新。 安装任何支持 Java 17 以及更高版本的平台均可使用。只需要下载该服务器的最新版本或者使用 Gradle创建项目即可。要运行该可信，只需要在终端中打开其所在的文件夹并执行以下命令： 1java -jar ZoteCore-SNAPSHOT.jar 配置服务器的设置主要通过以下三个文件：server.properties 和 zotecore.yml。它们会在核心启动后被自动创建，前两个文件的文档可以在 Nukkit 的仓库中找到。 一些 Nukkit 的设置是被引导程序锁死的，包括 multiversion-min/max-protocol (422), xbox-auth (微软账号认证目前不可用) 和 save-player-data-by-uuid (false). zotecore.yml标准的基本内核设置： 123456789101112131415161718192021222324252627282930313233343536373839404142# 客户端要进入服务器所需要的包的信息# 过时或未实现的版本不会被添加pack: Inner Core Testpack-version: 2.3.0b115 testpack-version-code: 152# 设置要加载的模组集，你可以指定模组集名称或模组集相对于 /modpacks 的文件夹名称或路径modpack: innercore# 使用原版工作台界面替换自定义的版本# 警告：目前尚不支持，自定义的合成配方将不会被展示use-legacy-workbench-override: on# 禁用对已连接的服务端的背包修正# 旧版不能与其正常工作，会使物品无法在背包中移动use-legacy-inventory: on# 切换调试模式以用于不支持的方法（例如客户端方法）# 可选的值有：none, debug (默认), warning, raiseunsupported-method-handling: debug# 模组是否可以使用不安全的函数 (例如eval)# 警告：可能会制造安全风险# 但是通常它会影响 requireGlobal 从而导致模组出现问题allow-unsafe-scripting: on# 开发者模式允许你获关于内核操作的更多信息developer-mode: off# 自动保存模组数据的时间间隔(秒)auto-save-period: 60# 自动存档auto-save-world: on# 无论 socket 服务器是否启用，socket 都额外需要一个端口# 通过 socket 连接服务器相对更稳定socket-server-enable: on# socket 端口，通常应在 10000 至 24999# 但请注意客户端默认使用 2304socket-port: 2304 控制台命令 custom_items - 显示自定义物品列表 custom_blocks - 显示自定义方块列表 mods - 显示服务器上的模组列表 inner_core_network - 显示连接到服务器的玩家列表 state - 通过运行标识符获取方块状态 所有命令都需要管理员权限 技术信息 Key Value Protocol version 422 (1.16.200) Apparatus Commit 73194cfd Instant Referrer Commit a264591 Nukkit-MOT Commit 2b53fb5 开服流程 图文流程待补充首先在设备上安装好 Java，然后去 Releases 中下载最新版本的 ZoteCore，之后在一个空文件夹中（非硬性要求，只是这样方便些）按照上文介绍中的安装方式安装即可。客户端应为最新的 Inner Core Test 包，Horizon版本建议使用1.2.0-beta。此外，客户端还需安装 ServerFixed 模组，对于客户端模组（client only)，只需要在客户端安装即可，否则则需要客户端与服务端均安装，服务端安装模组的方式为 模组集 放在与服务器核心同级的modpack文件夹中即可。可以参考现有的两个服务器，即 Zote Echoes 和Tech Server。","categories":[],"tags":[]},{"title":"香草风格模组指南","slug":"香草风格模组指南","date":"2023-06-09T02:44:55.497Z","updated":"2023-06-09T02:46:35.307Z","comments":true,"path":"2023/06/09/香草风格模组指南/","link":"","permalink":"https://weifeng233.github.io/2023/06/09/%E9%A6%99%E8%8D%89%E9%A3%8E%E6%A0%BC%E6%A8%A1%E7%BB%84%E6%8C%87%E5%8D%97/","excerpt":"","text":"当你想制作一个能够与原版 MC 风格一致的模组时，需要注意两个要素：美术和玩法。 美术根据 BlockBench Wiki 中的文档 Minecraft Style Guide，MC 的美术风格的基础是简约。 比如在模型当中，应当在保证能够描绘对象的基础上尽可能减少元素的数量，不应为了过分追求真实感和精细而制作一个相当复杂的模型，否则当其与原版的内容放置在一起时可以明显感受到突兀感。 在 Minecraft Style Guide 中，作者总结了以下规则： 当然，你不需要在将其掌握到倒背如流的境界并在实际操作中步步遵守，毕竟即使在原版 MC 中也有例外出现（不要去观察可可豆的顶部），你只需要凭你自己的感觉去减少上文提到的那种“突兀感”即可，这里所列举的规则仅相当于一种如何让你的美术资源“香草化”的操作参考。 众所周知，MC 经历过一次大型的纹理更新，在此更新之后，MC 的纹理基本都由 Jappa 绘制，这样保证了风格的一致性，但是在纹理更新前的程序员风格纹理就不原版了吗？答案当然是否定的。你可以去学习 Jappa 的风格，也可以探索自己的风格，是否与原版契合是很容易被感知到的，但即使不契合，玩家也不会不接受。 玩法说到底美术只占了一部分视觉效果，真正能够体现一个模组是否与原版契合的还是在于其玩法（除非你仅仅想做一个装饰性的模组，我也喜欢那种）。 玩法与原版契合并不代表对原版进行复制粘贴，加入各种与原版功能区别不大的矿石工具等，那样并没有多少新意，玩家也很难提起兴趣去玩，因为那些经典的大型模组都已经提供了相当数量的优质选择。因此，模组应该有自己的原创玩法，给 MC 带来新的乐趣。 但是如何在加入新玩法的同时保持原版风格呢？ 在 2020 年 Minecon 上，Jeb 展示了他所编写的“小绿书”中的部分内容，该书是 Mojang 内部的 Minecraft 设计指导，很可惜 Mojang 并不向玩家社区公开其具体内容。但幸运的是 Jeb 大方地展示了两页内容，这使得我们可以据此对 Mojang 的设计理念作一番揣测。 ONE BLOCK AT A TIME! 一次一个方块，或者一块一块挖，即玩家的一次输入应当只引起一个方块的交互，但与一个方块交互后该方块可以再引起其他方块的变化，比如种树、点燃 TNT 或者启动红石装置，无论最终引起的变化有多大，对于玩家来说，一切都应该起始于与一个方块的交互。 这样的规则可以使玩家能够更容易地理解他人游玩时的操作，同时举了一键生成建筑的反面案例，这样的操作会可能使其他玩家难以理解发生了什么。 在此规则下，能够同时破坏多个方块的工具、连锁破坏都是不被允许的，因此需要另寻其他方式来为玩家提供便利。 BAD TINGS HAPPEN… but it’s technically the players’ fault 在 MC 中灾难是常见的，比如掉进熔岩湖或者房屋被苦力怕摧毁，但是重要的是这些事故都是由玩家造成的，或者说是玩家可以回避的，游戏中不应该有无法躲避的灾难，所有灾难性事件的发生都应该是有原因的。 因此，在原版中，闪电虽然是随机的但强度并不大，没有自然生成的生物会主动攻击苦力怕，末影人虽然能移动方块但只能移动如泥土，沙子这类自然生成且玩家可徒手破坏的常见方块（TNT 是个例外，但在无玩家干涉情况下，末影人需要从林地府邸找到 TNT，寻找熔岩或者火焰，或者将其带到远古城市或者雪屋当中的红石块或红石火把旁，我十分期待后者的发生）。 所以大型的自然灾害，能够主动破坏方块的生物都是不应该被加入到 MC 的，但这并不代表限制了游戏的挑战性，监守者就是个很好的例子，它会被方块遮挡，但可以发动声爆攻击。再比如炽足兽，尽管它是友好生物，但是它可以在熔岩上行走，在设计新的生物时也可以如此考虑，虽然不能破坏方块，但是在特定环境下其行为方式可以给玩家带来足够的挑战。 除此之外，开发者们也在社区提及了一些内容，比如毒马铃薯永远不会有用这种实用内容。 有把握认为上文这些规则设立于微软收购 Mojang 之后，自 Java 版末地更新开始实施，尤其是自水域更新之后加入的内容可以明显感知到与 Notch 时期的更新内容大相径庭，如闪电，苦力怕这些违反规则的内容都是在其之前加入的，对于闪电已经加入了避雷针，而苦力怕则是作为 MC 的吉祥物地位过高不可撼动。 当今新加入的动物基本上都是被动或者中立的，而且都带有一定的非现实元素（如海豚可以使玩家游泳加速，海龟壳可以用来酿造），同时因为环保的原因，MC 不支持玩家去杀死现实中存在的动物，所以新加入的动物都不会再掉落如食物之类的必需品（哞菇不是现实动物，因此棕色哞菇是合法的）；游戏中不会轻易加入不可破坏方块，除非它有极其重要的作用且相当罕见。 与美术一样，玩法方面的规则也不是必须要遵守的，你要做的是你自己的模组，一切内容都随你。当今 MC 的每一次更新都有玩家说这不原版，但一段时间后玩家们总会适应的，最重要的是新内容应该与 MC 先前的内容能够契合，而不是一套独立的玩法使 MC 原先的玩法变得无用（这里需要点名一些科技模组和魔法模组，但我懒得写了）。同时 MC 的更新内容可以分为 Notch 时期和微软时期，如果苦力怕是现在被加入游戏的，那么认为它不原版的玩家会不会更多呢？ MC 的主角是玩家，玩家可以自由探索改造这个世界，玩家的所作所为都应该被尊重，玩家的自由也不应该被过多限制，即使是末影龙，玩家也可以在一般生存模式下空手打败，也可以跳过该流程直接到外岛探索。1.8 加入的粘液块，1.20 加入的校频幽匿感测体单独看其功能不算太复杂，但都在社区带来了技术革命，MC 就是这样由一个个简单的内容的组合获得无限可能的，因此原版风格的模组不应该规定玩家的流程，那样会使 MC 更像一个 RPG 游戏或者经营策略游戏。","categories":[],"tags":[]},{"title":"一些关于InnerCore的闲话","slug":"无用闲话","date":"2023-02-18T16:35:06.127Z","updated":"2023-02-18T16:37:15.148Z","comments":true,"path":"2023/02/19/无用闲话/","link":"","permalink":"https://weifeng233.github.io/2023/02/19/%E6%97%A0%E7%94%A8%E9%97%B2%E8%AF%9D/","excerpt":"","text":"阅前提醒：本文仅为个人观点，是否具有参考价值由读者自行判断。 能看到这篇文章的人应该都知道InnerCore和Horizon是什么了，就不再赘述了。那么先按常例简单梳理一下发展史，首先InnerCore是Zheka基于CoreEngine开发的一款适用于安卓平台上PE/BE版MC的模组启动器，而CoreEngine则是由Factorzation的FactAPI发展而来，运行在著名的方块启动器上。而Horizon是Zheka为了规避Play商店的限制和方便更新InnerCore而开发的一个实例化启动器，或者说是一个“游戏启动器平台”，但按当前的情况来看，但实现后者是一件遥不可及的事情，毕竟除了人力物力的支持外，还难免会涉及版权纠纷。但是鉴于已经有相当多的人将Horizon与新版InnerCore画上等号，那么相比大部分人应该都不怎么担心Horizon会怎么样，只会关注InnerCore的游玩体验之类的事情，那么无论再怎么画饼也不会有人被吸引的。 说回InnerCore，现在InnerCore给人的第一印象相比只有三个字“不稳定”，再其次就是“卡顿”，“优化差”，“版本落后”，“不如网易”等批评，而且确实难以反驳。但是不能将这些问题简单地都推给引擎，还有两个重要因素值得注意，一是InnerCore的开发社区实在是太小了，人数最多的开发社区当属俄国（这么说并不能全部包括，或许应该叫前苏联地区233）和中国，但规模都在几十人且活跃者均为个位数，而且在这种甚至情况下还分生出了一些互相存在些许矛盾的小团体（嘛，其实也完全可以理解，毕竟人的方向和观念都是自由的），至于其他的国家或地区那就更是屈指可数了，这就导致了至今ICMod的开发还很不成熟，没有多少稳定可靠的轮子可用，而且有些比较基本的东西都还没有打成一个一致的标准（比如说经典UI和矿辞，都是有望通过开发社区交流合作来实现的）。 二是微软对第三方启动器的打压，虽然没有表现在明面上，但很多操作都可以证实，比如说封禁帐号和删除符号，前者是在警示玩家不要使用第三方启动器（当然，确实有反作弊的目的，但当时的封禁标准是针对安卓上的第三方启动器如方块启动器，Toolbox设计的，因为服务器作弊的大头在Win10平台上），后者则是阻碍第三方启动器的开发者对新版本的适配。所以我个人是对InnerCore适配新版本不抱任何希望了，但对于模组玩家来说，这并非是不能接受的事情。 但是我并不认为InnerCore就应该就此被遗弃，因为InnerCore以上的劣势都是由它最大的优势导致的——InnerCore是一个第三方模组API，这意味着开发者有足够的接口和权限去做几乎任何他们想做的事情（前提是不只是拘束在CoreEngineAPI当中），我可以断言，Mojang和网易的模组API永远不可能允许开发者有完全自由的文件读写权限和系统权限，当然这是因为这会给玩家带来很大的安全隐患，但这取决于开发者，Java版的模组引擎比如Forge，Fabric也有同样甚至更高的自由度，但恶意模组的事件不算多。如果第三方模组在基岩版彻底灭绝，全靠坐等官方开放的官方模组API，那么基岩版模组是不会有与Java版模组抗衡的时候的（虽然我个人觉得和Java版比意义不大就是了）。总之无论如何，我都会坚持支持第三方模组API。 再说点题外话，目前基岩版的官方模组API都是数据驱动+服务端脚本的模式，而InnerCore是客户端与服务端函数和回调混合的模式，直接比较两种不同的模式（或者叫“范式”）是不合适的，但就和面向过程和面向对象一样，都有其显优势的情况。我个人认为官方模组API的模式比较适合开发那些大体量但同质化较高和重视觉表现轻功能的模组，而InnerCore适合开发内容耦合性较高和拥有复杂逻辑的模组，虽然现在的环境是基本上都以前者为主，后者无论在基岩版和Java版都相当少见（但质量基本上都很高）。不过这都是相当理想的想法了，在现实中谁说要在InnerCore开发像机械动力那样的模组估计要么收获一些质疑要么被推荐去网易。另外比如Pojav，HMCLPE这些安卓平台上的Java版启动器我个人认为与InnerCore是不在同一条赛道上的，不能互相比较，谁优谁劣的争论是无意义的。 Vanilla Survival Player","categories":[],"tags":[]},{"title":"Core Utility（渣翻预警）","slug":"CoreUtility","date":"2022-08-03T10:23:19.603Z","updated":"2022-08-26T17:41:33.404Z","comments":true,"path":"2022/08/03/CoreUtility/","link":"","permalink":"https://weifeng233.github.io/2022/08/03/CoreUtility/","excerpt":"","text":"Core Utility应用领域该核心设计用于创建 Hooks（重载原生(Native)方法或覆写其返回值）以及在 JavaScript / TypeScript 中调用原版方法，以极大的简化部分方法与原生模块的集成。 声明文件 core-utility.d.ts - 用于支持 TypeScript 的编辑器 ToolTipToolTip(工具提示) 用于自定义显示在物品名称下方的附加数据，可用于展示能量值或创造物品栏类别。 向物品添加工具提示（当然这也适用于方块） 1ToolTip.addToolTip(id, data, name); 在正文之前添加一条动态工具提示 123ToolTip.addDynamicPre(id, data, function(item) &#123; return Translation.translate(&quot;tool.unique_artifact.formatter&quot;);&#125;); 在正文之后添加一条动态工具提示 123ToolTip.addDynamicPost(id, data, function(item) &#123; return Translation.translate(&quot;tool.unique_artifact.name&quot;);&#125;); 添加多条工具提示（译注：此处 names 为包含提示内容的数组） 1ToolTip.addToolTips(id, data, names); 删除特定的工具提示 1ToolTip.deletToolTip(id, data, names); 清除先前添加的工具提示 1ToolTip.clearToolTip(id, data); 以数组的形式获取所有的工具提示 1ToolTip.getToolTips(id, data); 清除所有物品的工具提示 1ToolTip.clearToolTips(); NativeAPI用于调用在运行环境（运行时值）和模组脚本之间转换标识符的主要方法的工具类。 标识符可以有多种类型，对于一个物品或方块必须相应地如下指定： 12ConversionType.ITEMConversionType.BLOCK 将动态标识符转换为静态标识符 1NativeAPI.dynamicToStatic(id, type); 将静态标识符转换为动态标识符 1NativeAPI.staticToDynamic(id, type); 通过实例对象获取实体的 UUID 1NativeAPI.getActorID(actor); 通过UUID获取实体的实例对象 1NativeAPI.getActorById(id); ActorDamageCause创建 ActorDamegeCause 类的实例对象，ID 为未来伤害的 ID（可以替换原版伤害类型） 1new ActorDamageCause(id); 设置死亡信息 123&lt;ActorDamageCause&gt;.setDeadMessage(function(type, name_player, attacker)&#123; return &quot;Kill &quot;+name_player;&#125;); TickingAreasManager常加载区域是由玩家创建的一些区块，可以在附近没有玩家的情况下保持更新。该类用于管理已创建的常加载区域和创建新的常加载区域。 检查是否存在常加载区域 1TickingAreasManager.hasActiveAreas(); 在特定坐标处添加特定半径的球形常加载区域 1TickingAreasManager.addArea(dimension, name, x, y, z, range); 以特定的两点添加长方体常加载区域 1TickingAreasManager.addAreaPositions(dimension, name, x1, y1, z1, x2, y2, z2); 为维度中的特定实体添加常加载区域，即使该实体拥有和玩家一样的加载区块的能力 1TickingAreasManager.addEntityArea(dimension, entity); 返回世界中的常加载区域的数量，因为是通过指令添加，上限为10 1TickingAreasManager.countStandaloneTickingAreas(); 返回特定维度中的常加载区域的数量 1TickingAreasManager.countPendingAreas(dimension); FileUtils用于处理文件的原生模块，简化了处理大量文件的过程。 12345678910111213141516171819202122232425262728// 删除文件夹及其包含的文件FileUtils.deleteDirectory(path);// 清空文件夹FileUtils.deleteDirectoryContents(path);// 如果为空文件夹则将其删除FileUtils.deleteEmptyDirectory(dir);// 删除特定文件FileUtils.deleteFile(file);// 重命名文件夹FileUtils.renameDirectory(oldName, newName);// 重命名文件FileUtils.renameFile(oldName, newName);// 复制文件夹及其包含的文件FileUtils.copyDirectory(from, to); // 检查文件是否存在FileUtils.fileExists(file);// 检查文件夹是否存在FileUtils.directoryExists(dir); // 检查路径是否可用FileUtils.isValidPath(path);// 检查是否为游戏文件夹的相对路径FileUtils.isRelativePath(path);// 检查文件或文件夹是否存在FileUtils.isExists(pathOrFile);// 创建文件夹FileUtils.createDirectory(path);// 为文件创建其路径中缺少的文件夹FileUtils.createDirectoryForFile(path); World用于管理世界列表，可以添加非游戏本身提供的世界文件夹路径，例如模组特定的世界。 向世界列表添加路径 1World.addWorldToCache(path); 刷新世界列表，若游戏已经加载完毕则会产生视觉上的变化（译注：在进入世界后使用可使游戏崩溃） 1World.updateWorlds(); 获取有效的世界数量（若世界存档损坏，则不会被计入） 1World.getWorldsCount(); Random 继承自 PointerClass 生成最大值为max的随机数 1&lt;random&gt;.nextInt(max); Level 继承自 PointerClass 返回 Random 实例 1&lt;level&gt;.getRandom(); 生成特定命名空间ID的实体到世界中 1addEntity(source, x, y, z, namespace); 返回自世界创建以来的总 tick 数 (1 tick = 1/20s) 1getCurrentTick(); 返回服务端自世界创建以来的总 tick 数 (1 tick = 1/20с) 1getCurrentServerTick(); 获取玩家加载区块范围 1getChunkTickRange(); Options 继承自 PointerClass 获取用户界面类型 - 0 为 Pocket UI, 1 为经典UI 1&lt;options&gt;.getUiProfile(); GuiData 继承自 PointerClass 展示标题消息（等同于 /title title） 1&lt;guiData&gt;.setTitle(name); 展示副标题消息（等同于 /title subtitle） 1&lt;guiData&gt;.setSubtitle(name); 展示快捷栏标题消息（等同于 /title actionbar） 1&lt;guiData&gt;.setActionMessage(name); ClientInstance 继承自 PointerClass 返回 Options 实例 1&lt;ClientInstance&gt;.getOptions(); 返回 GuiData 实例 1&lt;ClientInstance&gt;.getGuiData(); 在特定坐标播放方块破坏粒子 1&lt;ClientInstance&gt;.renderDestroyBlock(x, y, z, speed); 将本地玩家的相机设置为另一个实体 1&lt;ClientInstance&gt;.setCameraEntity(entity); GlobalContext返回 ClientInstance 实例 1GlobalContext.getClientInstance(); 返回服务端的 Level 实例 1GlobalContext.getServerLevel(); 返回客户端的 Level 实例 1GlobalContext.getLevel(); BlockUtils返回 LegacyBlock 的 PointerClass 实例 1BlockUtils.getBlockById(id); 返回 BlockState 的 PointerClass 实例 1BlockUtils.getBlockStateForIdData(id, data); 高级功能Minecraft 中的每个方法都有它的唯一标识符（符号，symbol），通过符号可以为方法创建 Hook （监听器）或调用它。 如何找到方法的符号？IDA Pro – Hex Rays - Windows, Linux, macOSGhidra Software Reverse Engineering Framework - Windows, Linux, macOSDisassembler - Viewer, Dumper - Android Injector用于和原版的类一起使用，以供调用方法并获取返回值。如果不打算再使用，建议释放内存。可以通过指针或 PointerClass 的实例对象来创建。 12new Injector(pointer);new Injector(PointerClass); 返回库中的 Offset 类，相当实用，需要查找相应的反汇编代码 12&lt;injector&gt;.getOffset();&lt;injector&gt;.getOffset(offset); 调用原版方法 1&lt;injector&gt;.call(symbol, parameters, table); 调用原版方法，返回值为整型 1&lt;injector&gt;.getIntResult(symbol, parameters, table); 调用原版方法，返回值为浮点数 1&lt;injector&gt;.getFloatResult(symbol, parameters, table); 调用原版方法，返回值为布尔值 1&lt;injector&gt;.getBoolResult(symbol, parameters, table); 调用原版方法，返回值为字符串 1&lt;injector&gt;.getStringResult(symbol, parameters, table); 调用原版方法，返回值为该类的实例对象的指针 1&lt;injector&gt;.getPointerResult(symbol, parameters, table); 用其他任意的方法替换特定的方法 1&lt;injector&gt;.replace(table, method, symbol); 释放内存，将无法再与此对象进行交互 1&lt;injector&gt;.free(); 设置原版库的名称 1&lt;injector&gt;.setLib(name); 调用静态方法如果一个类没有实例也不能创建实例，但存在静态方法，可通过构造一个空白的实例对象来调用。 1new Injector(); Offset该类允许通过偏移获取类的字段。 1234567891011&lt;offset&gt;.setOffset(offset);// 获取整型&lt;offset&gt;.getInt(offset?);// 获取浮点值&lt;offset&gt;.getFloat(offset?);// 获取值的指针&lt;offset&gt;.getPointer(offset?);// 获取字符串&lt;offset&gt;.getString(offset?);// 释放内存，不可再使用&lt;offset&gt;.free(); Hook 在模组文件夹中创建一个hooks.json文件。 在其中编写 Hook 对象的描述。 在模组脚本中添加回调（回调函数的第一个参数为控制器，第二个为指向被 Hook 的类的指针，之后为在描述中定义的参数）。 12345678&#123; &quot;symbol&quot;: &quot;&lt;symbol&gt;&quot;, &quot;callback&quot;: &quot;&lt;callbackName&gt;&quot;, &quot;args&quot;: [], // 默认为 [] &quot;priority&quot;: &quot;pre&quot; // 在方法调用之前或之后触发，默认为 pre 之前，可选 post 之后 &quot;lib&quot;: &quot;mcpe&quot;, // 默认为 mcpe &quot;return&quot;: &quot;bool&quot; // 默认为 void&#125; 返回值的类型 stl::string void - 接受类的实例对象的指针 int float bool 参数类型 stl::string int float ptr BlockPos Vec2 Vec3 ChunkPos BlockSource CompoundTag 对于其他的数据类型，可以使用指针ptr。另外不要忘记替换&lt;symbol&gt;为需要覆盖的特定符号，以及&lt;callbackName&gt;将作为该方法执行时调用的回调。 使用示例 模组 TimeWand NotBurningMobs Combination Lock Faster Ladder Climbing Injector 示例，当方块被点击时调用其 randomTick 方法。 123456789101112131415161718192021222324252627function getNativeBlock(region, x, y, z) &#123; let injector = new Injector(region.getPointer()).setArgsType([&quot;ptr&quot;]); let pos = new BlockPos(x, y, z); let block = injector.getPointerResult(&quot;_ZNK11BlockSource8getBlockERK8BlockPos&quot;, [ Parameter.getPointer(pos) ]); injector.free(); pos.free(); return block;&#125;function randomTick(block, x, y, z, region) &#123; let injector = new Injector(block).setArgsType([&quot;ptr&quot;, &quot;ptr&quot;, &quot;ptr&quot;]); let pos = new BlockPos(x, y, z); injector.call(&quot;_ZNK5Block10randomTickER11BlockSourceRK8BlockPosR6Random&quot;, [ Parameter.getPointer(region.getPointer()), Parameter.getPointer(pos), Parameter.getPointer(GlobalContext.getServerLevel().getRandom()) ]); pos.free(); injector.free();&#125;Callback.addCallback(&quot;ItemUse&quot;, function(pos, item, block, is, player) &#123; let region = BlockSource.getDefaultForActor(player); randomTick(getNativeBlock(region, pos.x, pos.y, pos.z), pos.x, pos.y, pos.z, region);&#125;); Offset 示例，当点击方块时创建一个 BlockPos 实例，其坐标值为偏移值。 12345678Callback.addCallback(&quot;ItemUse&quot;, function(coords, item, block, is, player) &#123; let pos = new BlockPos(coords.x, coords.y, coords.z); let injector = new Injector(pos); let offset = injector.getOffset(); alert(offset.getInt(0) + &quot; &quot; + offset.getInt(4) + &quot; &quot; + offset.getInt(8)); pos.free(); injector.free();&#125;); Hook 示例，更改确定白天的逻辑，使无论在什么时间亡灵生物都会燃烧 123456789[ &#123; &quot;symbol&quot;: &quot;_ZNK9Dimension5isDayEv&quot;, &quot;callback&quot;: &quot;Dimension.isDay&quot;, &quot;args&quot;: [], &quot;priority&quot;: &quot;pre&quot;, &quot;return&quot;: &quot;bool&quot; &#125;] 1234Callback.addCallback(&quot;Dimension.isDay&quot;, function(controller, self)&#123; controller.replace(); controller.setResult(false);&#125;); 一个设置红石信号强度的例子，当使用木棍点击方块时会设置此处的红石信号强度为5。 12345678910111213141516171819202122232425262728293031323334353637383940function getDimension(region)&#123; let injector = new Injector(region.getPointer()); let dimension = injector.getPointerResult(&quot;_ZN11BlockSource12getDimensionEv&quot;); injector.free(); return dimension;&#125;function getCircuitSystem(region)&#123; let injector = new Injector(getDimension(region)); let system = injector.getPointerResult(&quot;_ZN9Dimension16getCircuitSystemEv&quot;); injector.free(); return system;&#125;let cache = &#123;&#125;;function redstoneUpdate(region, x, y, z, strength)&#123; let system = cache[region.getDimension()]; if(!system)&#123; cache[region.getDimension()] = getCircuitSystem(region); system = cache[region.getDimension()]; &#125; let injector = new Injector(system); let pos = new BlockPos(x, y, z); injector.setArgsType([&quot;ptr&quot;, &quot;int&quot;]).call(&quot;_ZN13CircuitSystem11setStrengthERK8BlockPosi&quot;, [ Parameter.getPointer(pos), Parameter.getInt(strength||10) ]); injector.free(); pos.free();&#125;Callback.addCallback(&quot;ItemUse&quot;, function(pos, item, block, is, player)&#123; if(item.id == 280) Updatable.addUpdatable(&#123; tick: 0, update()&#123; if(this.tick &gt;= 20) this.remove = true; redstoneUpdate(BlockSource.getDefaultForActor(player), pos.x, pos.y, pos.z, 5); &#125; &#125;)&#125;); 原生类为了使用方便，原生类都继承自 PointerClass。 返回类的实例对象的指针 1&lt;pointerClass&gt;.getPointer(); ItemsUtil获取特定ID物品的 PointerClass 实例对象 1ItemsUtil.getItemById(id); 修改物品名称 1ItemsUtil.overrideName(id, data, name); 修改盔甲的护甲值 1ItemsUtil.overrideArmorValue(id, value); EntityRegister通过字符串类型的标识符向实体添加 tick 回调（例如 minecraft:zombie&lt;&gt;，其中&lt;&gt;为年龄，状态等附加数据）。 1234EntityRegister.setHandlerTick(name, function(ent) &#123; // 使符合条件的生物升天 Entity.setVelocity(ent, 0, 0.0005, 0);&#125;); BlockPos 继承自 PointerClass 12new BlockPos(pointer);new BlockPos(x, y, z); 123&lt;blockPos&gt;.getX();&lt;blockPos&gt;.getY();&lt;blockPos&gt;.getZ(); 123&lt;blockPos&gt;.setX(x);&lt;blockPos&gt;.setY(y);&lt;blockPos&gt;.setZ(z); 1&lt;blockPos&gt;.free(); Vec3 继承自 PointerClass 12new Vec3(pointer);new Vec3(x, y, z); 123&lt;vec3&gt;.getX();&lt;vec3&gt;.getY();&lt;vec3&gt;.getZ(); 123&lt;vec3&gt;.setX(x);&lt;vec3&gt;.setY(y);&lt;vec3&gt;.setZ(z); 1&lt;vec3&gt;.free(); Vec2 继承自 PointerClass 12new Vec2(pointer);new Vec2(x, y); 12&lt;vec2&gt;.getX();&lt;vec2&gt;.getY(); 12&lt;vec2&gt;.setX(x);&lt;vec2&gt;.setY(y); 1&lt;vec2&gt;.free(); ChunkPos 继承自 PointerClass 12new ChunkPos(pointer);new ChunkPos(x, z); 12&lt;ChunkPos&gt;.getX();&lt;ChunkPos&gt;.getZ(); 12&lt;ChunkPos&gt;.setX(x);&lt;ChunkPos&gt;.setZ(z); 1&lt;ChunkPos&gt;.free(); Gui在特定坐标播放方块破坏动画 1Gui.animationDestroy(x, y, z); 在声明文件core-utility.d.ts中提供了一些方法文档","categories":[],"tags":[]},{"title":"在Horizon使用ZeroTier进行多人游戏","slug":"mutiplayer-in-horizon","date":"2022-07-20T17:46:48.363Z","updated":"2022-07-20T17:49:52.273Z","comments":true,"path":"2022/07/21/mutiplayer-in-horizon/","link":"","permalink":"https://weifeng233.github.io/2022/07/21/mutiplayer-in-horizon/","excerpt":"","text":"首先下载ZeroTier，如果打不开可以用镜像。 然后到ZeroTier官网注册账号，接着去创建一个网络，点击Create A Network按钮然后复制NETWORK ID即可 之后进入网络设置将访问控制更改为公共（你也可以选择私人，但那样每有新人加入时就需要手动在该页面同意），你也可以顺便改个名字 然后在手机上打开ZeroTier Fix，进行极其简单的操作： 然后进入游戏即可与普通的局域网联机一样了","categories":[],"tags":[]},{"title":"内核课程 - 0：模组结构、编程语言和库","slug":"0","date":"2022-07-17T11:00:33.475Z","updated":"2022-07-17T13:19:56.560Z","comments":true,"path":"2022/07/17/0/","link":"","permalink":"https://weifeng233.github.io/2022/07/17/0/","excerpt":"","text":"本文是ICMod开发教程的第0章，主要内容为模组结构，编程语言和库，适用版本为InnerCore 2.x（在玩家社区中通常以Horizon指代），注意发布时间。 模组结构ICMod是以文件夹的形式放在对应InnerCore包下的innercore/mods文件夹，在发布时以ZIP格式的压缩包并通常使用.icmod作为文件后缀。 在ICMod中，许多文件的相对位置和名称都可以在build.config中指定，除了以下文件： 模组文件夹 │ build.config - 模组的结构信息和编译信息 │ config.json - 模组的配置文件 │ config.info.json - 模组配置文件的描述文件，包括本地化(翻译)和配置属性 │ mod.info - 模组信息 │ mod_icon.png - 模组图标 | └─.dex - 已编译的模组源码 先简单说一下mod.info的内容，包含以下信息： 123456&#123; &quot;name&quot;: &quot;模组名称&quot;, &quot;author&quot;: &quot;模组作者&quot;, &quot;version&quot;: &quot;模组版本&quot;, &quot;description&quot;: &quot;模组简介&quot;&#125; 至于配置文件以后会单独讲解，这里先按下不表。 build.config中的内容可由模组作者自行修改，这里举个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//EnergyTech(能源科技) - V4.0.2//该build.config由官方的toolchain自动生成，在较新的模组中是相当典型的例子&#123; &quot;defaultConfig&quot;:&#123; //主要参数 &quot;readme&quot;:&quot;this build config is generated automatically by mod development toolchain&quot;, &quot;api&quot;:&quot;CoreEngine&quot;, //指定API，还可以选择 AdaptedScript 但缺少了很多拓展功能，更贴近底层(Java层) &quot;buildType&quot;:&quot;develop&quot; //编译类型，通常建议在发布时更改为 release &#125;, &quot;compile&quot;:[ //可执行文件，应 launcher 和 mod 源码类型各至少有一个 &#123; &quot;path&quot;:&quot;source/main.js&quot;, &quot;sourceType&quot;:&quot;mod&quot; &#125;, &#123; &quot;path&quot;:&quot;source/launcher.js&quot;, &quot;sourceType&quot;:&quot;launcher&quot; &#125;, &#123; &quot;path&quot;:&quot;library/BlockEngine.js&quot;, &quot;sourceType&quot;:&quot;library&quot; &#125;, &#123; &quot;path&quot;:&quot;library/ChargeItem.js&quot;, &quot;sourceType&quot;:&quot;library&quot; &#125;, &#123; &quot;path&quot;:&quot;library/SoundLib.js&quot;, &quot;sourceType&quot;:&quot;library&quot; &#125; ], &quot;resources&quot;:[ //资源文件，如模组贴图和GUI贴图 &#123; &quot;path&quot;:&quot;resources/res&quot;, &quot;resourceType&quot;:&quot;resource&quot; &#125;, &#123; &quot;path&quot;:&quot;gui/gui&quot;, &quot;resourceType&quot;:&quot;gui&quot; &#125; ], &quot;nativeDirs&quot;:[], //原生模组模块文件夹 &quot;javaDirs&quot;:[], //Java模块文件夹 &quot;buildDirs&quot;:[] //可行性构建文件夹&#125; 可以看到在compile中指定了很多js文件，其中mod类型即为模组的主要代码；launcher类型的文件只能有一个，用于决定模组是否启动；library类型为库，除了像这样一个一个添加之外还可以在defaultConfig中指定libraryDir，这样将会将该目录下的所有文件当作库并尝试执行；除了以上三种之外还有另外两种类型，分别是在模组加载之前执行的preloader和仅能在其他类型中使用runCustomSource方法调用的custom类型，值得注意的是这两种类型除了部分常量之外无法使用IC提供的API（虽然可以通过rhino调用，但不建议也没必要）。 resources用于指定资源文件，没什么好说的，只需要注意GUI纹理资源需要单独指定。 nativeDirs和javaDirs的用法见下文，此处单讲buildDirs。buildDirs允许开发者将可执行文件分散成多个文件以方便开发，举个简单的例子： 123456&quot;buildDirs&quot;:[ &#123; &quot;dir&quot;:&quot;source/dev/&quot;, &quot;targetSource&quot;:&quot;source/main.js&quot; &#125; ] dir指定了可执行文件存放的文件夹，此文件夹内必须有一个includes文件逐行记录了各个文件的相对位置，InnerCore将会按顺序合并为一个文件并覆写到targetSource指定的文件中。此过程并非简单的文本拼接，不可将完整的代码文件随意拆分为两个文件，否则可能会导致错误。 编程语言ICMod主要使用的编程语言是JavaScript，使用Rhino作为引擎，支持ES5和极少一部分ES6特性和调用Java，主要劣势为运行速度相当慢，与主流JS引擎相差百倍，但对于大多数情况都是够用的。这里推荐几个JS学习资源： JavaScript编程精解，相当不错的入门书籍。 JavaScript | MDN，权威且全面，页面内还附有其他资源链接。 Rhino ES2015 Support，关于Rhino引擎对于ES6特性的实际支持情况。 但JS有一个特点，就是它是弱类型语言，对于一些更习惯强类型语言的开发者可以选择TypeScript，在官方的toolchain中就支持使用TS编写模组并在之后转译为JS供InnerCore使用。同样的，推荐一些教程： 官方文档，权威，最新。 TypeScript入门教程，菜鸟教程，中文，方便阅读但不是最新版本。 除了使用JS/TS，ICMod还允许使用Java或者Native模块来拓展API，需要有Java和C/C++知识并了解一些Android SDK/NDK开发，此处不再提供相关资源链接，但应注意始终以对应版本的官方文档为准，善用搜索引擎查找问题以及在提问前明确问题。 库库用于拓展API，可以是单个的JS文件也可以是以模块形式的DEX文件或者SO文件又或者是单独的模组，关于JS格式的库在模组中的存放位置已在前文叙述，这里仅将如何编写内容和使用。 JS库在库的开头，需要使用LIBRARY方法来描述库的基本信息： 123456789LIBRARY(&#123; name: &quot;名称&quot;, // 库的唯一识别名称，不应再修改 version: 版本, // 库的版本，必须为大于0的整数，更高版本的库会覆盖更低版本的 shared: false, // 如果为 true 则库将作为全局API，即所有使用该库的模组共用相同的API对象，否则仅作用于单个模组 api: &quot;CoreEngine&quot;, // 库使用的API dependencies: [&quot;name1:version1&quot;, //... ] //在库中导入的依赖库列表&#125;); 要导出库中的API，使用EXPORT方法： 12345678910111213141516EXPORT(&quot;API对象名称&quot;, API对象);//EXPORT还支持指定导出API对象的最低库版本//如加入在一个库中存在以下三条EXPORTEXPORT(&quot;print&quot;, function () &#123; alert(&quot;new version print&quot;); &#125;);EXPORT(&quot;print:3&quot;, function () &#123; alert(&quot;older print&quot;); &#125;);EXPORT(&quot;print:1&quot;, function () &#123; alert(&quot;first version print&quot;); &#125;);//一般情况下，默认使用第一个print方法//但当使用者指定的库版本＞1且≤3时，将使用第二个print方法//若指定的库版本为1，则使用第三个print方法 在模组中导入库时，使用IMPORT方法： 123IMPORT(&quot;库名称&quot;); //导入整个库IMPORT(&quot;库名称&quot;, &quot;API对象名称&quot;); //导入特定的APIIMPORT(&quot;库名称:库版本&quot;); //指定库版本 原生模块和Java模块在nativeDirs和javaDirs中与buildDirs相似，只需要指定path即可，如下： 12345&quot;nativeDirs&quot;: [ &#123; &quot;path&quot;: &quot;source/native/&quot; &#125;] 在指定的目录下必须有一个manifest文件来指定相关信息，对于原生模块，格式是这样的： 123456789101112&#123; &quot;shared&quot;: &#123; &quot;name&quot;: &quot;name&quot;, //此名称为编译后生成的so文件名称，如 libname.so &quot;include&quot;: [ //编译时包含的源码文件夹，可选 &quot;shared_headers&quot; ] &#125;, &quot;depends&quot;: [ //在编译的时候依赖的内置库，可选 &quot;innercore&quot;, &quot;nativejs&quot; ]&#125; 同时需要一个main.cpp文件包含基本的代码，你可以在官方的toolchain中使用NDK对其进行编译，也可以在Horzion中使用gcc编译。 对于Java模块，manifest文件的格式是这样的： 12345678//Toolchain示例模组&#123; &quot;source-dirs&quot;: [&quot;src&quot;], //源码文件夹 &quot;library-dirs&quot;: [&quot;lib&quot;], //JAR库文件夹 &quot;verbose&quot;: true, //是否开启verbose输出 &quot;options&quot;: [], //verbose选项 &quot;boot-classes&quot;: [&quot;com.sample_mod.sample_package.Boot&quot;] //要执行的类&#125; Java编译可以在Toolchain中使用JDK完成，也可以在Horizon中完成。 要使用原生模块和Java模块，InnerCore提供了以下方法： 123IMPORT_NATIVE(name, target); //获取原生模块方法并注入到指定对象中WRAP_JAVA(name); //获取Java对象并返回WRAP_NATIVE(name); //获取原生模块并返回 在Java模块中，得益于Rhino，所定义的Java类都可直接使用，而在原生模块中，需要nativejs.h头文件提供的方法才能创建可供JS使用的JS模块： 12345JS_MODULE_VERSION(模块名称, 1); //指定模块名称和版本JS_EXPORT(模块名称, 方法名称, &quot;I()&quot;, (JNIEnv* env) &#123; //导出一个返回值为整型无参数的方法 //... NativeJS::wrapIntegerResult(0); //返回 0&#125;); 非常感谢您能读完本篇教程，因本人能力不足，对于教程中的疏漏与错误望各位指出斧正。 本系列教程将按照俄国社区先前编写的一份课程表格(谷歌文档)进行，下一篇将会简要讲解物品。","categories":[],"tags":[]},{"title":"关于InnerCore包","slug":"关于InnerCore包","date":"2022-04-07T12:42:10.438Z","updated":"2022-04-07T16:45:12.887Z","comments":true,"path":"2022/04/07/关于InnerCore包/","link":"","permalink":"https://weifeng233.github.io/2022/04/07/%E5%85%B3%E4%BA%8EInnerCore%E5%8C%85/","excerpt":"","text":"注：本文翻译自官方文档，UI文本与InnerCore b113一致 这个包有什么？在InnerCore包的主菜单中有以下五个按钮： 游玩 - 用于开始游戏的按钮 原生模组 - 位于屏幕右侧用于打开原生模组菜单的按钮 模组管理器 - 此游戏的模组管理器 下载模组 - 允许你任意下载模组 我的模组 - 用于管理你已安装的模组 我的模组集 - 管理已安装的由开发者创作的现成整合包 模组更新 - 可更新的模组列表 访问网站 - 打开此游戏的一个成熟的模组网站 首选项和链接 首选项 禁用加载屏幕 - 显示正在加载模组的页面，在某些设备上禁用后可能会提升加载速度 开发人员模式 - 对模组开发者相当实用，包括在支持的模组中启用调试模式 使用旧版工作台 UI - 如果原版工作台对于一些配方无效，则可以恢复至之前的工作台UI 基于时间限制更新 - 开启后，模组在一游戏刻中产生的最大更新数量将被限制，否则将无限制，简单说就是模组每刻最多能调用的次数 每刻最大的更新次数 - 调整_更新次数限制_ 建立高级线程优先级 - 更高的优先级可使TPS更稳定（这意味着更稳定的操作和响应时间），但可能会冻结线程和降低帧率 服务端线程优先级 - 调整_线程优先级_ FPS阈值 - 当FPS低于该阈值时，将会降低服务端线程优先级 更多的线程数 - 额外的更新线程，对于性能较强的设备上可以提升负载性能，注意，该功能仍处于实验性阶段，可能会不稳定 更多的线程优先级 - 调整_额外线程的优先级_ 自动保存 - 允许你在游戏意外停止运行时保存存档和模组数据 自动保存优先级 - 两次保存之间间隔的秒数 启用套接字服务器 - 允许局域网内的玩家通过Socket协议进入你的世界 优先化本地网络协议 - 使用原生协议（默认情况下Socket协议有更高的优先级） （开发人员用）强制本地化本地协议 - 使用原生协议进行本地客户端与服务端的通信，该选项仅用于调试模组，切勿在正常游戏中使用！ (For developers)Dump additional information - 在世界加载期间导出与开发相关的信息，dump文件会与log放在相同文件夹 指南和链接 - 包含指南和社交网络链接的标签页 开发小组 - 开发者，测试员和模组开发者的贡献名单 关于","categories":[],"tags":[]},{"title":"CraftTweaker使用教程","slug":"CraftTweaker","date":"2022-01-15T06:40:12.563Z","updated":"2022-01-22T15:50:15.431Z","comments":true,"path":"2022/01/15/CraftTweaker/","link":"","permalink":"https://weifeng233.github.io/2022/01/15/CraftTweaker/","excerpt":"","text":"CraftTweaker（以下简称CrT）是由麦穗开发与同名的Java版模组有类似功能的魔改类模组。 本文将简要介绍如何编写和使用CrT脚本。 加载脚本CrT在运行时会读取当前加载模组集对应文件夹下script文件夹内的所有后缀为js的文件并为每一个脚本创建独立的沙盒以独立运行。 你可以在包对应文件夹内的innercore/preferences.json文件中的pack_selected键对应的属性得知当前所加载的模组集对应的路径，无论如何，script文件夹都应与mods文件夹在同一级文件夹内。 123//可能放置脚本的文件夹//pack_name/innercore/script///mod_pack_name/script/ 编写脚本编程语言与ICMod一样，CrT脚本使用Rhino引擎运行，语言为JavaScript，支持ES5与部分ES6特性。 预置函数CrT为CrT脚本提供了两个预置函数，分别为$和require，下文将分别介绍这两个函数的详细用法： $$用于创建ItemStack对象，是CrT和ICMod通用的物品格式。 格式：123456789101112131415161718192021// $ 的格式如下$(&quot;type:name:data*count&quot;);/* type - ID的类型，分为方块 - block 和 物品 - item * name - ID的名称，如bedrock, stick等 * data - 物品的特殊值/损坏值（可选） * count - 物品的数量（可选） *///举例：$(&quot;block:bedrock&quot;); //基岩$(&quot;block:wool:6*32&quot;); //半组粉红色羊毛$(&quot;item:stick*64&quot;); //一组木棍$(&quot;item:diamond_shovel:1560&quot;); //一把快要坏掉的钻石锹// ItemStack 对象包含的值如下&#123; index: string, //索引，即ID的名称 id: number, //物品的数字ID data: number, //物品的特殊值/损坏值 count: number, //物品的数量 _condition: function, //合成条件，物品在工作台中参与合成时执行，详见下文&#125; 用法：12345678910111213141516171819202122232425262728293031323334// ItemStack 对象有以下方法toItem(); //返回 toItem 对象，详见下文toBlock(); //返回 toBlock 对象，详见下文onUse(state); // state - function 类型，为物品注册使用回调（点击方块时触发），返回该 ItemStack 自身getMaxStack(); //返回 number 类型，该物品的最大堆叠数量only(state); // state - function 类型，合成条件，详见下文，返回该 ItemStack 自身transformDamage(damage); // damage - number 类型，设置物品在合成时增加的损坏值（或指消耗的耐久值），仅调用该方法而不传入参数将设置为1，返回该 ItemStack 自身reuse(); //设置该物品在合成中不会消耗，返回该 ItemStack 自身// toItem 对象有以下方法getMaxDamage(); //返回 number 类型，该物品的最大特殊值/损坏值isTool(); //返回 boolean 类型，该物品是否为工具（包含武器，装备等）// toBlock 对象有以下方法onPlace(state); // state - function 类型，为方块注册放置回调，返回该 toBlock 自身getTileID(); //返回 number 类型，该方块的数字ID（范围[0, 2048]）//回调相关示例，合成相关示例见下文//极为经典的铁剑点地爆炸，因为在CrT所创建的沙盒中无法使用CEAPI，因此使用Rhino提供的调用Java的功能直接调用Java方法$(&quot;item:iron_sword&quot;).onUse(function (coords, item, block, isExternal, player) &#123; com.zhekasmirnov.innercore.api.NativeAPI.explode(coords.x, coords.y, coords.z, 10, true);&#125;);//在基岩上放置基岩时爆炸$(&quot;block:bedrock&quot;).toBlock().onPlace(function (coords, item, block, player, region) &#123; let pos = coords.relative; if (!region.getBlock(pos.x, pos.y, pos.z).id) &#123; region.setBlock(pos.x, pos.y, pos.z, $(&quot;block:bedrock&quot;).id, 0); if (block.id === $(&quot;block:bedrock&quot;).id) &#123; region.explode(pos.x, pos.y + 1, pos.z, 100, false); &#125; &#125;&#125;); requirerequire可用于获取CrT的自定义API，在没有其他模组添加API的情况下，默认可获取的API有furnace和recipes 格式：1require(&quot;api_name&quot;); //返回 api_name 对象 用法：123//因为一般情况下只需要获取一次API对象，而且没有修改名称的必要，故赋值为常量const Furnace = require(&quot;furnace&quot;); //CrT预置的熔炉类const Recipes = require(&quot;recipes&quot;); //CrT预置的合成类 下面将详细介绍furnace和recipes的详细用法 furnace12345678910111213//我们已经获取到了 furnace 对象并赋值给 Furnace，为方便，下文均使用 Furnace// Furnace 有三条函数可用Furnace.remove(input); // input - ItemStack 类型，输入物品，移除某物品的熔炉配方Furnace.addRecipe(input, output); // input - ItemStack 类型，输入物品，output - ItemStack 类型，输出物品，添加一条熔炉配方Furnace.setFuel(input, time); // input - ItemStack 类型，燃料物品，time - number 类型，燃烧时间，设置某物品作为燃料的燃烧时间//举例：Furnace.remove($(&quot;block:iron_ore&quot;)); //移除铁矿石的熔炉配方Furnace.addRecipe($(&quot;item:rotten_flesh&quot;), $(&quot;item:leather&quot;)); //经典的腐肉烧皮革Furnace.setFuel($(&quot;block:hay_block&quot;), 900); //将干草块设置为燃料，燃烧时间为4.5个物品//注：200燃烧时间为一个物品 recipes12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//同上，下文均使用Recipes//至此，我们可以说明上文的一些“详见下文”了// Recipes 有三条函数可用Recipes.remove(output); // output - ItemStick 类型，输出物品，移除某物品的合成配方Recipes.addShaped(output, input); // output - ItemStack 类型，输出物品，input - array 类型，包含输入物品的二维数组，添加有序合成Recipes.addShapeless(output, item); // output - ItemStack 类型，输出物品，input - array 类型，包含输入物品的一维数组，添加无序合成//举例：//移除工业模组中铜块合成配方（该函数在目前版本的IC暂不可移除原版合成配方）Recipes.remove($(&quot;block:blockCopper&quot;));/* 添加基岩的合成配方，摆放方式如下所示 * ABA * BAB * ABA * 其中 A 代表黑曜石，B 代表石头 */Recipes.addShaped($(&quot;block:bedrock*3&quot;), [[$(&quot;block:obsidian&quot;), $(&quot;block:stone&quot;), $(&quot;block:obsidian&quot;)], [$(&quot;block:stone&quot;), $(&quot;block:obsidian&quot;), $(&quot;block:stone&quot;)], [$(&quot;block:obsidian&quot;), $(&quot;block:stone&quot;), $(&quot;block:obsidian&quot;)]]);//你可以像下面这样写成多行以便阅读Recipes.addShaped($(&quot;block:bedrock*3&quot;), [ [$(&quot;block:obsidian&quot;), $(&quot;block:stone&quot;), $(&quot;block:obsidian&quot;)], [$(&quot;block:stone&quot;), $(&quot;block:obsidian&quot;), $(&quot;block:stone&quot;)], [$(&quot;block:obsidian&quot;), $(&quot;block:stone&quot;), $(&quot;block:obsidian&quot;)]]);//对于不需要放物品的格子，留空或者填null即可/* 添加用石头合成石镐的合成配方，摆放方式如下所示 * AAA * B * B * 其中 A 代表石头，B 代表木棍 *///如果你有够强迫症可以写这样（虽然对于强迫症我更建议写到一行，眼不见心不烦）Recipes.addShaped($(&quot;item:stone_pickaxe&quot;), [ [$(&quot;block:stone&quot;), $(&quot;block:stone&quot;), $(&quot;block:stone&quot;)], [null , $(&quot;item:stick&quot;) , null ], [null , $(&quot;item:stick&quot;) , null ]]);//添加有不被消耗物品的合成//使用铁锭和海洋之心合成三叉戟，其中海洋之心可以重复使用Recipes.addShaped($(&quot;item:trident&quot;), [[$(&quot;item:iron_ingot&quot;), $(&quot;item:iron_ingot&quot;), $(&quot;item:iron_ingot&quot;)], [null, $(&quot;item:heart_of_the_sea&quot;).reuse(), null], [null, $(&quot;item:iron_ingot&quot;), null]]);//添加无序合成与有序合成的方式十分相像，而且在添加输入物品时可以设置数量（有序合成则只能设置输出物品的数量），但要注意的是输入物品的总数不能超过9个//截止至V1.1.0版本的CrT，有设置输入物品数量的配方会有部分物品不会消耗的BUG//为蘑菇煲添加两条合成配方，使其只需要任意两个蘑菇即可合成Recipes.addShapeless($(&quot;item:mushroom_stew&quot;), [$(&quot;block:brown_mushroom&quot;), $(&quot;block:brown_mushroom&quot;), $(&quot;item:bowl&quot;)]);Recipes.addShapeless($(&quot;item:mushroom_stew&quot;), [$(&quot;block:red_mushroom&quot;), $(&quot;block:brown_mushroom&quot;), $(&quot;item:bowl&quot;)]);//添加消耗物品耐久的配方//使用毒马铃薯合成马铃薯，并消耗剪刀1耐久值//特殊值-1代表任意特殊值均可Recipes.addShapeless($(&quot;item:potato&quot;), [$(&quot;item:shears:-1&quot;).transformDamage(), $(&quot;item:poisonous_potato&quot;)]);//自定义合成事件//使用水桶与爆裂紫颂果合成紫颂果，并返还桶Recipes.addShapeless($(&quot;item:chorus_fruit&quot;), [$(&quot;item:chorus_fruit_popped&quot;), $(&quot;item:water_bucket&quot;).only(function (api, index, item, output) &#123; item.id = $(&quot;item:bucket&quot;).id;&#125;)]);//木板与剪刀合成随机1-4根木棍并消耗剪刀相应的耐久值Recipes.addShapeless($(&quot;item:stick&quot;), [$(&quot;block:planks&quot;), $(&quot;item:shears:-1&quot;).only(function (api, index, item, output) &#123; let count = Math.floor(Math.random() * 4) + 1; let max = $(&quot;item:shears&quot;).toItem().getMaxDamage(); item.data += count; if (item.data &gt;= max) &#123; count += max - item.data; item.id = item.data = item.count = 0; &#125; output.count = count;&#125;)]); 模组联动如果你是模组开发者，你可以通过ModAPI调用CrT提供的方法来拓展CrT 1234//CrT有以下方法可以通过ModAPI调用addAPI(name, state); // name - string 类型，API名称，state - object 类型，API对象，像CrT添加自定义API以在脚本中使用require(name); // name - string 类型，API名称，同上文requirerequireGlobal(command); // command - string 类型，要执行的代码，在CrT的中执行一段代码，慎用 好了，你已经学会如何使用CrT了，快去试着制作整合包吧！","categories":[],"tags":[]},{"title":"模组集","slug":"模组集","date":"2022-01-01T10:12:49.659Z","updated":"2022-01-01T12:56:17.977Z","comments":true,"path":"2022/01/01/模组集/","link":"","permalink":"https://weifeng233.github.io/2022/01/01/%E6%A8%A1%E7%BB%84%E9%9B%86/","excerpt":"","text":"模组集是在2.2.1b85更新中加入的功能。 功能概述模组集将一些互相兼容的模组整合为一个整体，通常包含附加代码或者模组以提高模组集成度和游戏玩法一致性。 在此更新中，模组将无法安装在模组集之外，因此InnerCore会创建一个默认模组集，你可以在其之中找到你之前安装的所有模组并通过模组管理器添加新模组。你可以到模组管理器的我的模组集中下载现成的模组集。要加载一个模组集只需要点击模组集页面上的选择按钮。 无论何时都只能加载一个模组集。模组集默认到受更改保护，即模组集内的模组不会被模组管理器更新除非模组集有更新，以及你不能向模组集移除或添加模组，如果你尝试这样做会出现如下警告： 只有当你明白你在做什么时才允许修改模组集，当模组集被修改之后，模组集中的模组将开启更新功能，同时模组集会失去更新功能。 创建你自己的模组集你可以基于现有的模组集或默认模组集来创建你自己的模组集。使用模组集页面的克隆选项即可完成此工作（在目前版本中，部分设备可能无法克隆默认模组集，下文会讲如何使用文件管理器手动操作） 生成的模组集会在对应的InnerCore包的modpacks文件夹内。接下来你可以使用模组管理器来安装所需的模组，也可以将你自己编写的模组添加到模组集的mods文件夹中。除此之外，你还可以添加模组集图标pack_icon.png，以及必须创建模组集清单文件modpacks.json，其中可包含以下字段： name - 模组集的短名称，将会作为其ID displayedName - 模组集的展示名称 versionName - 模组集当前的版本名称 versionCode - 模组集当前的版本号 author - 模组集的作者名称 description - 模组集的简介 示例： 12345678&#123; &quot;name&quot;: &quot;coop-tech&quot;, &quot;displayedName&quot;: &quot;Cooperative Tech&quot;, &quot;versionName&quot;: &quot;1.01-beta​&quot;, &quot;versionCode&quot;: 2, &quot;author&quot;: &quot;zheka_smirnov&quot;, &quot;description&quot;: &quot;Simple small modpack, that contains few tech and utility mods and supports multiplayer.&quot;&#125; 一旦模组集构建完成，可以使用模组集界面内的压缩文件选项创建一个压缩存档保存在对应InnerCore包的modpacks-archive文件夹内，你可以在模组管理器的模组集页面重装模组集的压缩文档。 模组配置首先，你应该知道每个ICMod都有一个config.json文件用于存储的模组的配置信息，在模组集中应将模组的压缩文件统一放在模组集的config文件夹内，并按模组文件夹名-config.json的格式命名（文件夹名称中的空格需要使用-代替），此外，你还可以在该文件夹中创建一个.keep-unchanged文件夹用于存放不允许玩家修改的配置信息。 注意：如果一个模组的配置信息不在config文件夹内时InnerCore会自动创建一个仅包含enabled字段的json文件，此操作可能会使模组无法读取到需要的配置信息而导致报错。","categories":[],"tags":[]},{"title":"使用JavaScript实现的MCBE史莱姆区块算法","slug":"使用JavaScript实现的MCBE史莱姆区块算法","date":"2021-08-29T15:11:08.237Z","updated":"2022-01-11T16:53:28.415Z","comments":true,"path":"2021/08/29/使用JavaScript实现的MCBE史莱姆区块算法/","link":"","permalink":"https://weifeng233.github.io/2021/08/29/%E4%BD%BF%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E7%9A%84MCBE%E5%8F%B2%E8%8E%B1%E5%A7%86%E5%8C%BA%E5%9D%97%E7%AE%97%E6%B3%95/","excerpt":"","text":"直接将origin0110使用C的代码简单地用JS写一遍，在此记录： 2022/1/12：减少不必要的转无符号运算 12345678910111213141516171819function getSeed(x, z) &#123; return x * 0x1f1f1f1f ^ z;&#125;function isSlimeChunk(s) &#123; let m = 1 + Math.imul(s ^ s &gt;&gt;&gt; 30, 0x6c078965); s = s &amp; 0x80000000 | m &amp; 0x7fffffff; for (let i = 2; i &lt; 398; i++) m = i + Math.imul(m ^ m &gt;&gt;&gt; 30, 0x6c078965); m ^= (s &gt;&gt;&gt; 1) ^ (s &amp; 1 ? 0x9908b0df : 0x0); m ^= m &gt;&gt;&gt; 11; m ^= m &lt;&lt; 0x7 &amp; 0x9d2c5680; m ^= m &lt;&lt; 0xf &amp; 0xefc60000; m ^= m &gt;&gt;&gt; 18; return !((m &gt;&gt;&gt; 0) % 10);&#125;","categories":[],"tags":[]},{"title":"UI PART2","slug":"UI-2","date":"2021-08-13T17:51:44.941Z","updated":"2021-08-29T15:18:35.562Z","comments":true,"path":"2021/08/14/UI-2/","link":"","permalink":"https://weifeng233.github.io/2021/08/14/UI-2/","excerpt":"","text":"注意：本教程仅为简单介绍UI的窗口，不会涉及详细的函数。如果想要了解更多请阅读官方文档。 在上期教程中我们简要介绍了ICMod的UI构成与基本控件，接下来将详细介绍控件用法以及如何组成一个“精美”的界面。 StandardWindow在此纠正上一篇专栏的严重错误：StandartWindow在现在版本的InnerCore中已经弃用，使用StandardWindow替代。 你可以永远相信StandardWindow。 —Prosto Sostavil StandardWindow是一个由三部分组成的WindowGroup，分别为main, inventory和header，对应关系如下图： Standard样式与原版的PocketUI相似，默认自带一个展示玩家背包的可滑动界面以及常规的关闭界面按钮和界面名称等，非常适合用作一般的方块实体的互动界面。 在此使用工业的火力发电机界面作为示例： 这是一个简单的界面，但基本上包含了常用控件，让我们简要分析一下其代码： 123456789101112131415161718192021//源码使用TypeScript编写且分不同部分在多个文件中，为方便讲解取主要代码并使用JavaScript重写const GUI_SCALE = 3.2; //声明GUI_SCALE常量，以便统一模组内各界面new UI.StandardWindow(&#123; standard: &#123; header: &#123;text: &#123;text: Translation.translate(&quot;Generator&quot;)&#125;&#125;, //此处使用Translate类函数以实现多语言，详见官方文档 inventory: &#123;standard: true&#125;, background: &#123;standard: true&#125; &#125;, drawing: [//两个scale元素对应的当其为空时的贴图 &#123;type: &quot;bitmap&quot;, x: 530, y: 144, bitmap: &quot;energy_bar_background&quot;, scale: GUI_SCALE&#125;, &#123;type: &quot;bitmap&quot;, x: 450, y: 150, bitmap: &quot;fire_background&quot;, scale: GUI_SCALE&#125;, ], elements: &#123; &quot;energyScale&quot;: &#123;type: &quot;scale&quot;, x: 530 + GUI_SCALE * 4, y: 144, direction: 0, value: 0.5, bitmap: &quot;energy_bar_scale&quot;, scale: GUI_SCALE&#125;, //注意此处x的值比对应的bitmap加了GUI_SCALE*4，这是因为它的贴图两端各少了4个像素，以便完整显示进度 &quot;burningScale&quot;: &#123;type: &quot;scale&quot;, x: 450, y: 150, direction: 1, value: 0.5, bitmap: &quot;fire_scale&quot;, scale: GUI_SCALE&#125;, &quot;slotEnergy&quot;: &#123;type: &quot;slot&quot;, x: 441, y: 75&#125;, &quot;slotFuel&quot;: &#123;type: &quot;slot&quot;, x: 441, y: 212&#125;, &quot;textInfo1&quot;: &#123;type: &quot;text&quot;, x: 642, y: 142, width: 300, height: 30, text: &quot;0/&quot;&#125;, &quot;textInfo2&quot;: &#123;type: &quot;text&quot;, x: 642, y: 172, width: 300, height: 30, text: &quot;10000&quot;&#125; &#125;&#125;); 可以看出在StandardWindow中使用的是绝对坐标，而且可与贴图像素对应，因此只需要耐心的慢慢调整就能够得到一个不错的界面。 与方块实体互动此部分不是本教程的主要内容，因此将简要带过。 在IC中，注册方块实体的函数为TileEntity.registerPrototype(blockID: number, customPrototype: TileEntityPrototype): void，参数只有两个：方块ID和方块实体原型。 方块实体原型是一个JS对象，包含方块实体的数据和事件。要将创建的StandardWindow对象与方块实体绑定则需要在方块实体原型中设置getGuiScreen函数并返回界面对象。这样IC会自动为该界面对象创建相应的容器对象，你可以在方块实体原型的函数中使用this.container来获得容器对象并使用其提供的方法与界面交互。 更进一步StandardWindow的可玩性远不止如此，你可以试着除去StandardWindow的默认控件，并从0开始自定义界面，或者在方块实体原型的getGuiScreen方法中编写逻辑以使在不同的情况下打开不同的界面。 示例为我去年3月份初次尝试UI时所写的会根据MC设置的UI档案切换StandardWindow的方块实体（PS：图二的界面标题有偏移Bug，在之后的版本中已被修复）。整个界面从开始构思到完成大概用了5天时间(大部分时间用在编写库上，但如今得益于WindowGroup，可以更快地完成该任务。 WindowWindow是最基本的窗口，相较于StandardWindow，Window更为灵活，适合用作弹窗或者HUD。 在创建一个Window对象的时候，可以像StandardWindow那样传入一个包含Drawing和Elements等的对象。但能够突出Window特色的是location参数，你可以自定义Window的大小，在屏幕上的位置，内边距和可滑动窗口大小（PS：Window内的unit为此Window宽度的千分之一）。 值得一提，内边距padding的会覆盖x|y|width|height的效果。 举个简单的空白窗口界面的例子： 1234567891011121314151617181920212223//定义一些常量const GUI_SCALE = 5;const WIDTH = 1000;const HEIGHT = UI.getScreenHeight();//创建窗口let testWindow = new UI.Window(&#123; location: &#123; //此处运算是为方便居中 x: (WIDTH - 300) / 2, y: (HEIGHT - 225) / 2, width: 300, height: 225 &#125;, drawing: [ //贴图是从拆原版包扒的XD &#123;type: &quot;background&quot;, color: android.graphics.Color.TRANSPARENT&#125;, &#123;type: &quot;frame&quot;, bitmap: &quot;background_panel&quot;, width: 1000, height: 750, scale: GUI_SCALE&#125; ], elements: &#123; &quot;closeButton&quot;: &#123;type: &quot;closeButton&quot;, x: 904, y: 26, bitmap: &quot;close_button_default&quot;, bitmap2: &quot;close_button_pressed&quot;, scale: GUI_SCALE&#125; &#125;&#125;);//一些常规设置testWindow.setCloseOnBackPressed(true);testWindow.setBlockingBackground(true); 效果图： TabbedWindowTabbedWindow可用于创建标签式窗口，如原版的玩家背包一样，具有多个可切换的标签页。 TabbedWindow和StandardWindow一样，都继承自WindowGroup。在创建TabbedWindow对象时，所传入的参数与Window相同，与之不同的是TabbedWindow多了一些函数。 使用new UI.TabbedWindow()创建一个空白的TabbedWindow，效果如下（PS：部分异形屏可能会被遮挡部分边界）： 简单地说明一下这个窗口，左上角的关闭按钮是一个索引值为0的FakeTab（PS：FakeTab指没有对应标签页的标签），标签页的上限为12个，即索引值的范围为0-11（左侧为0-5，右侧为6-11）。 要添加一个标签页可以使用setTab(index: number, tabOverlay: ElementSet, tabContent: WindowContent, isAlwaysSelected?: boolean): void函数，index即标签页的索引值，tabOverlay是标签的元素集（如关闭按钮），tabContent即为标签页展示的窗口内容，格式与之前介绍的基本无异。 因为setTab函数并不返回创建的Window对象，所以你需要用到getWindowForTab(index: number): Window来函数获取对应索引值的Window实例化对象，以完成对其的动态修改。 WindowGroupWindowGroup是StandardWindow和TabbedWindow的父类，其方法基本上都可以在StandardWindow和TabbedWindow中使用。 WindowGroup诞生的目的是为了能够将复杂的界面模块化，以便提高代码的复用率并降低调试难度，使开发效率提高，最为典型的例子就是IC中的工作台界面（PS：此处不谈其交互逻辑，仅谈其界面）。 该界面由三部分组成，分别为Main·，Slots和Grid，对应下图中的青色，粉色和黄色部分： 阅读workbench.js中工作台界面部分的代码，可以看出该三部分都是先定义WindowContent的JSON描述，然后一一创建Window对象，并使用addWindowInstance(name: string, window: Window): void函数将Window对象添加到WindowGroup对象并声明其对应的名称ID。你也可以直接使用addWindow(name: string, content: WindowContent): Window函数向WindowGroup添加窗口。 至此，关于UI界面的内容就基本上介绍完毕，当然全部内容不止这些，你需要认真地查阅官方文档以及去学习他人的优秀作品。另外，虽然本教程对于UI与容器的互动只是简单地带过，但此部分内容是相当重要的，应当注重学习（PS：谁让你们当时评论不提容器和方块实体呢XD）。","categories":[],"tags":[]},{"title":"UI PART1","slug":"UI-1","date":"2021-06-26T06:57:07.355Z","updated":"2021-06-26T07:03:05.492Z","comments":true,"path":"2021/06/26/UI-1/","link":"","permalink":"https://weifeng233.github.io/2021/06/26/UI-1/","excerpt":"","text":"Try hard. -Zheka Smirnov 本文的部分名词与描述或许与别处有出入以至于错误，欢迎在评论区指出 相较于原版MC，IC的UI系统并不有多复杂，可简单地用下图概括 尽管这张图看似过于简略，但事实的确如此。快速掌握UI的基本控件等内容并不困难，但难点是如何用它们拼凑出美观且实用的用户界面 PS：本文不会讲到每一个控件及其函数，更详细的内容可见官方文档 首先在IC中，用户界面的控件的大小和单位都是使用同一的unit单位，1unit = 窗口宽度/1000 UI资源UI所使用到的贴图存放于构筑文件(build.config)所指定的gui类型的资源文件夹，在使用时只需要输入文件名即可(不包含后缀与文件夹) 除此之外，还有： color: 颜色，即Android的Color类，可使用android.graphics.Color.rgb(r, g, b)等自定义颜色 font: 字体，包含三个属性，{size: 文本大小, color: 文本颜色, shadow: 文本阴影}，其中文本阴影为范围[0, 1]的浮点数 frame: 边框，一般使用大小为16x16的贴图，在使用时会被自动拉伸至所需大小 DrawingDrawing，顾名思义就是在界面中进行绘制，在UI的描述对象中Drawing为一个包含绘制指令的数组 描述对象：用于设定UI以及在UI打开时对其进行动态修改 123456//格式drawing: [ &#123;/*指令1*/&#125;, &#123;/*指令2*/&#125;, ...] 常用标准指令如下： 123456&#123;type: &quot;background&quot;, color: 颜色&#125; //填充背景颜色&#123;type: &quot;bitmap&quot;, bitmap: 贴图, x: Number, y: Number, width: Number, height: Number, scale: Number&#125; //绘制贴图，scale - 贴图像素和unit的缩放比例，默认1像素=1unit&#123;type: &quot;frame&quot;, x: Number, y: Number, width: Number, height: Number, bitmap: 贴图, bg: 颜色, scale: Number&#125; //绘制边框，bg - 边框背景颜色&#123;type: &quot;text&quot;, text: String, x: Number, y: Number, font: 字体&#125; //绘制文本&#123;type: &quot;line&quot;, x1: Number, y1: Number, x2: Number, y2: Number, width: Number, height: Number, color: 颜色&#125; //绘制直线，width - 直线粗细&#123;type: &quot;custom&quot;, onDraw: Function(canvas, scale)&#125; //自定义绘制，onDraw - 在绘制时调用的函数，传参包括当前绘制的Canvas对象和scale数值，无返回值 PS：custom drawing的canvas为Android的Canvas类 ElementsElements，指UI中的控件，与Drawing不同的是Elements在描述对象里为一个包含各控件的对象 Elements中的每一个控件都有其唯一且独特的名称，即每一个对象都有其唯一的建 123456//格式elements: &#123; &quot;名称1&quot;: &#123;/*元素1*/&#125;, &quot;名称2&quot;: &#123;/*元素2*/&#125;, ...&#125; 每一个元素都有以下基本属性： 1234567&#123; type: &quot;type&quot;, //元素类型 x: number, //x坐标 y: number, //y坐标 z: number, //z坐标，用于区分控件层次防止混乱重叠 clicker: Click对象 //控件点击对象&#125; 此处控件点击对象指一个包含短时点击事件和长时点击事件函数的对象： 12345678910&#123; onClick: function(position, container, tileEntity, window, canvas, scale) &#123; //container - 界面打开的容器 //tileEntity - 如果界面是为某方块实体打开的，它就会传出它，否则传出null &#125;, onLongClick: function(position, container, tileEntity, window, canvas, scale) &#123; //container - 界面打开的容器 //tileEntity - 如果界面是为某方块实体打开的，它就会传出它，否则传出null &#125;&#125; 同样地，常用元素如下： 123456789&#123;type: &quot;slot&quot;, x: Number, y: Number, size: Number, visual: Boolean/Function(id, data, count), bitmap: 贴图, clicker: Click对象&#125; //物品格，visual - 是否可选中&#123;type: &quot;invSlot&quot;, x: Number, y: Number, size: Number, index: Number, bitmap: 贴图&#125; //背包物品格，index - 对应背包物品格id&#123;type: &quot;button&quot;, x: Number, y: Number, bitmap: 贴图, bitmap2: 贴图, scale: Number, clicker: Click对象&#125; //按钮，bitmap2 - 按下时贴图，button的Click对象与其他的稍有不同，其点击事件函数的参数为(container, tileEntity, position, window, canvas, scale)&#123;type: &quot;closeButton&quot;, x: Number, y: Number, global: Boolean, bitmap: 贴图, bitmap2: 贴图, scale: Number&#125; //关闭窗口按钮，global - 为真时将关闭窗口组内所有窗口，否则只关闭所在单窗口，详见下文&#123;type: &quot;scale&quot;, x: Number, y: Number, direction: Number, bitmap: 贴图, scale: Number, invert: Number, overlay: 贴图, overlayScale: Number, overlayOffset: &#123;x: Number, y: Number&#125;&#125; //刻度表或进度栏，direction - 朝向，详见下文，invert - 是否翻转贴图，overlay - 重叠在scale上的贴图，Scale和Offset分别为其缩放比例和相对scale元素的位置&#123;type: &quot;text&quot;, x: Number, y: Number, width: Number, height: Number, text: String, font: 字体&#125; //文本&#123;type: &quot;fps&quot;, interpolate: Boolean, period: Number, font: 字体, multiline: Boolean, format: Boolean, maxCharsPerLine: Number&#125;//FPS文本&#123;type: &quot;image&quot;, x: Number, y: Number, bitmap: 贴图, scale: Number, overlay: 贴图, overlayScale: Number, overlayOffset: &#123;x: Number, y: Number&#125;, clicker: Click对象&#125; //贴图&#123;type: &quot;custom&quot;, onSetup: Function(element: Element), onDraw: Function(element, canvas, scale), onTouchReleased: Function(element), onBindingUpdated: Function(element, name, value), onReset: Function(element), onRelease: Function(element), onContainerInit: Function(element, container, elementName)&#125;//自定义元素，各函数均无返回值 除以上元素之外，还有Scroll，Switch，Tab等元素未被提及，但用法大同小异，建议自行按照官方文档进行尝试，这样才是最有效率的学习方法 direction参数: 0 - 朝右1 - 朝上2 - 朝左3 - 朝下 在简要介绍完Drawing和Elments后，在介绍重头戏Window之前先来补充一点其他内容 自定义参数用于修改Window的一些默认参数，如下： 12345678params: &#123; slot: &quot;格子贴图&quot;, invSlot: &quot;背包格子贴图&quot;, frame: &quot;平面边框贴图&quot;, selection: &quot;格子高亮贴图&quot;, closeButton: &quot;关闭按钮贴图&quot;, closeButton2: &quot;按下的关闭按钮贴图&quot;,&#125; UI.getContext()该函数用于获取Android UI线程的上下文，以便调用Android API来操控界面控件 UI.getScreenHeight()获取以unit为单位的屏幕高度，与之相同的还有UI.getScreenRelativeHeight() ElementSet元素集合 WindowLocation窗口位置及大小，使用unit作为单位，详细参数见官方文档 Style窗口风格，有CLASSIC和DEFAULT两种 Slot，FullSlot窗口中的物品格对象，Slot包含物品的id、特殊值、数量和额外数据，FullSlot则在其基础上添加了如drop、set等方法 Window在官方文档中，窗口(Window)有如下几个类： StandardWindow StandartWindow TabbedWindow Window WindowGroup 在这里将暂先略讲StandartWindow，Window和WindowGroup StandartWindow定义为UI.StandartWindow类，以一个描述对象定义界面 描述对象格式(摘自BigFish和方法放寒假翻译的官方Wiki第8-2节)： 123456789101112131415161718192021222324252627282930&#123; standart: &#123;//这种类型的界面标准参数在这里写入，它们允许你快速地设置基本的元素，例如标题、背景和背包 //如果你想定义标准的元素，但是又不想改变默认值，那么就单写上值 - standart: true，例如inventory: &#123;standart: true&#125; header: &#123;//设定你是否需要一个标头，包含一个标题和和一个关闭按钮 text: &#123;//必需的参数，如果你定义了标头 text: &quot;标题文本&quot;, //文本内容，必需的参数 &#125;, Font: &#123;...&#125;, //文本字体，如果你想改变默认值，就请定义它 color: 颜色, //只有当你想改变标题颜色的时候才需要 frame: &quot;边框文本&quot;, //只有当你想改变标头边框的时候才需要 width: 80, //表头的高度，以unit为单位 hideButton: true, //定义并设置为true则移除关闭按钮 &#125;, inventory: &#123;//要想定义标准背包，请使用inventory: &#123;standart: true&#125; width: 300, //背包窗口的宽度 padding: 20, //背包窗口的内边距 &#125;, background: &#123;//要定义一个默认背景，请使用background: &#123;standart: true&#125; color: 颜色, //如果你想改变背景的颜色就定义它 bitmap: &quot;背景图片&quot;, //如果你想添加一个背景图片就定义它 frame: &quot;边框贴图&quot; //如果你想添加一个边框就定义它 &#125;, minHeight: 650, //如果以unit为单位的窗口高度小于这个参数的值，那么窗口将自动转变为滚动窗口，以此来保证它的内部大小的高度为minHeight units &#125;, params: &#123; //自定义（改变默认材质） &#125;, drawing: [/*背景渲染指令*/], elements: &#123;/*元素的描述*/&#125;&#125; StandartWindow是适用性最高的窗口，在多人游戏中表现优于Window，但尽管如此绝对布局仍是其一大缺点，在实际使用时需要考虑到不同的屏幕尺寸会造成的控件偏移。因此，尽量将控件放置在屏幕内部区域 Window相较于StandartWindow，Window的优点在于其灵活性，与默认为方块互动界面的StandartWindow不同，Window可以通过修改WindowLocation来显示在游戏界面上的任意位置，且可以通过适当修改padding值来尽可能避免控件偏移。 Window默认没有关闭按钮和玩家背包栏，在使用时需要按需自行添加 WindowGroupStandartWindow和Window都是单个窗口，如果需要复杂的界面那么用多个窗口组合无疑是最最好的选择，将一个复杂窗口分为多个小窗口也可以提高调试效率。 WindowGroup的主要作用就是将多个Window整合在一起，将其组合布局在一起，例如现在的工作台界面就是一个包含3个Window的WindowGroup Hierarchic UI库HierarchicUI由Zheka开发，用于以json来定义分层式的UI，可以方便的创建绝对布局和线性布局，届时json会被解析为WindowGroup 此外，该库还可以定义视图布局并且对于一个视图可以灵活地嵌入到其他界面，并且基于它创建继承其全部属性的子视图，无疑让WindowGroup展示美观的复杂界面更加容易。","categories":[],"tags":[]}],"categories":[],"tags":[]}