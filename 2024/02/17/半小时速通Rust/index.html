<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>半小时速通Rust | Hexo</title>
  <meta name="description" content="编程语言不学Rust，就如同游戏不玩原神  本文翻译自A half-hour to learn Rust  letlet用于声明变量绑定(binding) 12let x; &#x2F;&#x2F; 声明 xx &#x3D; 42; &#x2F;&#x2F; 将 42 赋值给 x 也可以写成一行： 1let x &#x3D; 42; 可以通过:来显式指定变量类型，即类型注释： 1234let x: i32; &#x2F;&#x2F; &#96;i32&#96; 为 32 位有符号整型x &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="半小时速通Rust">
<meta property="og:url" content="https://weifeng233.github.io/2024/02/17/%E5%8D%8A%E5%B0%8F%E6%97%B6%E9%80%9F%E9%80%9ARust/index.html">
<meta property="og:site_name" content="微风的博客">
<meta property="og:description" content="编程语言不学Rust，就如同游戏不玩原神  本文翻译自A half-hour to learn Rust  letlet用于声明变量绑定(binding) 12let x; &#x2F;&#x2F; 声明 xx &#x3D; 42; &#x2F;&#x2F; 将 42 赋值给 x 也可以写成一行： 1let x &#x3D; 42; 可以通过:来显式指定变量类型，即类型注释： 1234let x: i32; &#x2F;&#x2F; &#96;i32&#96; 为 32 位有符号整型x &#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-02-16T19:20:11.922Z">
<meta property="article:modified_time" content="2024-02-16T19:21:26.931Z">
<meta property="article:author" content="SugarBreeze">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="https://weifeng233.github.io/2024/02/17/%E5%8D%8A%E5%B0%8F%E6%97%B6%E9%80%9F%E9%80%9ARust/index.html">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="微风的博客" type="application/atom+xml">
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/weifeng233" target="_blank">
          <img class="img-circle img-rotate" src="/images/ava.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Sugar Breeze</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">MCBE Modder.</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Henan, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/weifeng233" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2024/02/17/%E5%8D%8A%E5%B0%8F%E6%97%B6%E9%80%9F%E9%80%9ARust/" class="title">半小时速通Rust</a>
              </p>
              <p class="item-date">
                <time datetime="2024-02-16T19:20:11.922Z" itemprop="datePublished">2024-02-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2024/01/18/zote-core-loader/" class="title">InnerCore 第三方服务端 Zote Core 介绍</a>
              </p>
              <p class="item-date">
                <time datetime="2024-01-18T07:41:04.712Z" itemprop="datePublished">2024-01-18</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/06/09/%E9%A6%99%E8%8D%89%E9%A3%8E%E6%A0%BC%E6%A8%A1%E7%BB%84%E6%8C%87%E5%8D%97/" class="title">香草风格模组指南</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-09T02:44:55.497Z" itemprop="datePublished">2023-06-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/02/19/%E6%97%A0%E7%94%A8%E9%97%B2%E8%AF%9D/" class="title">一些关于InnerCore的闲话</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-18T16:35:06.127Z" itemprop="datePublished">2023-02-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/08/03/CoreUtility/" class="title">Core Utility（渣翻预警）</a>
              </p>
              <p class="item-date">
                <time datetime="2022-08-03T10:23:19.603Z" itemprop="datePublished">2022-08-03</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-半小时速通Rust" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      半小时速通Rust
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2024/02/17/%E5%8D%8A%E5%B0%8F%E6%97%B6%E9%80%9F%E9%80%9ARust/" class="article-date">
	  <time datetime="2024-02-16T19:20:11.922Z" itemprop="datePublished">2024-02-17</time>
	</a>
</span>
        
        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2024/02/17/%E5%8D%8A%E5%B0%8F%E6%97%B6%E9%80%9F%E9%80%9ARust/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 8.5k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 40(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <blockquote>
<p>编程语言不学Rust，就如同游戏不玩原神</p>
</blockquote>
<p><em>本文翻译自<a target="_blank" rel="noopener" href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half-hour to learn Rust</a></em></p>
<hr>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><code>let</code>用于声明变量绑定(<em>binding</em>)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x; <span class="comment">// 声明 x</span></span><br><span class="line">x = <span class="number">42</span>; <span class="comment">// 将 42 赋值给 x</span></span><br></pre></td></tr></table></figure>
<p>也可以写成一行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>:</code>来显式指定变量类型，即类型注释：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">i32</span>; <span class="comment">// `i32` 为 32 位有符号整型</span></span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 在Rust中，整型有 i8, i16, i32, i64, 128</span></span><br><span class="line"><span class="comment">// 以及对应的无符号类型 u8, u16, u32, u64, u128</span></span><br></pre></td></tr></table></figure>
<p>也可以写成一行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>如果你在声明变量后，初始化前使用变量，则会被编译器阻止：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">foobar(x); <span class="comment">// error: borrow of possibly-uninitialized variable: `x`</span></span><br><span class="line">x = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>这样则没问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line">foobar(x); <span class="comment">// `x` 的类型将会根据此处推断</span></span><br></pre></td></tr></table></figure>
<p>下划线<code>_</code>是一个特殊的变量名称，即缺省名称。通常使用<code>_</code>说明丢弃一些东西：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _ = <span class="number">42</span>; <span class="comment">// 将不会做任何事，因为 42 是一个常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _ = get_thing(); <span class="comment">// 调用 `get_thing` 但丢弃返回值</span></span><br></pre></td></tr></table></figure>
<p>变量可以以下划线开头，除了编译器不会警告它们未被使用之外与普通变量名一样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `_x` 可能最终会被用到，但是目前代码还没有完成，并且当前不想看到编译器对其的警告</span></span><br><span class="line"><span class="keyword">let</span> _x = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>可以引入相同名称的变量绑定，进而隐藏原先的变量绑定：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">let</span> x = x + <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 之后使用 `x` 仅指代第二个 `x`， 第一个 `x` 不再存在</span></span><br></pre></td></tr></table></figure>
<h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>元组(<em>Tuple</em>)可以将其视作不同类型值的定长集合：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pair = (<span class="string">&#x27;a&#x27;</span>, <span class="number">17</span>);</span><br><span class="line">pair.<span class="number">0</span> <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">pair.<span class="number">1</span> <span class="comment">// 17</span></span><br></pre></td></tr></table></figure>
<p>若要给元组添加类型注释，则可以：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pair: (<span class="built_in">char</span>, <span class="built_in">i32</span>) = (<span class="string">&#x27;a&#x27;</span>, <span class="number">17</span>);</span><br></pre></td></tr></table></figure>
<p>在进行赋值的时候元组可以被解构，即可以分解为独立的字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (some_char, some_int) = (<span class="string">&#x27;a&#x27;</span>, <span class="number">17</span>);</span><br></pre></td></tr></table></figure>
<p>在函数返回元组时非常有用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (left, right) = slice.split_at(middle);</span><br></pre></td></tr></table></figure>
<p>当然，在结构元组的时候也可以使用<code>_</code>来丢弃其中一部分：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (_, right) = slice.split_at(middle);</span><br></pre></td></tr></table></figure>
<h3 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h3><p>分号标志着语句的结束：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> z = x + y;</span><br></pre></td></tr></table></figure>
<p>这意味着语句可以跨越多行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">    .iter()</span><br><span class="line">    .map(|x| x + <span class="number">3</span>)</span><br><span class="line">    .fold(<span class="number">0</span>, |x, y| x + y);</span><br></pre></td></tr></table></figure>
<p>（后文会对其作讲解）</p>
<h3 id="fn"><a href="#fn" class="headerlink" title="fn"></a>fn</h3><p><code>fn</code>用于声明函数<br>这是一个无返回值的函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">greet</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hi there!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个返回 32 位有符号整型的函数。用箭头来表示其返回值类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fair_dice_roll</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>花括号对<code>&#123;&#125;</code>用于声明块(<em>Block</em>)，它有自己的作用域：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该程序会先输出 &quot;in&quot; 然后是 &quot;out&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">&quot;out&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此处是另一个 `x`</span></span><br><span class="line">        <span class="keyword">let</span> x = <span class="string">&quot;in&quot;</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>块也是表达式，这意味着其计算结果也是一个值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两行是等价的</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="number">42</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>在一个块内可以有多条语句：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">1</span>; <span class="comment">// 第一条语句</span></span><br><span class="line">    <span class="keyword">let</span> z = <span class="number">2</span>; <span class="comment">// 第二条语句</span></span><br><span class="line">    y + z <span class="comment">// 这里是*尾巴* - 整个块会被认定的表达式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是为什么”省略函数末尾的分号“与<code>return</code>是相同的，即以下写法是等效的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fair_dice_roll</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fair_dice_roll</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>if</code> 条件也是表达式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fair_dice_roll</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> feeling_lucky &#123;</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>match</code>也是表达式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fair_dice_roll</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> feeling_lucky &#123;</span><br><span class="line">        <span class="literal">true</span> =&gt; <span class="number">6</span>,</span><br><span class="line">        <span class="literal">false</span> =&gt; <span class="number">4</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>表达式总会返回值</strong>，能返回值的就是表达式，表达式不能以分号结尾，否则就变成了语句，不再返回值，若表达式不返回值，则会隐式地返回一个<code>()</code>。<br>点<code>.</code>通常用于访问值的字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = (<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">a.<span class="number">0</span>; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> amos = get_some_struct();</span><br><span class="line">amos.nickname; <span class="comment">// &quot;fasterthanlime&quot;</span></span><br></pre></td></tr></table></figure>
<p>或者对值调用方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nick = <span class="string">&quot;fasterthanlime&quot;</span>;</span><br><span class="line">nick.len(); <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>
<p>双冒号<code>::</code>与其类似，但是它使用在命名空间上。<br>在此示例中，<code>std</code>是一个包(<em>crate</em>)（或者说库），<code>cmp</code>是一个模块(<em>module</em>)（或者说源文件），以及<code>min</code>是一个函数(<em>function</em>)：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> least = std::cmp::min(<span class="number">3</span>, <span class="number">8</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><code>use</code>可用于从其他命名空间引入名称到作用域：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::min;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> least = min(<span class="number">7</span>, <span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>使用<code>use</code>时，花括号还有另一种含义，即 <em>glob</em>。如果我们想同时导入<code>min</code>和<code>max</code>，我们可以使用以下任意一种方式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::min;</span><br><span class="line"><span class="keyword">use</span> std::cmp::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::cmp::&#123;min, max&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::min, cmp::max&#125;;</span><br></pre></td></tr></table></figure>
<p>通配符<code>*</code>允许你从命名空间导入所有符号：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这将会将 `min` 和 `max` 以及许多其他东西导入到当前作用域</span></span><br><span class="line"><span class="keyword">use</span> std::cmp::*;</span><br></pre></td></tr></table></figure>
<p>类型也是命名空间，方法可以作为常规函数调用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">&quot;amos&quot;</span>.len(); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="built_in">str</span>::len(<span class="string">&quot;amos&quot;</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p><code>str</code>是原始类型，但默认情况下许多非原始类型也包含在作用域内：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `Vec` 是一个常规的结构体，不是原始类型</span></span><br><span class="line"><span class="keyword">let</span> v = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上面的代码相同，但是使用了 `Vec` 的完整路径</span></span><br><span class="line"><span class="keyword">let</span> v = std::vec::<span class="built_in">Vec</span>::new();</span><br></pre></td></tr></table></figure>
<p>这之所以有效是因为 Rust 会在每个模块的开头插入以下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::prelude::v1::*;</span><br></pre></td></tr></table></figure>
<p>这会重新导出很多符号，例如<code>Vec</code>，<code>String</code>，<code>Option</code>和<code>Result</code>。</p>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>结构体使用<code>struct</code>关键字声明：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f64</span>, <span class="comment">// 64 位浮点数，即双精度</span></span><br><span class="line">    y: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它们可以通过结构体字面量初始化：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1 = Vec2 &#123; x: <span class="number">1.0</span>, y: <span class="number">3.0</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> v2 = Vec2 &#123; y: <span class="number">2.0</span>, x: <span class="number">4.0</span>&#125;;</span><br><span class="line"><span class="comment">// 顺序不需要关注，只需要关注名称</span></span><br></pre></td></tr></table></figure>
<p>有一种简便写法可以从另一个结构体初始化剩余的字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v3 = Vec2 &#123;</span><br><span class="line">    x: <span class="number">14.0</span>,</span><br><span class="line">    ..v2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这被称为”结构体更新语法“，只能用在最后一个位置，且后面不能跟逗号。<br>注意，其余字段可以表示所有字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v4 = Vec2 &#123; ..v3 &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>结构体与元组一样，可以被解构。<br>就和以下是一个有效的<code>let</code>模式一样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (left, right)  slice.split_at(middle);</span><br></pre></td></tr></table></figure>
<p>以下也是如此：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = Vec2 &#123; x: <span class="number">3.0</span>, y: <span class="number">6.0</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> Vec2 &#123; x, y &#125; = v;</span><br><span class="line"><span class="comment">// `x` 为 3.0， `y` 为 6.0</span></span><br></pre></td></tr></table></figure>
<p>以及这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vec2 &#123; x, ..&#125; = v;</span><br><span class="line"><span class="comment">// 将会忽略 `v.y`</span></span><br></pre></td></tr></table></figure>
<p>模式是 Rust 中的特殊语法，它用来匹配类型中的结构和数据，它往往和 <code>match</code> 表达式联用，以实现强大的模式匹配能力。模式一般由以下内容组合而成：</p>
<ul>
<li>字面值</li>
<li>解构的数组、枚举、结构体或者元组</li>
<li>变量</li>
<li>通配符</li>
<li>占位符<br><code>let</code>模式可以用作<code>if</code>的条件：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number</span></span> &#123;</span><br><span class="line">    odd: <span class="built_in">bool</span>,</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> one = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> two = Number &#123; odd: <span class="literal">false</span>, value: <span class="number">2</span> &#125;;</span><br><span class="line">    print_number(one);</span><br><span class="line">    print_number(two);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: Number) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Number &#123; odd: <span class="literal">true</span>, value &#125; = n &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Odd number: &#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> Number &#123; odd: <span class="literal">false</span>, value &#125; = n &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Even number: &#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会输出：</span></span><br><span class="line"><span class="comment">// Odd number: 1</span></span><br><span class="line"><span class="comment">// Even number: 2</span></span><br></pre></td></tr></table></figure>
<code>match</code>分支同样同于模式，就像<code>if let</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: Number) &#123;</span><br><span class="line">    <span class="keyword">match</span> n &#123;</span><br><span class="line">        Number &#123; odd: <span class="literal">true</span>, value &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Odd number: &#123;&#125;&quot;</span>, value),</span><br><span class="line">        Number &#123; odd: <span class="literal">false</span>, value &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Even number: &#123;&#125;&quot;</span>, value),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出与之前相同</span></span><br></pre></td></tr></table></figure>
<code>match</code>是穷尽式的，即至少有一个分支被匹配。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: Number) &#123;</span><br><span class="line">    <span class="keyword">match</span> n &#123;</span><br><span class="line">        Number &#123; value: <span class="number">1</span>, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One&quot;</span>),</span><br><span class="line">        Number &#123; value: <span class="number">2</span>, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Two&quot;</span>),</span><br><span class="line">        Number &#123; value, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, value),</span><br><span class="line">        <span class="comment">// 如果最后一个分支不存在，那么编译器将会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果很难做到匹配所有分支，那么则可以使用<code>_</code>来匹配所有剩余的情况：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: Number) &#123;</span><br><span class="line">    <span class="keyword">match</span> n.value &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One&quot;</span>),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Two&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n.value),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
你可以在自己的类型上声明方法：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number</span></span> &#123;</span><br><span class="line">    odd: <span class="built_in">bool</span>,</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Number &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_strictly_positive</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
并像通常一样使用它们：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> minus_two = Number &#123;</span><br><span class="line">        odd: <span class="literal">false</span>,</span><br><span class="line">        value: -<span class="number">2</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;positive? &#123;&#125;&quot;</span>, minus_two.is_strictly_positive());</span><br><span class="line">    <span class="comment">// 输出 &quot;positive? false&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mut"><a href="#mut" class="headerlink" title="mut"></a>mut</h3>默认情况下，变量绑定是不可变的，这意味着它们的内部状态不能被改变：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123;</span><br><span class="line">        odd: <span class="literal">true</span>,</span><br><span class="line">        value: <span class="number">17</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    n.odd = <span class="literal">false</span>; <span class="comment">// error: cannot assign to `n.odd`,</span></span><br><span class="line">                   <span class="comment">// as `n` is not declared to be mutable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
同时它们也不能被重新赋值：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123;</span><br><span class="line">        odd: <span class="literal">true</span>,</span><br><span class="line">        value: <span class="number">17</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    n = Number &#123;</span><br><span class="line">        odd: <span class="literal">false</span>,</span><br><span class="line">        value: <span class="number">22</span>,</span><br><span class="line">    &#125;; <span class="comment">// error: cannot assign twice to immutable variable `n`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>mut</code>可使变量绑定可变：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> n = Number &#123;</span><br><span class="line">        odd: <span class="literal">true</span>,</span><br><span class="line">        value: <span class="number">17</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    n.value = <span class="number">19</span>; <span class="comment">// 一切顺利</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3>特征(<em>trait</em>)是指多种类型可以共有的共同点：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Signed</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_strictly_negative</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
你可以实现：</li>
<li>对任何人的类型使用你的特征</li>
<li>将任何人的特征用于你的类型</li>
<li>不能将外来特征用于外来类型<br>这被称作孤儿规则(<em>orphan rules</em>)，更为规范的定义是<strong>如果你想要为类型</strong> <code>A</code> <strong>实现特征</strong> <code>T</code><strong>，那么</strong> <code>A</code> <strong>或者</strong> <code>T</code> <strong>至少有一个是在当前作用域中定义的</strong>。<br>这是一个将我们的特征用在我们的类型上的实现：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Signed <span class="keyword">for</span> Number &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_strictly_negative</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value &lt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">false</span>, value: -<span class="number">44</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n.is_strictly_negative()); <span class="comment">// 输出 &quot;true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
将我们的特征用在外来类型（甚至是原始类型）上：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Signed <span class="keyword">for</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_strictly_negative</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> &lt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n: <span class="built_in">i32</span> = -<span class="number">44</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n.is_strictly_negative()); <span class="comment">// 输出 &quot;true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
将外来特征用在我们的类型上：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `Neg` 特征用于重载 `-`，即一元减运算符</span></span><br><span class="line"><span class="keyword">impl</span> std::ops::Neg <span class="keyword">for</span> Number &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = Number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">neg</span></span>(<span class="keyword">self</span>) -&gt; Number &#123;</span><br><span class="line">        Number &#123;</span><br><span class="line">            value: -<span class="keyword">self</span>.value,</span><br><span class="line">            odd: <span class="keyword">self</span>.odd,</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">987</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> m = -n; <span class="comment">// 因为我们实现了 `Neg` 所以可以这样做</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, m.value); <span class="comment">// 输出 &quot;-987&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
一个<code>impl</code>块使用代表一种类型，所以在该块里<code>Self</code>表示该类型：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> std::ops::Neg <span class="keyword">for</span> Number &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = <span class="keyword">Self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">neg</span></span>(<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            value: -<span class="keyword">self</span>.value,</span><br><span class="line">            odd: <span class="keyword">self</span>.odd,</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
有一些特征是标记(<em>marker</em>)，它们并不是指该类型实现了某些方法，而是指可以用该类型完成某些事情。<br>例如，<code>i32</code>实现了特征<code>Copy</code>（简单说<code>i32</code>是<code>Copy</code>），所以以下是可行的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a: <span class="built_in">i32</span> = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">let</span> b = a; <span class="comment">// `a` 被复制</span></span><br><span class="line">    <span class="keyword">let</span> c = a; <span class="comment">// `a` 再次被复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
同时以下也可行：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_i32</span></span>(x: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a: <span class="built_in">i32</span> = <span class="number">15</span>;</span><br><span class="line">    print_i32(a); <span class="comment">// `a` 被复制</span></span><br><span class="line">    print_i32(a); <span class="comment">// `a` 再次被复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但是<code>Number</code>结构体不是<code>Copy</code>，所以以下是不可行的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">51</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> m = n; <span class="comment">// `n` 被移动至 `m`</span></span><br><span class="line">    <span class="keyword">let</span> o = n; <span class="comment">// error: use of moved value: `n`</span></span><br><span class="line">    <span class="comment">// 因为试图使用一个已经被移动过的值而报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以下也是如此：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: Number) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; number &#123;&#125;&quot;</span>, <span class="keyword">if</span> n.odd &#123; <span class="string">&quot;odd&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;even&quot;</span> &#125;, n.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">51</span> &#125;;</span><br><span class="line">    print_number(n); <span class="comment">// `n` 被移动</span></span><br><span class="line">    print_number(n); <span class="comment">// error: use of moved value: `n`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但是如果<code>print_number</code>使用不可变引用，那么它就可以工作：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: &amp;Number) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; number &#123;&#125;&quot;</span>, <span class="keyword">if</span> n.odd &#123; <span class="string">&quot;odd&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;even&quot;</span> &#125;, n.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">51</span> &#125;;</span><br><span class="line">    print_number(&amp;n); <span class="comment">// `n` 被引用给这次调用</span></span><br><span class="line">    print_number(&amp;n); <span class="comment">// `n` 再次被引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果函数采用可变引用，那么也可以工作，前提是我们的变量绑定也是<code>mut</code>。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">invert</span></span>(n: &amp;<span class="keyword">mut</span> Number) &#123;</span><br><span class="line">    n.value = -n.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_number</span></span>(n: &amp;Number) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; number &#123;&#125;&quot;</span>, <span class="keyword">if</span> n.odd &#123; <span class="string">&quot;odd&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;even&quot;</span> &#125;, n.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 这一次 `n` 是可变的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">51</span> &#125;;</span><br><span class="line">    print_number(&amp;n);</span><br><span class="line">    invert(&amp;<span class="keyword">mut</span> n); <span class="comment">// `n 被可变引用，一切都是明确的</span></span><br><span class="line">    print_number(&amp;n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
特征方法还可以通过引用或者可变引用获取<code>self</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> std::clone::<span class="built_in">Clone</span> <span class="keyword">for</span> Number &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ..*<span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当调用特征方法时，接受者被隐式引用：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">51</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> m = n.clone();</span><br><span class="line">    m.value += <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    print_number(&amp;n);</span><br><span class="line">    print_number(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
为了强调这一点，以下写法是等效的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = n.clone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = std::clone::<span class="built_in">Clone</span>::clone(&amp;n);</span><br></pre></td></tr></table></figure>
像<code>Copy</code>这样的标记特征没有方法：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：`Copy` 需要 `Clone` 也被实现</span></span><br><span class="line"><span class="keyword">impl</span> std::clone::<span class="built_in">Clone</span> <span class="keyword">for</span> Number &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ..*<span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
现在<code>Clone</code>仍然可以被使用：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: <span class="literal">true</span>, value: <span class="number">51</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> m = n.clone();</span><br><span class="line">    <span class="keyword">let</span> o = n.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但是<code>Number</code>的值不会再被移动：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; odd: trie, value: <span class="number">51</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> m = n; <span class="comment">// `m` 是 `n` 的一个拷贝</span></span><br><span class="line">    <span class="keyword">let</span> o = n; <span class="comment">// 同样，`n` 不再会被移动或引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
有些特征非常常见，可以使用<code>derive</code>属性自动实现：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone, Copy)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number</span></span> &#123;</span><br><span class="line">    odd: <span class="built_in">bool</span>,</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这将会展开成 `impl Clone for Number` 和 `impl Copy for Number` 块</span></span><br></pre></td></tr></table></figure>
<h3 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型(Generics)"></a>泛型(<em>Generics</em>)</h3>函数可以是泛型化的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;T&gt;(arg: T) &#123;</span><br><span class="line">    <span class="comment">// 与 `arg` 相关的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
它们可以有多个类型参数，然后可以在函数的声明及其主体中使用这些参数，而不是具体类型：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;L, R&gt;(left: L, right: R) &#123;</span><br><span class="line">    <span class="comment">// 与 `left` 和 `right` 相关的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
类型参数通常由约束(<em>constraint</em>)，所以实际上你可以用它们来做一些事情。<br>最简单的约束是特征名称：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>&lt;T: Display&gt;(value: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value = &#123;&#125;&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>&lt;T: <span class="built_in">Debug</span>&gt;(value: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value = &#123;:?&#125;&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
类型参数约束由一种更长的语法：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>&lt;T&gt;(value: T)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value = &#123;&#125;&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
约束可以更复杂：它们可能需要类型参数实现多个特征：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">compare</span></span>&lt;T&gt;(left: T, right: T)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T:<span class="built_in">Debug</span> + <span class="built_in">PartialEq</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &#123;&#125; &#123;:?&#125;&quot;</span>, left, <span class="keyword">if</span> left == right &#123; <span class="string">&quot;==&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;!=&quot;</span> &#125;, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    compare(<span class="string">&quot;tea&quot;</span>, <span class="string">&quot;coffee&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出 &quot;tea != coffee&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
泛型函数可以被认为是命名空间，包含无穷个具有不同具体类型的函数。<br>与包，模块和类型相同，可以对泛型函数使用<code>::</code><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::any::type_name;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, type_name::&lt;<span class="built_in">i32</span>&gt;()); <span class="comment">// 输出 &quot;i32&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, type_name::&lt;(<span class="built_in">f64</span>, <span class="built_in">char</span>)&gt;()); <span class="comment">// 输出 &quot;(f64, char)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这被亲切地称为 turbofish 语法，因为<code>::&lt;&gt;</code>看起来像一条鱼。<br>结构也可以泛型化：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>&lt;T&gt; &#123;</span><br><span class="line">    a: T,</span><br><span class="line">    b: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_type_name</span></span>&lt;T&gt;(_val: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, std::any::type_name::&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = Pair &#123; a: <span class="number">3</span>, b: <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> p2 = Pair &#123; a: <span class="literal">true</span>, b: <span class="literal">false</span>&#125;;</span><br><span class="line">    print_type_name(&amp;p1);</span><br><span class="line">    print_type_name(&amp;p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
标准库类型<code>Vec</code>（或者说堆分配的数组）是泛型化的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v1 = <span class="built_in">Vec</span>::new();</span><br><span class="line">    v1.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v2 = <span class="built_in">Vec</span>::new();</span><br><span class="line">    v2.push(<span class="literal">false</span>);</span><br><span class="line">    print_type_name(&amp;v1); <span class="comment">// prints &quot;Vec&lt;i32&gt;&quot;</span></span><br><span class="line">    print_type_name(&amp;v2); <span class="comment">// prints &quot;Vec&lt;bool&gt;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3>说到<code>Vec</code>，它带有一个宏，可以提供或多或少的”vec 字面量“：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="built_in">vec!</span>[<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>];</span><br><span class="line">    print_type_name(&amp;v1);</span><br><span class="line">    print_type_name(&amp;v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
所有的<code>name!()</code>，<code>name![]</code>和<code>name!&#123;&#125;</code>都会调用宏。宏只是展开成常规代码。<br>实际上<code>println</code>是一个宏：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Hello there!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这会展开成具有相同效果的东西：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line">    io::stdout().lock().write_all(<span class="string">b&quot;Hello there!\n&quot;</span>).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>panic</code>也是一个宏，它会猛烈地停止执行并显示错误消息和文件名 / 行号：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;This panics&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
有些方法也会出现<code>panic</code>。例如，<code>Option</code>类型可以包含某些内容，也可以不包含任何内容。如果<code>.unwrap()</code>被调用，并且它不包括任何内容，那么就会发生<code>panic</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> o1: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">Some</span>(<span class="number">128</span>);</span><br><span class="line">    o1.unwrap(); <span class="comment">// this is fine</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> o2: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    o2.unwrap(); <span class="comment">// this panics!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: thread &#x27;main&#x27; panicked at &#x27;called `Option::unwrap()` on a `None` value&#x27;, src/libcore/option.rs:378:21</span></span><br></pre></td></tr></table></figure>
<code>Option</code>不是一个结构体，它是一个枚举(<code>enum</code>)，有两个成员：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">num <span class="built_in">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unwrap</span></span>(<span class="keyword">self</span>) -&gt; T &#123;</span><br><span class="line">        <span class="comment">// 枚举成员可以被用在模式中：</span></span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Self::<span class="literal">Some</span>(t) =&gt; t,</span><br><span class="line">            Self::<span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;.unwrap() called on a None option&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> self::<span class="built_in">Option</span>::&#123;<span class="literal">None</span>, <span class="literal">Some</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> o1: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">Some</span>(<span class="number">128</span>);</span><br><span class="line">    o1.unwrap(); <span class="comment">// this is fine</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> o2: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    o2.unwrap(); <span class="comment">// this panics!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: thread &#x27;main&#x27; panicked at &#x27;.unwrap() called on a None option&#x27;, src/main.rs:11:27</span></span><br></pre></td></tr></table></figure>
<code>Result</code>也是一个枚举，它可以包含某些内容，也可以包含错误：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
若调用<code>unwrap</code>时包含错误，那么它也会<code>panic</code>。<h3 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a>变量绑定</h3>变量绑定拥有一个”生命周期“：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// `x` 还不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">42</span>; <span class="comment">// `x` 开始存在</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, x);</span><br><span class="line">        <span class="comment">// `x` 停止存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// `x` 不再存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
同样，引用也有生命周期：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// `x` 还不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">42</span>; <span class="comment">// `x` 开始存在</span></span><br><span class="line">        <span class="keyword">let</span> x_ref = &amp;x; <span class="comment">// `x_ref` 开始存在 - 它引用 `x`</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x_ref = &#123;&#125;&quot;</span>, x_ref);</span><br><span class="line">        <span class="comment">// `x_ref` 停止存在</span></span><br><span class="line">        <span class="comment">// `x` 停止存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// `x` 不再存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
引用的生命周期不能超过它引用的变量绑定的生命周期：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x_ref = &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">42</span>;</span><br><span class="line">        &amp;x</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x_ref = &#123;&#125;&quot;</span>, x_ref);</span><br><span class="line">    <span class="comment">// error: `x` does not live long enough</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
变量绑定可以不可变地被多次引用：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> x_ref1 = &amp;x;</span><br><span class="line">    <span class="keyword">let</span> x_ref2 = &amp;x;</span><br><span class="line">    <span class="keyword">let</span> x_ref3 = &amp;x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, x_ref1, x_ref2, x_ref3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当被引用时，变量绑定不能改变：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> x_ref = &amp;x;</span><br><span class="line">    x = <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x_ref = &#123;&#125;&quot;</span>, x_ref);</span><br><span class="line">    <span class="comment">// error: cannot assign to `x` because it is borrowed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当被不可变引用时，变量不能被可变引用：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> x_ref1 = &amp;x;</span><br><span class="line">    <span class="keyword">let</span> x_ref2 = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">    <span class="comment">// error: cannot borrow `x` as mutable because it is also borrowed as immutable</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x_ref1 = &#123;&#125;&quot;</span>, x_ref1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
函数参数中的引用也有生命周期：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>(x: &amp;<span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="comment">// `x` 是从外部被引用的，可用在该次函数调用的全过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
具有引用参数的函数可以通过具有不同声明周期的引用来调用，因此：</li>
<li>所有接受引用的函数都是泛型化的</li>
<li>生命周期是泛型参数<br>生命周期的参数以单引号<code>&#39;</code>开头：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式（匿名）生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>(x: &amp;<span class="built_in">i32</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
使返回的引用的生命周期取决于参数的生命周期：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">number_value</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(num: &amp;<span class="symbol">&#x27;a</span> Number) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    &amp;num.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = Number &#123; value: <span class="number">47</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> v = number_value(&amp;n);</span><br><span class="line">    <span class="comment">// `v` 是 `n` 的不可变引用，因此 `v` 的生命周期不能超过 `n`.</span></span><br><span class="line">    <span class="comment">// 当 `v` 存在时，`n` 不能被可变引用，改变，移动等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当只有一个生命周期输入时，不需要命名，所有变量都具有相同的生命周期，因此以下两个函数是等效的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">number_value</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(num: &amp;<span class="symbol">&#x27;a</span> Number) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    &amp;num.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">number_value</span></span>(num: &amp;Number) -&gt; &amp;<span class="built_in">i32</span> &#123;</span><br><span class="line">    &amp;num.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>结构体也可以使用生命周期泛型，使其可以保存引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumRef</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">let</span> x_ref = NumRef &#123; x: &amp;x &#125;;</span><br><span class="line">    <span class="comment">// `x_ref` 的生命周期不能长于 `x`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加个相关函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumRef</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">as_num_ref</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>) -&gt; NumRef&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    NumRef &#123; x: &amp;x &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">let</span> x_ref = NumRef &#123; x: &amp;x &#125;;</span><br><span class="line">    <span class="comment">// `x_ref` 的生命周期不能长于 `x`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数中省写生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumRef</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">as_num_ref</span></span>(x: &amp;<span class="built_in">i32</span>) -&gt; NumRef&lt;<span class="symbol">&#x27;_</span>&gt; &#123;</span><br><span class="line">    NumRef &#123; x: &amp;x &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">let</span> x_ref = NumRef &#123; x: &amp;x &#125;;</span><br><span class="line">    <span class="comment">// `x_ref` 的生命周期不能长于 `x`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>impl</code>块也可以这样操作：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; NumRef&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">as_i32_ref</span></span>(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">let</span> x_num_ref = NumRef &#123; x: &amp;x &#125;;</span><br><span class="line">    <span class="keyword">let</span> x_i32_ref = x_num_ref.as_i32_ref();</span><br><span class="line">    <span class="comment">// 引用的生命周期都不能长于 `x`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以这样省写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; NumRef&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">as_i32_ref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不需要用到变量名，那可以更简单：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> NumRef&lt;<span class="symbol">&#x27;_</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">as_i32_ref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个特殊的生命周期，即静态<code>&#39;static</code>，代表在整个程序的生命周期中都保持有效。<br>字符串字面量是<code>&#39;static</code>的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Person &#123;</span><br><span class="line">        name: <span class="string">&quot;fasterthanlime&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是持有字符串(<em>owned string</em>)不是静态的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="built_in">format!</span>(<span class="string">&quot;fasterthan&#123;&#125;&quot;</span>, <span class="string">&quot;lime&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> p = Person &#123; name: &amp;name &#125;;</span><br><span class="line">    <span class="comment">// error: `name` does not live long enough</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>name</code>不是<code>&amp;&#39;static str</code>而是<code>String</code>。它是被动态分配并且会被释放的，即其生命周期小于整个程序（即使其恰好位于<code>main</code>中）<br>如果要将非<code>&#39;static</code>字符串存储在<code>Person</code>中，有以下两种方法：<br>A. 使用生命周期泛型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="built_in">format!</span>(<span class="string">&quot;fasterthan&#123;&#125;&quot;</span>, <span class="string">&quot;lime&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> p = Person &#123; name: &amp;name &#125;;</span><br><span class="line">    <span class="comment">// `p` 的生命周期不能长于 `name`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B. 获取字符串的所有权</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="built_in">format!</span>(<span class="string">&quot;faterthan&#123;&#125;&quot;</span>, <span class="string">&quot;lime&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> p = Person &#123; name: name &#125;;</span><br><span class="line">    <span class="comment">// `name` 被移动到 `p`，它们的生命周期不再被限制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，在结构体字面量中，如果即将字段设置为同名的变量绑定时，可以简写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = Person &#123; name: name &#125;;</span><br><span class="line"><span class="comment">// 可悲简写为</span></span><br><span class="line"><span class="keyword">let</span> p = Person &#123; name &#125;;</span><br></pre></td></tr></table></figure>
<p>对于 Rust 中的许多类型，都有所有权(<em>owned</em>)和无所有权(<em>non-owned</em>)两种变体：</p>
<ul>
<li>字符串：<code>String</code> 是有所有权的，<code>&amp;str</code> 是引用</li>
<li>路径：<code>PathBuf</code> 是有所有权的，<code>&amp;Path</code> 是引用</li>
<li>集合：<code>Vec&lt;T&gt;</code> 是有所有权的，<code>&amp;[T]</code> 是引用<br>在 Rust 中，所有权有以下规则：</li>
</ul>
<ol>
<li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</li>
<li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</li>
<li>当所有者(变量)离开作用域范围时，这个值将被丢弃(<em>drop</em>)<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3>切片(<em>slice</em>)是对多个连续元素的<strong>引用</strong>。<br>你可以引用一个向量的切片，例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> v2 = &amp;v[<span class="number">2</span>..<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;v2 = &#123;:?&#125;&quot;</span>, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// v2 = [3, 4]</span></span><br></pre></td></tr></table></figure>
上面的操作并不神奇。索引操作符<code>foo[index]</code>重载了<code>Index</code>和<code>IndexMut</code>特征。<br><code>..</code>语法只是范围(<em>range</em>)字面量，范围是标准库中定义的结构体。<br>切片区间可以是开放的，右边界可以是闭的，如果前面有<code>=</code>的话。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 大于等于 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, (<span class="number">0</span>..).contains(&amp;<span class="number">100</span>)); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 严格小于 20</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, (..<span class="number">20</span>).contains(&amp;<span class="number">20</span>)); <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// 小于等于 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, (..=<span class="number">20</span>).contains(&amp;<span class="number">20</span>)); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 只包含 3, 4, 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, (<span class="number">3</span>..<span class="number">6</span>).contions(&amp;<span class="number">4</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
引用规则同样适用于切片：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">tail</span></span>(s: &amp;[<span class="built_in">u8</span>]) -&gt; &amp;[<span class="built_in">u8</span>] &#123;</span><br><span class="line">    &amp;s[<span class="number">1</span>..]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> y = tail(x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;:?&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
一样地，<code>tail</code>函数也可以这样写：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">tail</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> [<span class="built_in">u8</span>]) -&gt; &amp;<span class="symbol">&#x27;a</span> [<span class="built_in">u8</span>] &#123;</span><br><span class="line">    &amp;s[<span class="number">1</span>..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以下代码是合规的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y = &#123;</span><br><span class="line">        <span class="keyword">let</span> x = &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">        tail(x)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;:?&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但这只是因为<code>&amp;[1, 2, 3, 4, 5]</code>是一个<code>&#39;static</code>数组。<br>所以以下是不可行的：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y = &#123;</span><br><span class="line">        <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">        tail(&amp;v);</span><br><span class="line">        <span class="comment">//error: `v` does not live long enough</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;:?&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这是因为向量是堆分配的(<em>heap-allocated</em>)，并且它的生命周期不是<code>&#39;static</code><br><code>&amp;str</code>值实际上是切片。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_ext</span></span>(name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="built_in">str</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 这不会返回一个新的字符串</span></span><br><span class="line">    <span class="comment">// 而是返回参数的一个切片</span></span><br><span class="line">    name.split(<span class="string">&quot;.&quot;</span>).last()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&quot;Read me. Or don&#x27;t.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(ext) = file_ext(name) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;file extension: &#123;&#125;&quot;</span>, ext);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;no file extension&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
所以引用规则也同样适用：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> ext = &#123;</span><br><span class="line">        <span class="keyword">let</span> name = <span class="built_in">String</span>::from(<span class="string">&quot;Read me. Or don&#x27;t.txt&quot;</span>);</span><br><span class="line">        file_ext(&amp;name).unwarp_or(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="comment">// error: `name` does not live long enough</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;extension: &#123;:?&#125;&quot;</span>, ext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3>可能会出错的函数通常会返回<code>Result</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">240</span>, <span class="number">159</span>, <span class="number">141</span>, <span class="number">137</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">    <span class="comment">// 输出：Ok(&quot;🍉&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s = std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">195</span>, <span class="number">40</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">    <span class="comment">// 输出：Err(Utf8Error &#123; valid_up_to: 0, error_len: Some(1) &#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果你想在出错的时候<code>panic</code>，则可以使用<code>.unwarp()</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">240</span>, <span class="number">159</span>, <span class="number">141</span>, <span class="number">137</span>]).unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">    <span class="comment">// 输出：&quot;🍉&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s = std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">195</span>, <span class="number">40</span>]).unwrap();</span><br><span class="line">    <span class="comment">// 输出：thread &#x27;main&#x27; panicked at &#x27;called `Result::unwrap()`</span></span><br><span class="line">    <span class="comment">// on an `Err` value: Utf8Error &#123; valid_up_to: 0, error_len: Some(1) &#125;&#x27;,</span></span><br><span class="line">    <span class="comment">// src/libcore/result.rs:1165:5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
或者<code>expect()</code>，用来自定义报错消息：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">195</span>, <span class="number">40</span>]).expect(<span class="string">&quot;valid utf-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出：thread &#x27;main&#x27; panicked at &#x27;valid utf-8: Utf8Error</span></span><br><span class="line">    <span class="comment">// &#123; valid_up_to: 0, error_len: Some(1) &#125;&#x27;, src/libcore/result.rs:1165:5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
或者你可以使用<code>match</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">240</span>, <span class="number">159</span>, <span class="number">141</span>, <span class="number">137</span>]) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s).</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="built_in">println!</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出：🍉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
或者使用<code>if let</code>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(s) = std::std::from_utf8(&amp;[<span class="number">240</span>, <span class="number">159</span>, <span class="number">141</span>, <span class="number">137</span>]) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出：🍉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
或者你可以将错误提升出来：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), std::<span class="built_in">str</span>::Utf8Error&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">240</span>, <span class="number">159</span>, <span class="number">141</span>, <span class="number">137</span>]) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s),</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
你可以使用<code>?</code>来以更简洁的方式完成此操作：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), std::<span class="built_in">str</span>::Utf8Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> s = std::<span class="built_in">str</span>::from_utf8(&amp;[<span class="number">240</span>, <span class="number">159</span>, <span class="number">141</span>, <span class="number">137</span>])?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>*</code>运算符可用于取消引用(<em>dereference</em>)，但是你在访问字段和调用方法的时候并不需要用到：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f64</span>,</span><br><span class="line">    y: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">3.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> p_ref = &amp;p;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, p_ref.x, p_ref.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 `(1, 3)`</span></span><br></pre></td></tr></table></figure>
只有当类型为<code>Copy</code>的时候才能这样操作：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f64</span>,</span><br><span class="line">    y: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">negate</span></span>(p: Point) -&gt; Point &#123;</span><br><span class="line">    Point &#123;</span><br><span class="line">        x: -p.x,</span><br><span class="line">        y: -p.y,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">3.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> p_ref = &amp;p;</span><br><span class="line">    negate(*p_ref);</span><br><span class="line">    <span class="comment">// error: cannot move out of `*p_ref` which is behind a shared reference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在 `Point` 是 `Copy`</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f64</span>,</span><br><span class="line">    y: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">negate</span></span>(p: Point) -&gt; Point &#123;</span><br><span class="line">    Point &#123;</span><br><span class="line">        x: -p.x,</span><br><span class="line">        y: -p.y,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">3.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> p_ref = &amp;p;</span><br><span class="line">    negate(*p_ref); <span class="comment">// 并且现在不会报错了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包(<em>closure</em>)只是<code>Fn</code>，<code>FnMut</code>和<code>FnOnce</code>类型的函数加上捕获传递的上下文。<br>它们的参数是被一对管道(<code>|</code>)包括，用逗号分隔的。它们不需要花括号，除非你需要多条语句。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">for_each_planet</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>)</span><br><span class="line">&#123;</span><br><span class="line">    f(<span class="string">&quot;Earth&quot;</span>);</span><br><span class="line">    f(<span class="string">&quot;Mars&quot;</span>);</span><br><span class="line">    f(<span class="string">&quot;Jupiter&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    for_each_planet(|planet| <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;&quot;</span>, planet));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Hello, Earth</span></span><br><span class="line"><span class="comment">// Hello, Mars</span></span><br><span class="line"><span class="comment">// Hello, Jupiter</span></span><br></pre></td></tr></table></figure>
<p>引用规则同样适用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">for_each_planet</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>)</span><br><span class="line">&#123;</span><br><span class="line">    f(<span class="string">&quot;Earth&quot;</span>);</span><br><span class="line">    f(<span class="string">&quot;Mars&quot;</span>);</span><br><span class="line">    f(<span class="string">&quot;Jupiter&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="built_in">String</span>::from(<span class="string">&quot;Good to see you&quot;</span>);</span><br><span class="line">    for_each_planet(|planet| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, greeting, planet));</span><br><span class="line">    <span class="comment">// 我们的闭包引用了 `greeting`，所以其生命周期不能长于它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如以下是无法工作的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">for_each_planet</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>) + <span class="symbol">&#x27;static</span> <span class="comment">// `F` 必须是 &quot;&#x27;static&quot; 生命周期</span></span><br><span class="line">&#123;</span><br><span class="line">    f(<span class="string">&quot;Earth&quot;</span>);</span><br><span class="line">    f(<span class="string">&quot;Mars&quot;</span>);</span><br><span class="line">    f(<span class="string">&quot;Jupiter&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="built_in">String</span>::from(<span class="string">&quot;Good to see you&quot;</span>);</span><br><span class="line">    for_each_planet(|planet| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, greeting, planet));</span><br><span class="line">    <span class="comment">// error: closure may outlive the current function, but it borrows</span></span><br><span class="line">    <span class="comment">// `greeting`, which is owned by the current function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样可以：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="built_in">String</span>::from(<span class="string">&quot;You&#x27;re doing great&quot;</span>);</span><br><span class="line">    for_each_planet(<span class="keyword">move</span> |planet| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, greeting, planet));</span><br><span class="line">    <span class="comment">// `greeting` 不再被引用，它被移动到该闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FnMut</code>需要被可变引用才能被调用，因此一次传参只能调用一次。<br>以下是可行的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f(f(<span class="number">2</span>))); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foobar(|x| x * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：8</span></span><br></pre></td></tr></table></figure>
<p>但以下不能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(<span class="keyword">mut</span> f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">FnMut</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f(f(<span class="number">2</span>))); </span><br><span class="line">    <span class="comment">// error: cannot borrow `f` as mutable more than once at a time</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foobar(|x| x * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样则可行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(<span class="keyword">mut</span> f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">FnMut</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = f(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f(tmp)); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foobar(|x| x * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：8</span></span><br></pre></td></tr></table></figure>
<p><code>FnMut</code>的存在是因为某些闭包会可变引用本地变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(<span class="keyword">mut</span> f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">FnMut</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = f(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f(tmp)); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> acc = <span class="number">2</span>;</span><br><span class="line">    foobar(|x| &#123;</span><br><span class="line">        acc += <span class="number">1</span>;</span><br><span class="line">        x * acc</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：24</span></span><br></pre></td></tr></table></figure>
<p>这些闭包不能传递给需要<code>Fn</code>的函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f(f(<span class="number">2</span>))); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> acc = <span class="number">2</span>;</span><br><span class="line">    foobar(|x| &#123;</span><br><span class="line">        acc += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// error: cannot assign to `acc`, as it is a</span></span><br><span class="line">        <span class="comment">// captured variable in a `Fn` closure.</span></span><br><span class="line">        <span class="comment">// the compiler suggests &quot;changing foobar</span></span><br><span class="line">        <span class="comment">// to accept closures that implement `FnMut`&quot;</span></span><br><span class="line">        x * acc</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FnOnce</code>闭包只能调用一次。它们的存在是因为某些闭包会移出在捕获时就已被移动的变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">FnOnce</span>() -&gt; <span class="built_in">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f()); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;alright&quot;</span>);</span><br><span class="line">    foobar(<span class="keyword">move</span> || s);</span><br><span class="line">    <span class="comment">// `s` 被移动到我们的闭包中</span></span><br><span class="line">    <span class="comment">// 并且我们的闭包通过返回将其移动到调用这中</span></span><br><span class="line">    <span class="comment">// 记住 `String` 不是 `Copy`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是默认强制执行的，因为<code>FnOnce</code>闭包需要移动才能被调用。<br>例如以下是不可行的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(f: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">FnOnce</span>() -&gt; <span class="built_in">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f()); </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f()); </span><br><span class="line">    <span class="comment">// error: use of moved value: `f`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你对我们的闭包是否确实移动了<code>s</code>有疑问，以下也是不可行的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;alright&quot;</span>);</span><br><span class="line">    foobar(<span class="keyword">move</span> || s);</span><br><span class="line">    foobar(<span class="keyword">move</span> || s);</span><br><span class="line">    <span class="comment">// 使用了被移动的值：`s`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这是可行的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;alright&quot;</span>);</span><br><span class="line">    foobar(|| s.clone());</span><br><span class="line">    foobar(|| s.clone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是带有两个参数的闭包：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;F&gt;(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>, is_greater: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>) -&gt; <span class="built_in">bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> (greater, smaller) = <span class="keyword">if</span> is_greater(x, y) &#123;</span><br><span class="line">        (x, y)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (y, x)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is greater than &#123;&#125;&quot;</span>, greater, smaller);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foobar(<span class="number">32</span>, <span class="number">64</span>, |x, y| x &gt; y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个忽略其两个参数的闭包：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foobar(<span class="number">32</span>, <span class="number">64</span>, |_, _| <span class="built_in">panic!</span>(<span class="string">&quot;Comparing is futile!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个有点吓人的闭包（指输出）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">countdown</span></span>&lt;F&gt;(count: <span class="built_in">usize</span>, tick: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(<span class="built_in">usize</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..=count).rev() &#123;</span><br><span class="line">        tick(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    countdown(<span class="number">3</span>, |i| <span class="built_in">println!</span>(<span class="string">&quot;tick &#123;&#125;...&quot;</span>, i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// tick 3...</span></span><br><span class="line"><span class="comment">// tick 2...</span></span><br><span class="line"><span class="comment">// tick 1...</span></span><br></pre></td></tr></table></figure>
<p>这是马桶闭包：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    countdown(<span class="number">3</span>, |_| ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以这么称呼是因为<code>|_| ()</code>看起来像马桶。</p>
<h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><p>任何可迭代的东西都可以在<code>for in</code>循环中使用。<br>我们刚刚演示了在范围上使用，但实际上它也适用于向量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">vec!</span>[<span class="number">52</span>, <span class="number">49</span>, <span class="number">21</span>] &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;I like the number &#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是切片：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;[<span class="number">52</span>, <span class="number">49</span>, <span class="number">21</span>] &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;I like thw number &#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// I like the number 52</span></span><br><span class="line"><span class="comment">// I like the number 49</span></span><br><span class="line"><span class="comment">// I like the number 21</span></span><br></pre></td></tr></table></figure>
<p>或者是一个实际的迭代器(<em>iterator</em>)：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 注意：`&amp;str` 还有个 `.bytes()` 迭代器</span></span><br><span class="line">    <span class="comment">// Rust 的 `char` 类型是一个 Unicode 标量值</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;rust&quot;</span>.chars() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Give me a &#123;&#125;&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Give me a r</span></span><br><span class="line"><span class="comment">// Give me a u</span></span><br><span class="line"><span class="comment">// Give me a s</span></span><br><span class="line"><span class="comment">// Give me a t</span></span><br></pre></td></tr></table></figure>
<p>即使迭代器的成员被过滤(<em>filter</em>)，映射(<em>map</em>)和展平(<em>flat</em>)：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;SuRPRISE INbOUND&quot;</span></span><br><span class="line">        .chars()</span><br><span class="line">        .filter(|c| c.is_lowercase())</span><br><span class="line">        .flat_map(|c| c.to_uppercase())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：UB</span></span><br></pre></td></tr></table></figure>
<p>你可以从函数中返回一个闭包：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">make_tester</span></span>(answer: <span class="built_in">String</span>) -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(&amp;<span class="built_in">str</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">move</span> |challenge| &#123;</span><br><span class="line">        challenge == answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 你可以使用 `.into()` 在类型变种间实施转换</span></span><br><span class="line">    <span class="comment">// 例如 `&amp;&#x27;static str` 和 `String`</span></span><br><span class="line">    <span class="keyword">let</span> test = make_tester(<span class="string">&quot;hunter2&quot;</span>.into());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, test(<span class="string">&quot;******&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, test(<span class="string">&quot;hunter2&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你甚至可以将函数参数的引用移动到它所返回的闭包中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">make_tester</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(answer: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(&amp;<span class="built_in">str</span>) -&gt; <span class="built_in">bool</span> + <span class="symbol">&#x27;a</span> &#123;</span><br><span class="line">    <span class="keyword">move</span> |challenge| &#123;</span><br><span class="line">        challenge == answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> test = make_tester(<span class="string">&quot;hunter2&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, test(<span class="string">&quot;*******&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, test(<span class="string">&quot;hunter2&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>以及，省写生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">make_tester</span></span>(answer: &amp;<span class="built_in">str</span>) -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(&amp;<span class="built_in">str</span>) -&gt; <span class="built_in">bool</span> + <span class="symbol">&#x27;_</span> &#123;</span><br><span class="line">    <span class="keyword">move</span> |challenge| &#123;</span><br><span class="line">        challenge == answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>到此，本文就结束了，现在你应该能够阅读他人的 Rust 代码。如果你想更进一步的学习，那么你可以查看：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://course.rs/">Rust语言圣经</a></li>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/rust-by-example/">Rust By Example</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rustlang-cn/rusty-book">锈书</a><br>但无论如何，希望你能记住：<blockquote>
<p>If you didn’t code, you didn’t learn.</p>
</blockquote>
</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://weifeng233.github.io/2024/02/17/%E5%8D%8A%E5%B0%8F%E6%97%B6%E9%80%9F%E9%80%9ARust/" title="半小时速通Rust" target="_blank" rel="external">https://weifeng233.github.io/2024/02/17/半小时速通Rust/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/weifeng233" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/ava.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/weifeng233" target="_blank"><span class="text-dark">Sugar Breeze</span><small class="ml-1x">MCBE Modder.</small></a></h3>
        <div>这个好像是自我介绍，那就这样吧</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    
    <li class="next">
      <a href="/2024/01/18/zote-core-loader/" title="InnerCore 第三方服务端 Zote Core 介绍"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/weifeng233" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: 'Jno3r2maUl40NYvI7whuU17a-gzGzoHsz',
    appKey: 'Lj5ksxOm87ao4qDsPHd02k0M',
    placeholder: '欢迎留言，虽然我一般不看',
    avatar: 'retro',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>